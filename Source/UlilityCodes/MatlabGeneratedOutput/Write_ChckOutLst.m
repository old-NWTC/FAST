% this script reads the an Excel file containing the parameters for an
% Output module and writes some Fortran code containing appropriate
% parameters (which can be imported into the output module).
 

clear all

ProgName = input('Enter the program for which the output module will be generated: ','s');

if strcmpi(ProgName,'FAST')
    OutListSheet = 'OutList';
    
    XLS_file = 'D:\DATA\DesignCodes\simulators\FAST\SVNdirectory\trunk\OutListParameters.xlsx';
    out_file = 'ChckOutLst_MatlabGen.f90';
    mod_file = 'Mods_MatlabGen.f90';

elseif strcmpi(ProgName,'HydroDyn')
    OutListSheet = 'HydroDyn';

    XLS_file = 'Y:\Wind\Public\Projects\DesignCodes\Simulators\HydroDyn\Release\Source\VersionsInProgress\v1.00.00b-jbj\Documents\HydroDynOutListParameters.xlsx';
    out_file = 'Y:\Wind\Public\Projects\DesignCodes\Simulators\HydroDyn\Release\Source\VersionsInProgress\v1.00.00b-jbj\FilesFromFASTv6.10d-jmj\ChckOutLst_MatlabGen.f90';
    mod_file = 'Y:\Wind\Public\Projects\DesignCodes\Simulators\HydroDyn\Release\Source\VersionsInProgress\v1.00.00b-jbj\FilesFromFASTv6.10d-jmj\Mods_MatlabGen.f90';
else
    error('Invalid program name.');
end

CLen     = 9;    %length of character array in FORTRAN code
UNLen    = 10;   %length of character array storing the units
numPerR  = 7;    %number of parameters per row of code

[~, ~, raw] = xlsread( XLS_file, OutListSheet);

% create variables from the column headings: Category, InputNUM, OutInd,
% SORTName, UniqueVals, Invalid_Channel_Criteria, Units
for iCol = 1:size(raw,2)
   
    if ischar(raw{1,iCol})
        if strcmpi(raw{1,iCol},'Name')
            Module_VarName = raw(2:end,iCol);
        elseif strfind( raw{1,iCol}, 'Other Name' )
            Module_InputStr = raw(2:end,iCol);
        elseif strfind( raw{1,iCol}, 'Units' )
            Units = raw(2:end,iCol);
        elseif strfind( raw{1,iCol}, 'Invalid Channel Criteria' )
            InvalidCriteria = raw(2:end,iCol);
        end
    end
    
end

%% write the "Module_VarName"s to the module that defines them
[~,tmpFileName,tmpExt] = fileparts(XLS_file);
tmpFileName = [tmpFileName tmpExt];

fout = fopen( mod_file, 'wt' );
fprintf( fout, '%s\n',      '! ==================================================================================================="' );
fprintf( fout, '%s\n',      '! NOTE: The following lines of code were generated by a Matlab script called "Write_ChckOutLst.m"' );
fprintf( fout, '%s%s%s\n',  '!      using the parameters listed in the "',tmpFileName,'" Excel file. Any changes to these ' );
fprintf( fout, '%s\n',      '!      lines should be modified in the Matlab script and/or Excel worksheet as necessary. ');
fprintf( fout, '%s\n',      '! ==================================================================================================="' );
fprintf( fout, '%s\n',     ['! This code was generated by Write_ChckOutLst.m at ' datestr(now) '.'] );

% fprintf( fout, '%s\n',        'MODULE Output' );
% fprintf( fout, '\n\n%s\n\n\n','      ! This MODULE stores variables used for output.' );
% fprintf( fout, '%s\n',        '   USE NWTC_Library' );
% fprintf( fout, '\n\n%s\n\n',  '     ! Defined TYPEs:' );  
fprintf( fout, '%s\n',        '   TYPE OutParmType                                                               ! User-defined type for output parameters' );
fprintf( fout, '%s\n',        '      INTEGER                    :: Indx                                          ! Index into AllOuts output array' );
fprintf( fout, '%s%02.0f%s\n','      CHARACTER(',CLen+1,')              :: Name                                          ! Name of the output parameter.' );
fprintf( fout, '%s%02.0f%s\n','      CHARACTER(',UNLen, ')              :: Units                                         ! Units corresponding to the output parameter.' );
fprintf( fout, '%s\n',        '      INTEGER                    :: SignM                                         ! sign (output multiplier).' );
fprintf( fout, '%s\n',        '   END TYPE OutParmType' );
fprintf( fout, '\n\n%s\n\n',  '     ! Parameters:' );
fprintf( fout, '\n%s\n',      '     ! Indices for computing output channels:' );
fprintf( fout, '%s\n',        '     ! NOTES: ');
fprintf( fout, '%s\n',        '     !    (1) These parameters are in the order stored in "OutListParameters.xlsx"' );
fprintf( fout, '%s\n',        '     !    (2) Array AllOuts() must be dimensioned to the value of the largest output parameter' );
if strcmpi(ProgName,'FAST')
fprintf( fout, '%s\n',        '     !    (3) If an index (MaxOutPts) ever becomes greater or equal to 1000, the logic to create ARRAY/1 in the FAST-to-ADAMS preprocessor will have to be changed.' );
end
fprintf( fout, '\n%s\n\n',    '     !  Time: ' );

numFmtLen = num2str( floor(log10(length(Module_VarName))+1) );
numFmt    =                  ['   INTEGER, PARAMETER             :: %' num2str(CLen) 's = ' ...
                                                                '%' numFmtLen '.0f\n'];
ParamNum = 0;
fprintf( fout, numFmt,       ['Time' repmat(' ',1,CLen-4)], ParamNum );  %Time is parameter 0; we left justify the character string


for i=1:length(Module_VarName)
    if ischar( Module_VarName{i} ) % print the parameter
        ParamNum = ParamNum + 1;
        fprintf( fout, numFmt,  [Module_VarName{i}, repmat(' ',1,CLen-length(Module_VarName{i}))], ParamNum );        
    else
        fprintf( fout, '\n\n%s%s:\n\n',  '  ! ', raw{i+1,1});  %make a comment describing the category
    end
end

fprintf( fout, '\n\n%s%s\n',  '     ! ', 'The maximum number of output channels which can be output by the code.');  
fprintf( fout, numFmt,  ['MaxOutPts', repmat(' ',1,CLen-length('MaxOutPts'))], ParamNum );        
% fprintf( fout, '\n\n%s\n\n',  '     ! Regular Variables:' );
% fprintf( fout, ['%s%' numFmtLen '.0f%s\n'],  '   REAL(ReKi)                     :: AllOuts  (0:', ...
%                    ParamNum, ')                               ! An array holding the value of all of the calculated (not selected) output channels.');
% fprintf( fout, ['%s'               '%s\n'],  '   TYPE(OutParmType), ALLOCATABLE :: OutParam (:) ', ...
%                              '                                 ! An array holding names, units, and indices of all of the selected output channels.');
% 
fprintf( fout, '\n%s\n', '!End of code generated by Matlab script');
fclose(fout);
%%

Module_ValidInputStr = cell(1,1);
Module_InputVarName  = cell(1,1);
Module_Units         = cell(1,1);
Indx               = false(length(Module_VarName),1);
nr = 0;

for i=1:length(Module_VarName)
    if ischar(Module_VarName{i})
        Indx(i) = true;
        nr = nr + 1;
        Module_ValidInputStr{nr,1} = Module_VarName{i};
        Module_InputVarName{ nr,1} = Module_VarName{i};
        Module_Units{        nr,1} = Units{       i};
    end    
end

for i=1:length(Module_InputStr)
    if ischar(Module_InputStr{i}) && ~isempty(Module_InputStr{i})
        tmp = textscan(Module_InputStr{i},'%s','delimiter',',');
        n   = length(tmp{1});
        for i2 = 1:n %nr:(nr+n-1)
            Module_ValidInputStr{nr+i2} = strtrim(tmp{1}{i2});
            Module_InputVarName{nr+i2}  = Module_VarName{i};
            Module_Units{nr+i2}         = Units{       i};
        end
        nr = nr + n;
    end
end

Module_VarName    = Module_VarName(Indx);
Units           = Units(Indx);
InvalidCriteria = InvalidCriteria(Indx);


%% Open the file for Fortran code
fout = fopen( out_file, 'wt' );
fprintf( fout, '%s\n', '! NOTE: The following lines of code were generated by a Matlab script called "Write_ChckOutLst.m"' );
fprintf( fout, '%s\n',  '!      using the parameters listed in the "OutListParameters.xlsx" Excel file. Any changes to these ' );
fprintf( fout, '%s\n',  '!      lines should be modified in the Matlab script and/or Excel worksheet as necessary. ');
fprintf( fout, '%s\n', ['! This code was generated by Write_ChckOutLst.m at ' datestr(now) '.'] );

%% The list of output names that are valid in the Module input file

[SORTedNames, IX] = sort( upper( Module_ValidInputStr ) ); %just in case it's not upper case or sorted (but make sure you store the indices!) SORTedNames = SORTName(IX);
SORTedNames       = char( SORTedNames );       %stored as a string array (with padding for FORTRAN)

[nr,nc] = size(SORTedNames);

    % make sure each row of the array has the desired number of characters
if nc > CLen
    error(['Length of strings in SORTName are more than ' num2str(CLen) ' characters' ]);
elseif nc < CLen 
    SORTedNames = [SORTedNames repmat(' ',nr,CLen-nc)];
end


fprintf( fout, '%s%2.0f%s%s%s\n', ...
 '   CHARACTER(',CLen, '),PARAMETER  :: ValidParamAry(', num2str(nr), ') =  (/ &                         ! This lists the names of the allowed parameters, which must be sorted alphabetically' );                                 

for iRow = 1:numPerR:nr
    fprintf( fout, '%s', '                               ' );  %the indent for each line
    lastRow = min(iRow+numPerR-1,nr);
    ContLine = true;
    for iNum = iRow:lastRow
        fprintf( fout, ['"%' num2str(CLen) 's"'], SORTedNames(iNum,:) );
        if iNum < nr
            fprintf( fout, '%s', ',' );
        else
            fprintf( fout, '%s\n', '/)'); %end of array
            ContLine = false;
        end
    end
    
    if ContLine
        fprintf( fout, '%s\n', ' &');
    end

end %iRow

%% The list of parameter parameter names corresponding to the entries in ValidParamAry
Sorted_OutInd = Module_InputVarName(IX);

fprintf( fout, '%s%s%s\n', ...
 '   INTEGER,      PARAMETER  :: ParamIndxAry(', num2str(nr), ') =  (/ &                          ! This lists the index into AllOuts(:) of the allowed parameters ValidParamAry(:)' );                                 

for iRow = 1:numPerR:nr
    fprintf( fout, '%s', '                               ' );  %the indent for each line
    lastRow = min(iRow+numPerR-1,nr);
    ContLine = true;
    for iNum = iRow:lastRow
        fprintf( fout, [' %' num2str(CLen) 's '], Sorted_OutInd{iNum} );
        if iNum < nr
            fprintf( fout, '%s', ',' );
        else
            fprintf( fout, '%s\n', '/)'); %end of array
            ContLine = false;
        end
    end
    
    if ContLine
        fprintf( fout, '%s\n', ' &');
    end
    
end %iRow

%% The units corresponding to the entries in ValidParamAry

% note: these units actually correspond to the unique entries in AllOuts(:),
% but i think it will be easier to implement using this array corresponding
% to ValidParamAry(:) entries

Sorted_Units = char( Module_Units(IX) );              %stored as a string array (with padding for FORTRAN)

[nr,nc] = size(Sorted_Units);

    % make sure each row of the array has the desired number of characters
if nc > UNLen
    error(['Length of strings in Units are more than ' num2str(UNLen) ' characters' ]);
elseif nc < UNLen 
    Sorted_Units = [Sorted_Units repmat(' ',nr,UNLen-nc)];
end

fprintf( fout, '%s%2.0f%s%s%s\n', ...
 '   CHARACTER(',UNLen, '),PARAMETER  :: ParamUnitsAry(', num2str(nr), ') =  (/ &                         ! This lists the units corresponding to the allowed parameters' );                                 

for iRow = 1:numPerR:nr
    fprintf( fout, '%s', '                               ' );  %the indent for each line
    lastRow = min(iRow+numPerR-1,nr);
    ContLine = true;
    for iNum = iRow:lastRow
        fprintf( fout, ['"%' num2str(UNLen) 's"'], Sorted_Units(iNum,:) );
        if iNum < nr
            fprintf( fout, '%s', ',' );
        else
            fprintf( fout, '%s\n', '/)'); %end of array
            ContLine = false;
        end
    end
    
    if ContLine
        fprintf( fout, '%s\n', ' &');
    end
    
end %iRow

%% Determine if the entry is valid
nu = length(Module_VarName);

fprintf( fout, '%s\n', ...
 '   LOGICAL                  :: InvalidOutput(0:MaxOutPts)                        ! This array determines if the output channel is valid for this configuration' );
%  '   LOGICAL                  :: InvalidOutput(0:', num2str(nu), ')                                 ! This array determines if the output channel is valid for this configuration' );
fprintf( fout, ['\n\n%s%' num2str(CLen) 's%s\n'], '   InvalidOutput ', ' ', '  = .FALSE.' );
fprintf( fout, '' );

for iRow = 1:nu
    if ischar(InvalidCriteria{iRow}) && ~isempty(InvalidCriteria{iRow})
        fprintf( fout, ['%s%' num2str(CLen) 's%s%s%s\n'], ...
           '   InvalidOutput(', Module_VarName{iRow}, ') = ( ', InvalidCriteria{iRow}, ' )' );
%            '   InvalidOutput(', iRow, ') = ', tmp, repmat(' ',1,nchars), '!"', SORTedNames(iRow,:), '", i.e. ', Sorted_OutInd{iRow} );
    end
end

%% Close the file
fprintf( fout, '%s\n', '!End of code generated by Matlab script' ); 
fclose(fout);

%% warn when too many outputs have been created!
fprintf( '%s%s%s\n', 'There are ', num2str(ParamNum), ' output parameters.');
if ParamNum >= 1000
    error('Too many output parameters! The maximum for FAST2ADAMS datasets is 1000.')
end    
                                