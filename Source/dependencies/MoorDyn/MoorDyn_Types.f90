!STARTOFREGISTRYGENERATEDFILE './MoorDyn_Types.f90'
!
! WARNING This file is generated automatically by the FAST registry
! Do not edit.  Your changes to this file will be lost.
!
! FAST Registry (v2.05.00, 14-Jan-2015)
!*********************************************************************************************************************************
! MoorDyn_Types
!.................................................................................................................................
! This file is part of MoorDyn.
!
! Copyright (C) 2012-2015 National Renewable Energy Laboratory
!
! Licensed under the Apache License, Version 2.0 (the "License");
! you may not use this file except in compliance with the License.
! You may obtain a copy of the License at
!
!     http://www.apache.org/licenses/LICENSE-2.0
!
! Unless required by applicable law or agreed to in writing, software
! distributed under the License is distributed on an "AS IS" BASIS,
! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
! See the License for the specific language governing permissions and
! limitations under the License.
!
!
! W A R N I N G : This file was automatically generated from the FAST registry.  Changes made to this file may be lost.
!
!*********************************************************************************************************************************
MODULE MoorDyn_Types
! This module contains all of the user-defined types needed in MoorDyn. It also contains copy, destroy, pack, and
! unpack routines associated with each defined data type. This code will be generated by the FAST Registry.
!---------------------------------------------------------------------------------------------------------------------------------
USE NWTC_Library
IMPLICIT NONE
! =========  MD_InitInputType  =======
  TYPE, PUBLIC :: MD_InitInputType
    REAL(ReKi)  :: g = -999.9      ! gravity constant [[m/s^2]]
    REAL(ReKi)  :: rhoW = -999.9      ! sea density [[kg/m^3]]
    REAL(ReKi)  :: WtrDepth = -999.9      ! depth of water [[m]]
    REAL(ReKi) , DIMENSION(1:6)  :: PtfmInit      ! initial position of platform [-]
    CHARACTER(1024)  :: FileName      ! MoorDyn input file [-]
    CHARACTER(1024)  :: RootName      ! RootName for writing output files [-]
    LOGICAL  :: Echo      ! echo parameter - do we want to echo the header line describing the input file? [-]
    REAL(ReKi)  :: DTIC      ! convergence check time step for IC generation [[s]]
    REAL(ReKi)  :: TMaxIC = 120      ! maximum time to allow for getting converged ICs [[s]]
    REAL(ReKi)  :: CdScaleIC = 1      ! factor to scale drag coefficients by during dynamic relaxation [[]]
    REAL(ReKi)  :: threshIC = 0.01      ! convergence tolerance for ICs  (0.01 means 1%) [[]]
    CHARACTER(10) , DIMENSION(:), ALLOCATABLE  :: OutList      ! string containing list of output channels requested in input file [-]
  END TYPE MD_InitInputType
! =======================
! =========  MD_LineProp  =======
  TYPE, PUBLIC :: MD_LineProp
    INTEGER(IntKi)  :: IdNum      ! integer identifier of this set of line properties [-]
    CHARACTER(10)  :: name      ! name/identifier of this set of line properties [-]
    REAL(ReKi)  :: d      ! volume-equivalent diameter [[m]]
    REAL(ReKi)  :: w      ! per-length weight in air [[kg/m]]
    REAL(ReKi)  :: EA      ! stiffness [[N]]
    REAL(ReKi)  :: BA      ! internal damping coefficient times area [[N-s]]
    REAL(ReKi)  :: Can      ! transverse added mass coefficient [-]
    REAL(ReKi)  :: Cat      ! tangential added mass coefficient [-]
    REAL(ReKi)  :: Cdn      ! transverse drag coefficient [-]
    REAL(ReKi)  :: Cdt      ! tangential drag coefficient [-]
  END TYPE MD_LineProp
! =======================
! =========  MD_Connect  =======
  TYPE, PUBLIC :: MD_Connect
    INTEGER(IntKi)  :: IdNum      ! integer identifier of this Connection [-]
    CHARACTER(10)  :: type      ! type of Connect: fix, vessel, connect [-]
    INTEGER(IntKi)  :: TypeNum      ! integer identifying the type.  0=fixed, 1=vessel, 2=connect [-]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: AttachedFairs      ! list of IdNums of connected Line tops [-]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: AttachedAnchs      ! list of IdNums of connected Line bottoms [-]
    REAL(ReKi)  :: conX      !  [-]
    REAL(ReKi)  :: conY      !  [-]
    REAL(ReKi)  :: conZ      !  [-]
    REAL(ReKi)  :: conM      !  [-]
    REAL(ReKi)  :: conV      !  [-]
    REAL(ReKi)  :: conFX      !  [-]
    REAL(ReKi)  :: conFY      !  [-]
    REAL(ReKi)  :: conFZ      !  [-]
    REAL(ReKi) , DIMENSION(1:3)  :: Ftot      ! total force on node [-]
    REAL(ReKi) , DIMENSION(1:3,1:3)  :: Mtot      ! node mass matrix, from attached lines [-]
    REAL(ReKi) , DIMENSION(1:3,1:3)  :: S      ! inverse mass matrix [[kg]]
    REAL(ReKi) , DIMENSION(1:3)  :: r      ! position [-]
    REAL(ReKi) , DIMENSION(1:3)  :: rd      ! velocity [-]
  END TYPE MD_Connect
! =======================
! =========  MD_Line  =======
  TYPE, PUBLIC :: MD_Line
    INTEGER(IntKi)  :: IdNum      ! integer identifier of this Line [-]
    CHARACTER(10)  :: type      ! type of line.  should match one of LineProp names [-]
    CHARACTER(10)  :: OutFlags      ! string specifying output options and other flags [-]
    INTEGER(IntKi)  :: FairConnect      ! IdNum of Connection at fairlead [-]
    INTEGER(IntKi)  :: AnchConnect      ! IdNum of Connection at anchor [-]
    INTEGER(IntKi)  :: PropsIdNum      ! the IdNum of the associated line properties [-]
    INTEGER(IntKi)  :: N      ! The number of elements in the line [-]
    REAL(ReKi)  :: UnstrLen      ! unstretched length of the line [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: r      ! node positions [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: rd      ! node velocities [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: q      ! node tangent vectors [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: l      ! segment unstretched length [[m]]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: lstr      ! segment stretched length [[m]]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: lstrd      ! segment change in stretched length [[m/s]]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: V      ! segment volume [[m^3]]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: T      ! segment tension vectors [[N]]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: Td      ! segment internal damping force vectors [[N]]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: W      ! weight/buoyancy vectors [[N]]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: Dp      ! node drag (transverse) [[N]]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: Dq      ! node drag (axial) [[N]]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: Ap      ! node added mass forcing (transverse) [[N]]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: Aq      ! node added mass forcing (axial) [[N]]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: B      ! node bottom contact force [[N]]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: F      ! total force on node [[N]]
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: S      ! node inverse mass matrix [[kg]]
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: M      ! node mass matrix [[kg]]
  END TYPE MD_Line
! =======================
! =========  MD_OutParmType  =======
  TYPE, PUBLIC :: MD_OutParmType
    CHARACTER(10)  :: Name      ! name of output channel [-]
    CHARACTER(10)  :: Units      ! units string [-]
    INTEGER(IntKi)  :: QType      ! type of quantity - 0=tension, 1=x, 2=y, 3=z... [-]
    INTEGER(IntKi)  :: OType      ! type of object - 0=line, 1=connect [-]
    INTEGER(IntKi)  :: NodeID      ! node number if OType=0.  0=anchor, -1=N=Fairlead [-]
    INTEGER(IntKi)  :: ObjID      ! number of Connect or Line object [-]
  END TYPE MD_OutParmType
! =======================
! =========  MD_InitOutputType  =======
  TYPE, PUBLIC :: MD_InitOutputType
    CHARACTER(ChanLen) , DIMENSION(:), ALLOCATABLE  :: writeOutputHdr      ! first line output file contents: output variable names [-]
    CHARACTER(ChanLen) , DIMENSION(:), ALLOCATABLE  :: writeOutputUnt      ! second line of output file contents: units [-]
    TYPE(ProgDesc)  :: Ver      ! this module's name, version, and date [-]
  END TYPE MD_InitOutputType
! =======================
! =========  MD_ContinuousStateType  =======
  TYPE, PUBLIC :: MD_ContinuousStateType
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: states      ! full list of node coordinates and velocities [[m] or [m/s]]
  END TYPE MD_ContinuousStateType
! =======================
! =========  MD_DiscreteStateType  =======
  TYPE, PUBLIC :: MD_DiscreteStateType
    REAL(ReKi)  :: dummy      ! Remove this variable if you have discrete states [-]
  END TYPE MD_DiscreteStateType
! =======================
! =========  MD_OtherStateType  =======
  TYPE, PUBLIC :: MD_OtherStateType
    TYPE(MD_LineProp) , DIMENSION(:), ALLOCATABLE  :: LineTypeList      ! array of properties for each line type [-]
    TYPE(MD_Connect) , DIMENSION(:), ALLOCATABLE  :: ConnectList      ! array of connection properties [-]
    TYPE(MD_Line) , DIMENSION(:), ALLOCATABLE  :: LineList      ! array of line properties [-]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: FairIdList      ! array of size NFairs listing the ID of each fairlead (index of ConnectList) []
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: LineStateIndList      ! starting index of each line's states in state vector []
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: F      ! thing for RK2 calculation, same size as states [[m] or [m/s]]
  END TYPE MD_OtherStateType
! =======================
! =========  MD_ConstraintStateType  =======
  TYPE, PUBLIC :: MD_ConstraintStateType
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: dummy      !  [-]
  END TYPE MD_ConstraintStateType
! =======================
! =========  MD_ParameterType  =======
  TYPE, PUBLIC :: MD_ParameterType
    INTEGER(IntKi)  :: NTypes      ! number of line types []
    INTEGER(IntKi)  :: NConnects      ! number of Connection objects []
    INTEGER(IntKi)  :: NLines      ! number of Line objects []
    INTEGER(IntKi)  :: NFairs      ! number of Fairlead Connections []
    REAL(ReKi)  :: g = 9.81      ! gravitational constant [[kg/m^2]]
    REAL(ReKi)  :: rhoW      ! density of seawater [[m]]
    REAL(ReKi)  :: WtrDpth      ! water depth [[m]]
    REAL(ReKi)  :: kBot      ! bottom stiffness [[Pa/m]]
    REAL(ReKi)  :: cBot      ! bottom damping [[Pa-s/m]]
    REAL(ReKi)  :: dtM0      ! desired mooring model time step [[s]]
    REAL(ReKi)  :: dtCoupling      ! coupling time step that MoorDyn should expect [[s]]
    INTEGER(IntKi)  :: NumOuts      ! Number of parameters in the output list (number of outputs requested) [-]
    CHARACTER(1024)  :: RootName      ! RootName for writing output files [-]
    TYPE(MD_OutParmType) , DIMENSION(:), ALLOCATABLE  :: OutParam      ! Names and units (and other characteristics) of all requested output parameters [-]
    CHARACTER(1)  :: Delim      ! Column delimiter for output text files [-]
  END TYPE MD_ParameterType
! =======================
! =========  MD_InputType  =======
  TYPE, PUBLIC :: MD_InputType
    TYPE(MeshType)  :: PtFairleadDisplacement      ! mesh for position AND VELOCITY of each fairlead in X,Y,Z [[m, m/s]]
  END TYPE MD_InputType
! =======================
! =========  MD_OutputType  =======
  TYPE, PUBLIC :: MD_OutputType
    TYPE(MeshType)  :: PtFairleadLoad      ! point mesh for fairlead forces in X,Y,Z [[N]]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: WriteOutput      ! output vector returned to glue code []
  END TYPE MD_OutputType
! =======================
CONTAINS
 SUBROUTINE MD_CopyInitInput( SrcInitInputData, DstInitInputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(MD_InitInputType), INTENT(IN) :: SrcInitInputData
   TYPE(MD_InitInputType), INTENT(INOUT) :: DstInitInputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: i3, i3_l, i3_u  !  bounds (upper/lower) for an array dimension 3
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
   DstInitInputData%g = SrcInitInputData%g
   DstInitInputData%rhoW = SrcInitInputData%rhoW
   DstInitInputData%WtrDepth = SrcInitInputData%WtrDepth
   DstInitInputData%PtfmInit = SrcInitInputData%PtfmInit
   DstInitInputData%FileName = SrcInitInputData%FileName
   DstInitInputData%RootName = SrcInitInputData%RootName
   DstInitInputData%Echo = SrcInitInputData%Echo
   DstInitInputData%DTIC = SrcInitInputData%DTIC
   DstInitInputData%TMaxIC = SrcInitInputData%TMaxIC
   DstInitInputData%CdScaleIC = SrcInitInputData%CdScaleIC
   DstInitInputData%threshIC = SrcInitInputData%threshIC
IF (ALLOCATED(SrcInitInputData%OutList)) THEN
   i1_l = LBOUND(SrcInitInputData%OutList,1)
   i1_u = UBOUND(SrcInitInputData%OutList,1)
   IF (.NOT. ALLOCATED(DstInitInputData%OutList)) THEN 
      ALLOCATE(DstInitInputData%OutList(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%OutList.', ErrStat, ErrMsg,'MD_CopyInitInput')
         RETURN
      END IF
   END IF
   DstInitInputData%OutList = SrcInitInputData%OutList
ENDIF
 END SUBROUTINE MD_CopyInitInput

 SUBROUTINE MD_DestroyInitInput( InitInputData, ErrStat, ErrMsg )
  TYPE(MD_InitInputType), INTENT(INOUT) :: InitInputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(InitInputData%OutList)) THEN
   DEALLOCATE(InitInputData%OutList)
ENDIF
 END SUBROUTINE MD_DestroyInitInput

 SUBROUTINE MD_PackInitInput( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(MD_InitInputType),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Re_BufSz   = Re_BufSz   + 1  ! g
  Re_BufSz   = Re_BufSz   + 1  ! rhoW
  Re_BufSz   = Re_BufSz   + 1  ! WtrDepth
  Re_BufSz    = Re_BufSz    + SIZE( InData%PtfmInit )  ! PtfmInit 
!  missing buffer for FileName
!  missing buffer for RootName
  Int_BufSz  = Int_BufSz  + 1  ! Echo
  Re_BufSz   = Re_BufSz   + 1  ! DTIC
  Re_BufSz   = Re_BufSz   + 1  ! TMaxIC
  Re_BufSz   = Re_BufSz   + 1  ! CdScaleIC
  Re_BufSz   = Re_BufSz   + 1  ! threshIC
!  missing buffer for OutList
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%g )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%rhoW )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%WtrDepth )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%PtfmInit))-1 ) =  PACK(InData%PtfmInit ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%PtfmInit)
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = TRANSFER( (InData%Echo ), IntKiBuf(1), 1)
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%DTIC )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%TMaxIC )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%CdScaleIC )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%threshIC )
  Re_Xferred   = Re_Xferred   + 1
 END SUBROUTINE MD_PackInitInput

 SUBROUTINE MD_UnPackInitInput( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(MD_InitInputType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  OutData%g = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%rhoW = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%WtrDepth = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  ALLOCATE(mask1(SIZE(OutData%PtfmInit,1)))
  mask1 = .TRUE.
  OutData%PtfmInit = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%PtfmInit))-1 ),mask1,OutData%PtfmInit)
  DEALLOCATE(mask1)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%PtfmInit)
  OutData%DTIC = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%TMaxIC = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%CdScaleIC = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%threshIC = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE MD_UnPackInitInput

 SUBROUTINE MD_CopyLineProp( SrcLinePropData, DstLinePropData, CtrlCode, ErrStat, ErrMsg )
   TYPE(MD_LineProp), INTENT(IN) :: SrcLinePropData
   TYPE(MD_LineProp), INTENT(INOUT) :: DstLinePropData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
   DstLinePropData%IdNum = SrcLinePropData%IdNum
   DstLinePropData%name = SrcLinePropData%name
   DstLinePropData%d = SrcLinePropData%d
   DstLinePropData%w = SrcLinePropData%w
   DstLinePropData%EA = SrcLinePropData%EA
   DstLinePropData%BA = SrcLinePropData%BA
   DstLinePropData%Can = SrcLinePropData%Can
   DstLinePropData%Cat = SrcLinePropData%Cat
   DstLinePropData%Cdn = SrcLinePropData%Cdn
   DstLinePropData%Cdt = SrcLinePropData%Cdt
 END SUBROUTINE MD_CopyLineProp

 SUBROUTINE MD_DestroyLineProp( LinePropData, ErrStat, ErrMsg )
  TYPE(MD_LineProp), INTENT(INOUT) :: LinePropData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
 END SUBROUTINE MD_DestroyLineProp

 SUBROUTINE MD_PackLineProp( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(MD_LineProp),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Int_BufSz  = Int_BufSz  + 1  ! IdNum
!  missing buffer for name
  Re_BufSz   = Re_BufSz   + 1  ! d
  Re_BufSz   = Re_BufSz   + 1  ! w
  Re_BufSz   = Re_BufSz   + 1  ! EA
  Re_BufSz   = Re_BufSz   + 1  ! BA
  Re_BufSz   = Re_BufSz   + 1  ! Can
  Re_BufSz   = Re_BufSz   + 1  ! Cat
  Re_BufSz   = Re_BufSz   + 1  ! Cdn
  Re_BufSz   = Re_BufSz   + 1  ! Cdt
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%IdNum )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%d )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%w )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%EA )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%BA )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%Can )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%Cat )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%Cdn )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%Cdt )
  Re_Xferred   = Re_Xferred   + 1
 END SUBROUTINE MD_PackLineProp

 SUBROUTINE MD_UnPackLineProp( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(MD_LineProp), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  OutData%IdNum = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%d = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%w = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%EA = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%BA = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%Can = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%Cat = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%Cdn = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%Cdt = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE MD_UnPackLineProp

 SUBROUTINE MD_CopyConnect( SrcConnectData, DstConnectData, CtrlCode, ErrStat, ErrMsg )
   TYPE(MD_Connect), INTENT(IN) :: SrcConnectData
   TYPE(MD_Connect), INTENT(INOUT) :: DstConnectData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
   DstConnectData%IdNum = SrcConnectData%IdNum
   DstConnectData%type = SrcConnectData%type
   DstConnectData%TypeNum = SrcConnectData%TypeNum
IF (ALLOCATED(SrcConnectData%AttachedFairs)) THEN
   i1_l = LBOUND(SrcConnectData%AttachedFairs,1)
   i1_u = UBOUND(SrcConnectData%AttachedFairs,1)
   IF (.NOT. ALLOCATED(DstConnectData%AttachedFairs)) THEN 
      ALLOCATE(DstConnectData%AttachedFairs(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstConnectData%AttachedFairs.', ErrStat, ErrMsg,'MD_CopyConnect')
         RETURN
      END IF
   END IF
   DstConnectData%AttachedFairs = SrcConnectData%AttachedFairs
ENDIF
IF (ALLOCATED(SrcConnectData%AttachedAnchs)) THEN
   i1_l = LBOUND(SrcConnectData%AttachedAnchs,1)
   i1_u = UBOUND(SrcConnectData%AttachedAnchs,1)
   IF (.NOT. ALLOCATED(DstConnectData%AttachedAnchs)) THEN 
      ALLOCATE(DstConnectData%AttachedAnchs(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstConnectData%AttachedAnchs.', ErrStat, ErrMsg,'MD_CopyConnect')
         RETURN
      END IF
   END IF
   DstConnectData%AttachedAnchs = SrcConnectData%AttachedAnchs
ENDIF
   DstConnectData%conX = SrcConnectData%conX
   DstConnectData%conY = SrcConnectData%conY
   DstConnectData%conZ = SrcConnectData%conZ
   DstConnectData%conM = SrcConnectData%conM
   DstConnectData%conV = SrcConnectData%conV
   DstConnectData%conFX = SrcConnectData%conFX
   DstConnectData%conFY = SrcConnectData%conFY
   DstConnectData%conFZ = SrcConnectData%conFZ
   DstConnectData%Ftot = SrcConnectData%Ftot
   DstConnectData%Mtot = SrcConnectData%Mtot
   DstConnectData%S = SrcConnectData%S
   DstConnectData%r = SrcConnectData%r
   DstConnectData%rd = SrcConnectData%rd
 END SUBROUTINE MD_CopyConnect

 SUBROUTINE MD_DestroyConnect( ConnectData, ErrStat, ErrMsg )
  TYPE(MD_Connect), INTENT(INOUT) :: ConnectData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(ConnectData%AttachedFairs)) THEN
   DEALLOCATE(ConnectData%AttachedFairs)
ENDIF
IF (ALLOCATED(ConnectData%AttachedAnchs)) THEN
   DEALLOCATE(ConnectData%AttachedAnchs)
ENDIF
 END SUBROUTINE MD_DestroyConnect

 SUBROUTINE MD_PackConnect( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(MD_Connect),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Int_BufSz  = Int_BufSz  + 1  ! IdNum
!  missing buffer for type
  Int_BufSz  = Int_BufSz  + 1  ! TypeNum
  IF ( ALLOCATED(InData%AttachedFairs) )   Int_BufSz   = Int_BufSz   + SIZE( InData%AttachedFairs )  ! AttachedFairs 
  IF ( ALLOCATED(InData%AttachedAnchs) )   Int_BufSz   = Int_BufSz   + SIZE( InData%AttachedAnchs )  ! AttachedAnchs 
  Re_BufSz   = Re_BufSz   + 1  ! conX
  Re_BufSz   = Re_BufSz   + 1  ! conY
  Re_BufSz   = Re_BufSz   + 1  ! conZ
  Re_BufSz   = Re_BufSz   + 1  ! conM
  Re_BufSz   = Re_BufSz   + 1  ! conV
  Re_BufSz   = Re_BufSz   + 1  ! conFX
  Re_BufSz   = Re_BufSz   + 1  ! conFY
  Re_BufSz   = Re_BufSz   + 1  ! conFZ
  Re_BufSz    = Re_BufSz    + SIZE( InData%Ftot )  ! Ftot 
  Re_BufSz    = Re_BufSz    + SIZE( InData%Mtot )  ! Mtot 
  Re_BufSz    = Re_BufSz    + SIZE( InData%S )  ! S 
  Re_BufSz    = Re_BufSz    + SIZE( InData%r )  ! r 
  Re_BufSz    = Re_BufSz    + SIZE( InData%rd )  ! rd 
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%IdNum )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%TypeNum )
  Int_Xferred   = Int_Xferred   + 1
  IF ( ALLOCATED(InData%AttachedFairs) ) THEN
    IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%AttachedFairs))-1 ) = PACK(InData%AttachedFairs ,.TRUE.)
    Int_Xferred   = Int_Xferred   + SIZE(InData%AttachedFairs)
  ENDIF
  IF ( ALLOCATED(InData%AttachedAnchs) ) THEN
    IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%AttachedAnchs))-1 ) = PACK(InData%AttachedAnchs ,.TRUE.)
    Int_Xferred   = Int_Xferred   + SIZE(InData%AttachedAnchs)
  ENDIF
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%conX )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%conY )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%conZ )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%conM )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%conV )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%conFX )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%conFY )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%conFZ )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Ftot))-1 ) =  PACK(InData%Ftot ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%Ftot)
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Mtot))-1 ) =  PACK(InData%Mtot ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%Mtot)
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%S))-1 ) =  PACK(InData%S ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%S)
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%r))-1 ) =  PACK(InData%r ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%r)
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%rd))-1 ) =  PACK(InData%rd ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%rd)
 END SUBROUTINE MD_PackConnect

 SUBROUTINE MD_UnPackConnect( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(MD_Connect), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  OutData%IdNum = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%TypeNum = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  IF ( ALLOCATED(OutData%AttachedFairs) ) THEN
  ALLOCATE(mask1(SIZE(OutData%AttachedFairs,1)))
  mask1 = .TRUE.
    OutData%AttachedFairs = UNPACK(IntKiBuf( Int_Xferred:Re_Xferred+(SIZE(OutData%AttachedFairs))-1 ),mask1,OutData%AttachedFairs)
  DEALLOCATE(mask1)
    Int_Xferred   = Int_Xferred   + SIZE(OutData%AttachedFairs)
  ENDIF
  IF ( ALLOCATED(OutData%AttachedAnchs) ) THEN
  ALLOCATE(mask1(SIZE(OutData%AttachedAnchs,1)))
  mask1 = .TRUE.
    OutData%AttachedAnchs = UNPACK(IntKiBuf( Int_Xferred:Re_Xferred+(SIZE(OutData%AttachedAnchs))-1 ),mask1,OutData%AttachedAnchs)
  DEALLOCATE(mask1)
    Int_Xferred   = Int_Xferred   + SIZE(OutData%AttachedAnchs)
  ENDIF
  OutData%conX = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%conY = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%conZ = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%conM = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%conV = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%conFX = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%conFY = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%conFZ = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  ALLOCATE(mask1(SIZE(OutData%Ftot,1)))
  mask1 = .TRUE.
  OutData%Ftot = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Ftot))-1 ),mask1,OutData%Ftot)
  DEALLOCATE(mask1)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%Ftot)
  ALLOCATE(mask2(SIZE(OutData%Mtot,1),SIZE(OutData%Mtot,2)))
  mask2 = .TRUE.
  OutData%Mtot = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Mtot))-1 ),mask2,OutData%Mtot)
  DEALLOCATE(mask2)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%Mtot)
  ALLOCATE(mask2(SIZE(OutData%S,1),SIZE(OutData%S,2)))
  mask2 = .TRUE.
  OutData%S = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%S))-1 ),mask2,OutData%S)
  DEALLOCATE(mask2)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%S)
  ALLOCATE(mask1(SIZE(OutData%r,1)))
  mask1 = .TRUE.
  OutData%r = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%r))-1 ),mask1,OutData%r)
  DEALLOCATE(mask1)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%r)
  ALLOCATE(mask1(SIZE(OutData%rd,1)))
  mask1 = .TRUE.
  OutData%rd = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%rd))-1 ),mask1,OutData%rd)
  DEALLOCATE(mask1)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%rd)
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE MD_UnPackConnect

 SUBROUTINE MD_CopyLine( SrcLineData, DstLineData, CtrlCode, ErrStat, ErrMsg )
   TYPE(MD_Line), INTENT(IN) :: SrcLineData
   TYPE(MD_Line), INTENT(INOUT) :: DstLineData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: i3, i3_l, i3_u  !  bounds (upper/lower) for an array dimension 3
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
   DstLineData%IdNum = SrcLineData%IdNum
   DstLineData%type = SrcLineData%type
   DstLineData%OutFlags = SrcLineData%OutFlags
   DstLineData%FairConnect = SrcLineData%FairConnect
   DstLineData%AnchConnect = SrcLineData%AnchConnect
   DstLineData%PropsIdNum = SrcLineData%PropsIdNum
   DstLineData%N = SrcLineData%N
   DstLineData%UnstrLen = SrcLineData%UnstrLen
IF (ALLOCATED(SrcLineData%r)) THEN
   i1_l = LBOUND(SrcLineData%r,1)
   i1_u = UBOUND(SrcLineData%r,1)
   i2_l = LBOUND(SrcLineData%r,2)
   i2_u = UBOUND(SrcLineData%r,2)
   IF (.NOT. ALLOCATED(DstLineData%r)) THEN 
      ALLOCATE(DstLineData%r(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstLineData%r.', ErrStat, ErrMsg,'MD_CopyLine')
         RETURN
      END IF
   END IF
   DstLineData%r = SrcLineData%r
ENDIF
IF (ALLOCATED(SrcLineData%rd)) THEN
   i1_l = LBOUND(SrcLineData%rd,1)
   i1_u = UBOUND(SrcLineData%rd,1)
   i2_l = LBOUND(SrcLineData%rd,2)
   i2_u = UBOUND(SrcLineData%rd,2)
   IF (.NOT. ALLOCATED(DstLineData%rd)) THEN 
      ALLOCATE(DstLineData%rd(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstLineData%rd.', ErrStat, ErrMsg,'MD_CopyLine')
         RETURN
      END IF
   END IF
   DstLineData%rd = SrcLineData%rd
ENDIF
IF (ALLOCATED(SrcLineData%q)) THEN
   i1_l = LBOUND(SrcLineData%q,1)
   i1_u = UBOUND(SrcLineData%q,1)
   i2_l = LBOUND(SrcLineData%q,2)
   i2_u = UBOUND(SrcLineData%q,2)
   IF (.NOT. ALLOCATED(DstLineData%q)) THEN 
      ALLOCATE(DstLineData%q(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstLineData%q.', ErrStat, ErrMsg,'MD_CopyLine')
         RETURN
      END IF
   END IF
   DstLineData%q = SrcLineData%q
ENDIF
IF (ALLOCATED(SrcLineData%l)) THEN
   i1_l = LBOUND(SrcLineData%l,1)
   i1_u = UBOUND(SrcLineData%l,1)
   IF (.NOT. ALLOCATED(DstLineData%l)) THEN 
      ALLOCATE(DstLineData%l(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstLineData%l.', ErrStat, ErrMsg,'MD_CopyLine')
         RETURN
      END IF
   END IF
   DstLineData%l = SrcLineData%l
ENDIF
IF (ALLOCATED(SrcLineData%lstr)) THEN
   i1_l = LBOUND(SrcLineData%lstr,1)
   i1_u = UBOUND(SrcLineData%lstr,1)
   IF (.NOT. ALLOCATED(DstLineData%lstr)) THEN 
      ALLOCATE(DstLineData%lstr(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstLineData%lstr.', ErrStat, ErrMsg,'MD_CopyLine')
         RETURN
      END IF
   END IF
   DstLineData%lstr = SrcLineData%lstr
ENDIF
IF (ALLOCATED(SrcLineData%lstrd)) THEN
   i1_l = LBOUND(SrcLineData%lstrd,1)
   i1_u = UBOUND(SrcLineData%lstrd,1)
   IF (.NOT. ALLOCATED(DstLineData%lstrd)) THEN 
      ALLOCATE(DstLineData%lstrd(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstLineData%lstrd.', ErrStat, ErrMsg,'MD_CopyLine')
         RETURN
      END IF
   END IF
   DstLineData%lstrd = SrcLineData%lstrd
ENDIF
IF (ALLOCATED(SrcLineData%V)) THEN
   i1_l = LBOUND(SrcLineData%V,1)
   i1_u = UBOUND(SrcLineData%V,1)
   IF (.NOT. ALLOCATED(DstLineData%V)) THEN 
      ALLOCATE(DstLineData%V(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstLineData%V.', ErrStat, ErrMsg,'MD_CopyLine')
         RETURN
      END IF
   END IF
   DstLineData%V = SrcLineData%V
ENDIF
IF (ALLOCATED(SrcLineData%T)) THEN
   i1_l = LBOUND(SrcLineData%T,1)
   i1_u = UBOUND(SrcLineData%T,1)
   i2_l = LBOUND(SrcLineData%T,2)
   i2_u = UBOUND(SrcLineData%T,2)
   IF (.NOT. ALLOCATED(DstLineData%T)) THEN 
      ALLOCATE(DstLineData%T(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstLineData%T.', ErrStat, ErrMsg,'MD_CopyLine')
         RETURN
      END IF
   END IF
   DstLineData%T = SrcLineData%T
ENDIF
IF (ALLOCATED(SrcLineData%Td)) THEN
   i1_l = LBOUND(SrcLineData%Td,1)
   i1_u = UBOUND(SrcLineData%Td,1)
   i2_l = LBOUND(SrcLineData%Td,2)
   i2_u = UBOUND(SrcLineData%Td,2)
   IF (.NOT. ALLOCATED(DstLineData%Td)) THEN 
      ALLOCATE(DstLineData%Td(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstLineData%Td.', ErrStat, ErrMsg,'MD_CopyLine')
         RETURN
      END IF
   END IF
   DstLineData%Td = SrcLineData%Td
ENDIF
IF (ALLOCATED(SrcLineData%W)) THEN
   i1_l = LBOUND(SrcLineData%W,1)
   i1_u = UBOUND(SrcLineData%W,1)
   i2_l = LBOUND(SrcLineData%W,2)
   i2_u = UBOUND(SrcLineData%W,2)
   IF (.NOT. ALLOCATED(DstLineData%W)) THEN 
      ALLOCATE(DstLineData%W(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstLineData%W.', ErrStat, ErrMsg,'MD_CopyLine')
         RETURN
      END IF
   END IF
   DstLineData%W = SrcLineData%W
ENDIF
IF (ALLOCATED(SrcLineData%Dp)) THEN
   i1_l = LBOUND(SrcLineData%Dp,1)
   i1_u = UBOUND(SrcLineData%Dp,1)
   i2_l = LBOUND(SrcLineData%Dp,2)
   i2_u = UBOUND(SrcLineData%Dp,2)
   IF (.NOT. ALLOCATED(DstLineData%Dp)) THEN 
      ALLOCATE(DstLineData%Dp(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstLineData%Dp.', ErrStat, ErrMsg,'MD_CopyLine')
         RETURN
      END IF
   END IF
   DstLineData%Dp = SrcLineData%Dp
ENDIF
IF (ALLOCATED(SrcLineData%Dq)) THEN
   i1_l = LBOUND(SrcLineData%Dq,1)
   i1_u = UBOUND(SrcLineData%Dq,1)
   i2_l = LBOUND(SrcLineData%Dq,2)
   i2_u = UBOUND(SrcLineData%Dq,2)
   IF (.NOT. ALLOCATED(DstLineData%Dq)) THEN 
      ALLOCATE(DstLineData%Dq(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstLineData%Dq.', ErrStat, ErrMsg,'MD_CopyLine')
         RETURN
      END IF
   END IF
   DstLineData%Dq = SrcLineData%Dq
ENDIF
IF (ALLOCATED(SrcLineData%Ap)) THEN
   i1_l = LBOUND(SrcLineData%Ap,1)
   i1_u = UBOUND(SrcLineData%Ap,1)
   i2_l = LBOUND(SrcLineData%Ap,2)
   i2_u = UBOUND(SrcLineData%Ap,2)
   IF (.NOT. ALLOCATED(DstLineData%Ap)) THEN 
      ALLOCATE(DstLineData%Ap(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstLineData%Ap.', ErrStat, ErrMsg,'MD_CopyLine')
         RETURN
      END IF
   END IF
   DstLineData%Ap = SrcLineData%Ap
ENDIF
IF (ALLOCATED(SrcLineData%Aq)) THEN
   i1_l = LBOUND(SrcLineData%Aq,1)
   i1_u = UBOUND(SrcLineData%Aq,1)
   i2_l = LBOUND(SrcLineData%Aq,2)
   i2_u = UBOUND(SrcLineData%Aq,2)
   IF (.NOT. ALLOCATED(DstLineData%Aq)) THEN 
      ALLOCATE(DstLineData%Aq(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstLineData%Aq.', ErrStat, ErrMsg,'MD_CopyLine')
         RETURN
      END IF
   END IF
   DstLineData%Aq = SrcLineData%Aq
ENDIF
IF (ALLOCATED(SrcLineData%B)) THEN
   i1_l = LBOUND(SrcLineData%B,1)
   i1_u = UBOUND(SrcLineData%B,1)
   i2_l = LBOUND(SrcLineData%B,2)
   i2_u = UBOUND(SrcLineData%B,2)
   IF (.NOT. ALLOCATED(DstLineData%B)) THEN 
      ALLOCATE(DstLineData%B(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstLineData%B.', ErrStat, ErrMsg,'MD_CopyLine')
         RETURN
      END IF
   END IF
   DstLineData%B = SrcLineData%B
ENDIF
IF (ALLOCATED(SrcLineData%F)) THEN
   i1_l = LBOUND(SrcLineData%F,1)
   i1_u = UBOUND(SrcLineData%F,1)
   i2_l = LBOUND(SrcLineData%F,2)
   i2_u = UBOUND(SrcLineData%F,2)
   IF (.NOT. ALLOCATED(DstLineData%F)) THEN 
      ALLOCATE(DstLineData%F(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstLineData%F.', ErrStat, ErrMsg,'MD_CopyLine')
         RETURN
      END IF
   END IF
   DstLineData%F = SrcLineData%F
ENDIF
IF (ALLOCATED(SrcLineData%S)) THEN
   i1_l = LBOUND(SrcLineData%S,1)
   i1_u = UBOUND(SrcLineData%S,1)
   i2_l = LBOUND(SrcLineData%S,2)
   i2_u = UBOUND(SrcLineData%S,2)
   i3_l = LBOUND(SrcLineData%S,3)
   i3_u = UBOUND(SrcLineData%S,3)
   IF (.NOT. ALLOCATED(DstLineData%S)) THEN 
      ALLOCATE(DstLineData%S(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstLineData%S.', ErrStat, ErrMsg,'MD_CopyLine')
         RETURN
      END IF
   END IF
   DstLineData%S = SrcLineData%S
ENDIF
IF (ALLOCATED(SrcLineData%M)) THEN
   i1_l = LBOUND(SrcLineData%M,1)
   i1_u = UBOUND(SrcLineData%M,1)
   i2_l = LBOUND(SrcLineData%M,2)
   i2_u = UBOUND(SrcLineData%M,2)
   i3_l = LBOUND(SrcLineData%M,3)
   i3_u = UBOUND(SrcLineData%M,3)
   IF (.NOT. ALLOCATED(DstLineData%M)) THEN 
      ALLOCATE(DstLineData%M(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstLineData%M.', ErrStat, ErrMsg,'MD_CopyLine')
         RETURN
      END IF
   END IF
   DstLineData%M = SrcLineData%M
ENDIF
 END SUBROUTINE MD_CopyLine

 SUBROUTINE MD_DestroyLine( LineData, ErrStat, ErrMsg )
  TYPE(MD_Line), INTENT(INOUT) :: LineData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(LineData%r)) THEN
   DEALLOCATE(LineData%r)
ENDIF
IF (ALLOCATED(LineData%rd)) THEN
   DEALLOCATE(LineData%rd)
ENDIF
IF (ALLOCATED(LineData%q)) THEN
   DEALLOCATE(LineData%q)
ENDIF
IF (ALLOCATED(LineData%l)) THEN
   DEALLOCATE(LineData%l)
ENDIF
IF (ALLOCATED(LineData%lstr)) THEN
   DEALLOCATE(LineData%lstr)
ENDIF
IF (ALLOCATED(LineData%lstrd)) THEN
   DEALLOCATE(LineData%lstrd)
ENDIF
IF (ALLOCATED(LineData%V)) THEN
   DEALLOCATE(LineData%V)
ENDIF
IF (ALLOCATED(LineData%T)) THEN
   DEALLOCATE(LineData%T)
ENDIF
IF (ALLOCATED(LineData%Td)) THEN
   DEALLOCATE(LineData%Td)
ENDIF
IF (ALLOCATED(LineData%W)) THEN
   DEALLOCATE(LineData%W)
ENDIF
IF (ALLOCATED(LineData%Dp)) THEN
   DEALLOCATE(LineData%Dp)
ENDIF
IF (ALLOCATED(LineData%Dq)) THEN
   DEALLOCATE(LineData%Dq)
ENDIF
IF (ALLOCATED(LineData%Ap)) THEN
   DEALLOCATE(LineData%Ap)
ENDIF
IF (ALLOCATED(LineData%Aq)) THEN
   DEALLOCATE(LineData%Aq)
ENDIF
IF (ALLOCATED(LineData%B)) THEN
   DEALLOCATE(LineData%B)
ENDIF
IF (ALLOCATED(LineData%F)) THEN
   DEALLOCATE(LineData%F)
ENDIF
IF (ALLOCATED(LineData%S)) THEN
   DEALLOCATE(LineData%S)
ENDIF
IF (ALLOCATED(LineData%M)) THEN
   DEALLOCATE(LineData%M)
ENDIF
 END SUBROUTINE MD_DestroyLine

 SUBROUTINE MD_PackLine( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(MD_Line),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Int_BufSz  = Int_BufSz  + 1  ! IdNum
!  missing buffer for type
!  missing buffer for OutFlags
  Int_BufSz  = Int_BufSz  + 1  ! FairConnect
  Int_BufSz  = Int_BufSz  + 1  ! AnchConnect
  Int_BufSz  = Int_BufSz  + 1  ! PropsIdNum
  Int_BufSz  = Int_BufSz  + 1  ! N
  Re_BufSz   = Re_BufSz   + 1  ! UnstrLen
  IF ( ALLOCATED(InData%r) )   Re_BufSz    = Re_BufSz    + SIZE( InData%r )  ! r 
  IF ( ALLOCATED(InData%rd) )   Re_BufSz    = Re_BufSz    + SIZE( InData%rd )  ! rd 
  IF ( ALLOCATED(InData%q) )   Re_BufSz    = Re_BufSz    + SIZE( InData%q )  ! q 
  IF ( ALLOCATED(InData%l) )   Re_BufSz    = Re_BufSz    + SIZE( InData%l )  ! l 
  IF ( ALLOCATED(InData%lstr) )   Re_BufSz    = Re_BufSz    + SIZE( InData%lstr )  ! lstr 
  IF ( ALLOCATED(InData%lstrd) )   Re_BufSz    = Re_BufSz    + SIZE( InData%lstrd )  ! lstrd 
  IF ( ALLOCATED(InData%V) )   Re_BufSz    = Re_BufSz    + SIZE( InData%V )  ! V 
  IF ( ALLOCATED(InData%T) )   Re_BufSz    = Re_BufSz    + SIZE( InData%T )  ! T 
  IF ( ALLOCATED(InData%Td) )   Re_BufSz    = Re_BufSz    + SIZE( InData%Td )  ! Td 
  IF ( ALLOCATED(InData%W) )   Re_BufSz    = Re_BufSz    + SIZE( InData%W )  ! W 
  IF ( ALLOCATED(InData%Dp) )   Re_BufSz    = Re_BufSz    + SIZE( InData%Dp )  ! Dp 
  IF ( ALLOCATED(InData%Dq) )   Re_BufSz    = Re_BufSz    + SIZE( InData%Dq )  ! Dq 
  IF ( ALLOCATED(InData%Ap) )   Re_BufSz    = Re_BufSz    + SIZE( InData%Ap )  ! Ap 
  IF ( ALLOCATED(InData%Aq) )   Re_BufSz    = Re_BufSz    + SIZE( InData%Aq )  ! Aq 
  IF ( ALLOCATED(InData%B) )   Re_BufSz    = Re_BufSz    + SIZE( InData%B )  ! B 
  IF ( ALLOCATED(InData%F) )   Re_BufSz    = Re_BufSz    + SIZE( InData%F )  ! F 
  IF ( ALLOCATED(InData%S) )   Re_BufSz    = Re_BufSz    + SIZE( InData%S )  ! S 
  IF ( ALLOCATED(InData%M) )   Re_BufSz    = Re_BufSz    + SIZE( InData%M )  ! M 
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%IdNum )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%FairConnect )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%AnchConnect )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%PropsIdNum )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%N )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%UnstrLen )
  Re_Xferred   = Re_Xferred   + 1
  IF ( ALLOCATED(InData%r) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%r))-1 ) =  PACK(InData%r ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%r)
  ENDIF
  IF ( ALLOCATED(InData%rd) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%rd))-1 ) =  PACK(InData%rd ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%rd)
  ENDIF
  IF ( ALLOCATED(InData%q) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%q))-1 ) =  PACK(InData%q ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%q)
  ENDIF
  IF ( ALLOCATED(InData%l) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%l))-1 ) =  PACK(InData%l ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%l)
  ENDIF
  IF ( ALLOCATED(InData%lstr) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%lstr))-1 ) =  PACK(InData%lstr ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%lstr)
  ENDIF
  IF ( ALLOCATED(InData%lstrd) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%lstrd))-1 ) =  PACK(InData%lstrd ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%lstrd)
  ENDIF
  IF ( ALLOCATED(InData%V) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%V))-1 ) =  PACK(InData%V ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%V)
  ENDIF
  IF ( ALLOCATED(InData%T) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%T))-1 ) =  PACK(InData%T ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%T)
  ENDIF
  IF ( ALLOCATED(InData%Td) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Td))-1 ) =  PACK(InData%Td ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%Td)
  ENDIF
  IF ( ALLOCATED(InData%W) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%W))-1 ) =  PACK(InData%W ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%W)
  ENDIF
  IF ( ALLOCATED(InData%Dp) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Dp))-1 ) =  PACK(InData%Dp ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%Dp)
  ENDIF
  IF ( ALLOCATED(InData%Dq) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Dq))-1 ) =  PACK(InData%Dq ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%Dq)
  ENDIF
  IF ( ALLOCATED(InData%Ap) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Ap))-1 ) =  PACK(InData%Ap ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%Ap)
  ENDIF
  IF ( ALLOCATED(InData%Aq) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Aq))-1 ) =  PACK(InData%Aq ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%Aq)
  ENDIF
  IF ( ALLOCATED(InData%B) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%B))-1 ) =  PACK(InData%B ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%B)
  ENDIF
  IF ( ALLOCATED(InData%F) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%F))-1 ) =  PACK(InData%F ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%F)
  ENDIF
  IF ( ALLOCATED(InData%S) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%S))-1 ) =  PACK(InData%S ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%S)
  ENDIF
  IF ( ALLOCATED(InData%M) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%M))-1 ) =  PACK(InData%M ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%M)
  ENDIF
 END SUBROUTINE MD_PackLine

 SUBROUTINE MD_UnPackLine( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(MD_Line), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  OutData%IdNum = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%FairConnect = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%AnchConnect = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%PropsIdNum = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%N = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%UnstrLen = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  IF ( ALLOCATED(OutData%r) ) THEN
  ALLOCATE(mask2(SIZE(OutData%r,1),SIZE(OutData%r,2)))
  mask2 = .TRUE.
    OutData%r = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%r))-1 ),mask2,OutData%r)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%r)
  ENDIF
  IF ( ALLOCATED(OutData%rd) ) THEN
  ALLOCATE(mask2(SIZE(OutData%rd,1),SIZE(OutData%rd,2)))
  mask2 = .TRUE.
    OutData%rd = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%rd))-1 ),mask2,OutData%rd)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%rd)
  ENDIF
  IF ( ALLOCATED(OutData%q) ) THEN
  ALLOCATE(mask2(SIZE(OutData%q,1),SIZE(OutData%q,2)))
  mask2 = .TRUE.
    OutData%q = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%q))-1 ),mask2,OutData%q)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%q)
  ENDIF
  IF ( ALLOCATED(OutData%l) ) THEN
  ALLOCATE(mask1(SIZE(OutData%l,1)))
  mask1 = .TRUE.
    OutData%l = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%l))-1 ),mask1,OutData%l)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%l)
  ENDIF
  IF ( ALLOCATED(OutData%lstr) ) THEN
  ALLOCATE(mask1(SIZE(OutData%lstr,1)))
  mask1 = .TRUE.
    OutData%lstr = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%lstr))-1 ),mask1,OutData%lstr)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%lstr)
  ENDIF
  IF ( ALLOCATED(OutData%lstrd) ) THEN
  ALLOCATE(mask1(SIZE(OutData%lstrd,1)))
  mask1 = .TRUE.
    OutData%lstrd = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%lstrd))-1 ),mask1,OutData%lstrd)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%lstrd)
  ENDIF
  IF ( ALLOCATED(OutData%V) ) THEN
  ALLOCATE(mask1(SIZE(OutData%V,1)))
  mask1 = .TRUE.
    OutData%V = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%V))-1 ),mask1,OutData%V)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%V)
  ENDIF
  IF ( ALLOCATED(OutData%T) ) THEN
  ALLOCATE(mask2(SIZE(OutData%T,1),SIZE(OutData%T,2)))
  mask2 = .TRUE.
    OutData%T = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%T))-1 ),mask2,OutData%T)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%T)
  ENDIF
  IF ( ALLOCATED(OutData%Td) ) THEN
  ALLOCATE(mask2(SIZE(OutData%Td,1),SIZE(OutData%Td,2)))
  mask2 = .TRUE.
    OutData%Td = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Td))-1 ),mask2,OutData%Td)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%Td)
  ENDIF
  IF ( ALLOCATED(OutData%W) ) THEN
  ALLOCATE(mask2(SIZE(OutData%W,1),SIZE(OutData%W,2)))
  mask2 = .TRUE.
    OutData%W = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%W))-1 ),mask2,OutData%W)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%W)
  ENDIF
  IF ( ALLOCATED(OutData%Dp) ) THEN
  ALLOCATE(mask2(SIZE(OutData%Dp,1),SIZE(OutData%Dp,2)))
  mask2 = .TRUE.
    OutData%Dp = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Dp))-1 ),mask2,OutData%Dp)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%Dp)
  ENDIF
  IF ( ALLOCATED(OutData%Dq) ) THEN
  ALLOCATE(mask2(SIZE(OutData%Dq,1),SIZE(OutData%Dq,2)))
  mask2 = .TRUE.
    OutData%Dq = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Dq))-1 ),mask2,OutData%Dq)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%Dq)
  ENDIF
  IF ( ALLOCATED(OutData%Ap) ) THEN
  ALLOCATE(mask2(SIZE(OutData%Ap,1),SIZE(OutData%Ap,2)))
  mask2 = .TRUE.
    OutData%Ap = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Ap))-1 ),mask2,OutData%Ap)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%Ap)
  ENDIF
  IF ( ALLOCATED(OutData%Aq) ) THEN
  ALLOCATE(mask2(SIZE(OutData%Aq,1),SIZE(OutData%Aq,2)))
  mask2 = .TRUE.
    OutData%Aq = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Aq))-1 ),mask2,OutData%Aq)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%Aq)
  ENDIF
  IF ( ALLOCATED(OutData%B) ) THEN
  ALLOCATE(mask2(SIZE(OutData%B,1),SIZE(OutData%B,2)))
  mask2 = .TRUE.
    OutData%B = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%B))-1 ),mask2,OutData%B)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%B)
  ENDIF
  IF ( ALLOCATED(OutData%F) ) THEN
  ALLOCATE(mask2(SIZE(OutData%F,1),SIZE(OutData%F,2)))
  mask2 = .TRUE.
    OutData%F = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%F))-1 ),mask2,OutData%F)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%F)
  ENDIF
  IF ( ALLOCATED(OutData%S) ) THEN
  ALLOCATE(mask3(SIZE(OutData%S,1),SIZE(OutData%S,2),SIZE(OutData%S,3)))
  mask3 = .TRUE.
    OutData%S = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%S))-1 ),mask3,OutData%S)
  DEALLOCATE(mask3)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%S)
  ENDIF
  IF ( ALLOCATED(OutData%M) ) THEN
  ALLOCATE(mask3(SIZE(OutData%M,1),SIZE(OutData%M,2),SIZE(OutData%M,3)))
  mask3 = .TRUE.
    OutData%M = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%M))-1 ),mask3,OutData%M)
  DEALLOCATE(mask3)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%M)
  ENDIF
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE MD_UnPackLine

 SUBROUTINE MD_CopyOutParmType( SrcOutParmTypeData, DstOutParmTypeData, CtrlCode, ErrStat, ErrMsg )
   TYPE(MD_OutParmType), INTENT(IN) :: SrcOutParmTypeData
   TYPE(MD_OutParmType), INTENT(INOUT) :: DstOutParmTypeData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
   DstOutParmTypeData%Name = SrcOutParmTypeData%Name
   DstOutParmTypeData%Units = SrcOutParmTypeData%Units
   DstOutParmTypeData%QType = SrcOutParmTypeData%QType
   DstOutParmTypeData%OType = SrcOutParmTypeData%OType
   DstOutParmTypeData%NodeID = SrcOutParmTypeData%NodeID
   DstOutParmTypeData%ObjID = SrcOutParmTypeData%ObjID
 END SUBROUTINE MD_CopyOutParmType

 SUBROUTINE MD_DestroyOutParmType( OutParmTypeData, ErrStat, ErrMsg )
  TYPE(MD_OutParmType), INTENT(INOUT) :: OutParmTypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
 END SUBROUTINE MD_DestroyOutParmType

 SUBROUTINE MD_PackOutParmType( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(MD_OutParmType),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
!  missing buffer for Name
!  missing buffer for Units
  Int_BufSz  = Int_BufSz  + 1  ! QType
  Int_BufSz  = Int_BufSz  + 1  ! OType
  Int_BufSz  = Int_BufSz  + 1  ! NodeID
  Int_BufSz  = Int_BufSz  + 1  ! ObjID
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%QType )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%OType )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NodeID )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%ObjID )
  Int_Xferred   = Int_Xferred   + 1
 END SUBROUTINE MD_PackOutParmType

 SUBROUTINE MD_UnPackOutParmType( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(MD_OutParmType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  OutData%QType = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%OType = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%NodeID = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%ObjID = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE MD_UnPackOutParmType

 SUBROUTINE MD_CopyInitOutput( SrcInitOutputData, DstInitOutputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(MD_InitOutputType), INTENT(IN) :: SrcInitOutputData
   TYPE(MD_InitOutputType), INTENT(INOUT) :: DstInitOutputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcInitOutputData%writeOutputHdr)) THEN
   i1_l = LBOUND(SrcInitOutputData%writeOutputHdr,1)
   i1_u = UBOUND(SrcInitOutputData%writeOutputHdr,1)
   IF (.NOT. ALLOCATED(DstInitOutputData%writeOutputHdr)) THEN 
      ALLOCATE(DstInitOutputData%writeOutputHdr(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitOutputData%writeOutputHdr.', ErrStat, ErrMsg,'MD_CopyInitOutput')
         RETURN
      END IF
   END IF
   DstInitOutputData%writeOutputHdr = SrcInitOutputData%writeOutputHdr
ENDIF
IF (ALLOCATED(SrcInitOutputData%writeOutputUnt)) THEN
   i1_l = LBOUND(SrcInitOutputData%writeOutputUnt,1)
   i1_u = UBOUND(SrcInitOutputData%writeOutputUnt,1)
   IF (.NOT. ALLOCATED(DstInitOutputData%writeOutputUnt)) THEN 
      ALLOCATE(DstInitOutputData%writeOutputUnt(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitOutputData%writeOutputUnt.', ErrStat, ErrMsg,'MD_CopyInitOutput')
         RETURN
      END IF
   END IF
   DstInitOutputData%writeOutputUnt = SrcInitOutputData%writeOutputUnt
ENDIF
      CALL NWTC_Library_Copyprogdesc( SrcInitOutputData%Ver, DstInitOutputData%Ver, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'MD_CopyInitOutput:Ver')
         IF (ErrStat>=AbortErrLev) RETURN
 END SUBROUTINE MD_CopyInitOutput

 SUBROUTINE MD_DestroyInitOutput( InitOutputData, ErrStat, ErrMsg )
  TYPE(MD_InitOutputType), INTENT(INOUT) :: InitOutputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(InitOutputData%writeOutputHdr)) THEN
   DEALLOCATE(InitOutputData%writeOutputHdr)
ENDIF
IF (ALLOCATED(InitOutputData%writeOutputUnt)) THEN
   DEALLOCATE(InitOutputData%writeOutputUnt)
ENDIF
  CALL NWTC_Library_Destroyprogdesc( InitOutputData%Ver, ErrStat, ErrMsg )
 END SUBROUTINE MD_DestroyInitOutput

 SUBROUTINE MD_PackInitOutput( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(MD_InitOutputType),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_Ver_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_Ver_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_Ver_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
!  missing buffer for writeOutputHdr
!  missing buffer for writeOutputUnt
  CALL NWTC_Library_Packprogdesc( Re_Ver_Buf, Db_Ver_Buf, Int_Ver_Buf, InData%Ver, ErrStat, ErrMsg, .TRUE. ) ! Ver 
  IF(ALLOCATED(Re_Ver_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_Ver_Buf  ) ! Ver
  IF(ALLOCATED(Db_Ver_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_Ver_Buf  ) ! Ver
  IF(ALLOCATED(Int_Ver_Buf))Int_BufSz = Int_BufSz + SIZE( Int_Ver_Buf ) ! Ver
  IF(ALLOCATED(Re_Ver_Buf))  DEALLOCATE(Re_Ver_Buf)
  IF(ALLOCATED(Db_Ver_Buf))  DEALLOCATE(Db_Ver_Buf)
  IF(ALLOCATED(Int_Ver_Buf)) DEALLOCATE(Int_Ver_Buf)
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  CALL NWTC_Library_Packprogdesc( Re_Ver_Buf, Db_Ver_Buf, Int_Ver_Buf, InData%Ver, ErrStat, ErrMsg, OnlySize ) ! Ver 
  IF(ALLOCATED(Re_Ver_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Ver_Buf)-1 ) = Re_Ver_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_Ver_Buf)
  ENDIF
  IF(ALLOCATED(Db_Ver_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Ver_Buf)-1 ) = Db_Ver_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_Ver_Buf)
  ENDIF
  IF(ALLOCATED(Int_Ver_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Ver_Buf)-1 ) = Int_Ver_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_Ver_Buf)
  ENDIF
  IF( ALLOCATED(Re_Ver_Buf) )  DEALLOCATE(Re_Ver_Buf)
  IF( ALLOCATED(Db_Ver_Buf) )  DEALLOCATE(Db_Ver_Buf)
  IF( ALLOCATED(Int_Ver_Buf) ) DEALLOCATE(Int_Ver_Buf)
 END SUBROUTINE MD_PackInitOutput

 SUBROUTINE MD_UnPackInitOutput( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(MD_InitOutputType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_Ver_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_Ver_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_Ver_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
 ! first call NWTC_Library_Packprogdesc to get correctly sized buffers for unpacking
  CALL NWTC_Library_Packprogdesc( Re_Ver_Buf, Db_Ver_Buf, Int_Ver_Buf, OutData%Ver, ErrStat, ErrMsg, .TRUE. ) ! Ver 
  IF(ALLOCATED(Re_Ver_Buf)) THEN
    Re_Ver_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Ver_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_Ver_Buf)
  ENDIF
  IF(ALLOCATED(Db_Ver_Buf)) THEN
    Db_Ver_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Ver_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_Ver_Buf)
  ENDIF
  IF(ALLOCATED(Int_Ver_Buf)) THEN
    Int_Ver_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Ver_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_Ver_Buf)
  ENDIF
  CALL NWTC_Library_UnPackprogdesc( Re_Ver_Buf, Db_Ver_Buf, Int_Ver_Buf, OutData%Ver, ErrStat, ErrMsg ) ! Ver 
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE MD_UnPackInitOutput

 SUBROUTINE MD_CopyContState( SrcContStateData, DstContStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(MD_ContinuousStateType), INTENT(IN) :: SrcContStateData
   TYPE(MD_ContinuousStateType), INTENT(INOUT) :: DstContStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcContStateData%states)) THEN
   i1_l = LBOUND(SrcContStateData%states,1)
   i1_u = UBOUND(SrcContStateData%states,1)
   IF (.NOT. ALLOCATED(DstContStateData%states)) THEN 
      ALLOCATE(DstContStateData%states(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstContStateData%states.', ErrStat, ErrMsg,'MD_CopyContState')
         RETURN
      END IF
   END IF
   DstContStateData%states = SrcContStateData%states
ENDIF
 END SUBROUTINE MD_CopyContState

 SUBROUTINE MD_DestroyContState( ContStateData, ErrStat, ErrMsg )
  TYPE(MD_ContinuousStateType), INTENT(INOUT) :: ContStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(ContStateData%states)) THEN
   DEALLOCATE(ContStateData%states)
ENDIF
 END SUBROUTINE MD_DestroyContState

 SUBROUTINE MD_PackContState( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(MD_ContinuousStateType),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  IF ( ALLOCATED(InData%states) )   Re_BufSz    = Re_BufSz    + SIZE( InData%states )  ! states 
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( ALLOCATED(InData%states) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%states))-1 ) =  PACK(InData%states ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%states)
  ENDIF
 END SUBROUTINE MD_PackContState

 SUBROUTINE MD_UnPackContState( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(MD_ContinuousStateType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  IF ( ALLOCATED(OutData%states) ) THEN
  ALLOCATE(mask1(SIZE(OutData%states,1)))
  mask1 = .TRUE.
    OutData%states = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%states))-1 ),mask1,OutData%states)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%states)
  ENDIF
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE MD_UnPackContState

 SUBROUTINE MD_CopyDiscState( SrcDiscStateData, DstDiscStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(MD_DiscreteStateType), INTENT(IN) :: SrcDiscStateData
   TYPE(MD_DiscreteStateType), INTENT(INOUT) :: DstDiscStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
   DstDiscStateData%dummy = SrcDiscStateData%dummy
 END SUBROUTINE MD_CopyDiscState

 SUBROUTINE MD_DestroyDiscState( DiscStateData, ErrStat, ErrMsg )
  TYPE(MD_DiscreteStateType), INTENT(INOUT) :: DiscStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
 END SUBROUTINE MD_DestroyDiscState

 SUBROUTINE MD_PackDiscState( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(MD_DiscreteStateType),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Re_BufSz   = Re_BufSz   + 1  ! dummy
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%dummy )
  Re_Xferred   = Re_Xferred   + 1
 END SUBROUTINE MD_PackDiscState

 SUBROUTINE MD_UnPackDiscState( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(MD_DiscreteStateType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  OutData%dummy = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE MD_UnPackDiscState

 SUBROUTINE MD_CopyOtherState( SrcOtherStateData, DstOtherStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(MD_OtherStateType), INTENT(IN) :: SrcOtherStateData
   TYPE(MD_OtherStateType), INTENT(INOUT) :: DstOtherStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcOtherStateData%LineTypeList)) THEN
   i1_l = LBOUND(SrcOtherStateData%LineTypeList,1)
   i1_u = UBOUND(SrcOtherStateData%LineTypeList,1)
   IF (.NOT. ALLOCATED(DstOtherStateData%LineTypeList)) THEN 
      ALLOCATE(DstOtherStateData%LineTypeList(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOtherStateData%LineTypeList.', ErrStat, ErrMsg,'MD_CopyOtherState')
         RETURN
      END IF
   END IF
   DO i1 = LBOUND(SrcOtherStateData%LineTypeList,1), UBOUND(SrcOtherStateData%LineTypeList,1)
      CALL MD_Copylineprop( SrcOtherStateData%LineTypeList(i1), DstOtherStateData%LineTypeList(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'MD_CopyOtherState:LineTypeList(i1)')
         IF (ErrStat>=AbortErrLev) RETURN
   ENDDO
ENDIF
IF (ALLOCATED(SrcOtherStateData%ConnectList)) THEN
   i1_l = LBOUND(SrcOtherStateData%ConnectList,1)
   i1_u = UBOUND(SrcOtherStateData%ConnectList,1)
   IF (.NOT. ALLOCATED(DstOtherStateData%ConnectList)) THEN 
      ALLOCATE(DstOtherStateData%ConnectList(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOtherStateData%ConnectList.', ErrStat, ErrMsg,'MD_CopyOtherState')
         RETURN
      END IF
   END IF
   DO i1 = LBOUND(SrcOtherStateData%ConnectList,1), UBOUND(SrcOtherStateData%ConnectList,1)
      CALL MD_Copyconnect( SrcOtherStateData%ConnectList(i1), DstOtherStateData%ConnectList(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'MD_CopyOtherState:ConnectList(i1)')
         IF (ErrStat>=AbortErrLev) RETURN
   ENDDO
ENDIF
IF (ALLOCATED(SrcOtherStateData%LineList)) THEN
   i1_l = LBOUND(SrcOtherStateData%LineList,1)
   i1_u = UBOUND(SrcOtherStateData%LineList,1)
   IF (.NOT. ALLOCATED(DstOtherStateData%LineList)) THEN 
      ALLOCATE(DstOtherStateData%LineList(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOtherStateData%LineList.', ErrStat, ErrMsg,'MD_CopyOtherState')
         RETURN
      END IF
   END IF
   DO i1 = LBOUND(SrcOtherStateData%LineList,1), UBOUND(SrcOtherStateData%LineList,1)
      CALL MD_Copyline( SrcOtherStateData%LineList(i1), DstOtherStateData%LineList(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'MD_CopyOtherState:LineList(i1)')
         IF (ErrStat>=AbortErrLev) RETURN
   ENDDO
ENDIF
IF (ALLOCATED(SrcOtherStateData%FairIdList)) THEN
   i1_l = LBOUND(SrcOtherStateData%FairIdList,1)
   i1_u = UBOUND(SrcOtherStateData%FairIdList,1)
   IF (.NOT. ALLOCATED(DstOtherStateData%FairIdList)) THEN 
      ALLOCATE(DstOtherStateData%FairIdList(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOtherStateData%FairIdList.', ErrStat, ErrMsg,'MD_CopyOtherState')
         RETURN
      END IF
   END IF
   DstOtherStateData%FairIdList = SrcOtherStateData%FairIdList
ENDIF
IF (ALLOCATED(SrcOtherStateData%LineStateIndList)) THEN
   i1_l = LBOUND(SrcOtherStateData%LineStateIndList,1)
   i1_u = UBOUND(SrcOtherStateData%LineStateIndList,1)
   IF (.NOT. ALLOCATED(DstOtherStateData%LineStateIndList)) THEN 
      ALLOCATE(DstOtherStateData%LineStateIndList(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOtherStateData%LineStateIndList.', ErrStat, ErrMsg,'MD_CopyOtherState')
         RETURN
      END IF
   END IF
   DstOtherStateData%LineStateIndList = SrcOtherStateData%LineStateIndList
ENDIF
IF (ALLOCATED(SrcOtherStateData%F)) THEN
   i1_l = LBOUND(SrcOtherStateData%F,1)
   i1_u = UBOUND(SrcOtherStateData%F,1)
   IF (.NOT. ALLOCATED(DstOtherStateData%F)) THEN 
      ALLOCATE(DstOtherStateData%F(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOtherStateData%F.', ErrStat, ErrMsg,'MD_CopyOtherState')
         RETURN
      END IF
   END IF
   DstOtherStateData%F = SrcOtherStateData%F
ENDIF
 END SUBROUTINE MD_CopyOtherState

 SUBROUTINE MD_DestroyOtherState( OtherStateData, ErrStat, ErrMsg )
  TYPE(MD_OtherStateType), INTENT(INOUT) :: OtherStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(OtherStateData%LineTypeList)) THEN
DO i1 = LBOUND(OtherStateData%LineTypeList,1), UBOUND(OtherStateData%LineTypeList,1)
  CALL MD_Destroylineprop( OtherStateData%LineTypeList(i1), ErrStat, ErrMsg )
ENDDO
   DEALLOCATE(OtherStateData%LineTypeList)
ENDIF
IF (ALLOCATED(OtherStateData%ConnectList)) THEN
DO i1 = LBOUND(OtherStateData%ConnectList,1), UBOUND(OtherStateData%ConnectList,1)
  CALL MD_Destroyconnect( OtherStateData%ConnectList(i1), ErrStat, ErrMsg )
ENDDO
   DEALLOCATE(OtherStateData%ConnectList)
ENDIF
IF (ALLOCATED(OtherStateData%LineList)) THEN
DO i1 = LBOUND(OtherStateData%LineList,1), UBOUND(OtherStateData%LineList,1)
  CALL MD_Destroyline( OtherStateData%LineList(i1), ErrStat, ErrMsg )
ENDDO
   DEALLOCATE(OtherStateData%LineList)
ENDIF
IF (ALLOCATED(OtherStateData%FairIdList)) THEN
   DEALLOCATE(OtherStateData%FairIdList)
ENDIF
IF (ALLOCATED(OtherStateData%LineStateIndList)) THEN
   DEALLOCATE(OtherStateData%LineStateIndList)
ENDIF
IF (ALLOCATED(OtherStateData%F)) THEN
   DEALLOCATE(OtherStateData%F)
ENDIF
 END SUBROUTINE MD_DestroyOtherState

 SUBROUTINE MD_PackOtherState( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(MD_OtherStateType),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_LineTypeList_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_LineTypeList_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_LineTypeList_Buf(:)
  REAL(ReKi),     ALLOCATABLE :: Re_ConnectList_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_ConnectList_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_ConnectList_Buf(:)
  REAL(ReKi),     ALLOCATABLE :: Re_LineList_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_LineList_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_LineList_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
DO i1 = LBOUND(InData%LineTypeList,1), UBOUND(InData%LineTypeList,1)
  CALL MD_Packlineprop( Re_LineTypeList_Buf, Db_LineTypeList_Buf, Int_LineTypeList_Buf, InData%LineTypeList(i1), ErrStat, ErrMsg, .TRUE. ) ! LineTypeList 
  IF(ALLOCATED(Re_LineTypeList_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_LineTypeList_Buf  ) ! LineTypeList
  IF(ALLOCATED(Db_LineTypeList_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_LineTypeList_Buf  ) ! LineTypeList
  IF(ALLOCATED(Int_LineTypeList_Buf))Int_BufSz = Int_BufSz + SIZE( Int_LineTypeList_Buf ) ! LineTypeList
  IF(ALLOCATED(Re_LineTypeList_Buf))  DEALLOCATE(Re_LineTypeList_Buf)
  IF(ALLOCATED(Db_LineTypeList_Buf))  DEALLOCATE(Db_LineTypeList_Buf)
  IF(ALLOCATED(Int_LineTypeList_Buf)) DEALLOCATE(Int_LineTypeList_Buf)
ENDDO
DO i1 = LBOUND(InData%ConnectList,1), UBOUND(InData%ConnectList,1)
  CALL MD_Packconnect( Re_ConnectList_Buf, Db_ConnectList_Buf, Int_ConnectList_Buf, InData%ConnectList(i1), ErrStat, ErrMsg, .TRUE. ) ! ConnectList 
  IF(ALLOCATED(Re_ConnectList_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_ConnectList_Buf  ) ! ConnectList
  IF(ALLOCATED(Db_ConnectList_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_ConnectList_Buf  ) ! ConnectList
  IF(ALLOCATED(Int_ConnectList_Buf))Int_BufSz = Int_BufSz + SIZE( Int_ConnectList_Buf ) ! ConnectList
  IF(ALLOCATED(Re_ConnectList_Buf))  DEALLOCATE(Re_ConnectList_Buf)
  IF(ALLOCATED(Db_ConnectList_Buf))  DEALLOCATE(Db_ConnectList_Buf)
  IF(ALLOCATED(Int_ConnectList_Buf)) DEALLOCATE(Int_ConnectList_Buf)
ENDDO
DO i1 = LBOUND(InData%LineList,1), UBOUND(InData%LineList,1)
  CALL MD_Packline( Re_LineList_Buf, Db_LineList_Buf, Int_LineList_Buf, InData%LineList(i1), ErrStat, ErrMsg, .TRUE. ) ! LineList 
  IF(ALLOCATED(Re_LineList_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_LineList_Buf  ) ! LineList
  IF(ALLOCATED(Db_LineList_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_LineList_Buf  ) ! LineList
  IF(ALLOCATED(Int_LineList_Buf))Int_BufSz = Int_BufSz + SIZE( Int_LineList_Buf ) ! LineList
  IF(ALLOCATED(Re_LineList_Buf))  DEALLOCATE(Re_LineList_Buf)
  IF(ALLOCATED(Db_LineList_Buf))  DEALLOCATE(Db_LineList_Buf)
  IF(ALLOCATED(Int_LineList_Buf)) DEALLOCATE(Int_LineList_Buf)
ENDDO
  IF ( ALLOCATED(InData%FairIdList) )   Int_BufSz   = Int_BufSz   + SIZE( InData%FairIdList )  ! FairIdList 
  IF ( ALLOCATED(InData%LineStateIndList) )   Int_BufSz   = Int_BufSz   + SIZE( InData%LineStateIndList )  ! LineStateIndList 
  IF ( ALLOCATED(InData%F) )   Re_BufSz    = Re_BufSz    + SIZE( InData%F )  ! F 
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
DO i1 = LBOUND(InData%LineTypeList,1), UBOUND(InData%LineTypeList,1)
  CALL MD_Packlineprop( Re_LineTypeList_Buf, Db_LineTypeList_Buf, Int_LineTypeList_Buf, InData%LineTypeList(i1), ErrStat, ErrMsg, OnlySize ) ! LineTypeList 
  IF(ALLOCATED(Re_LineTypeList_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_LineTypeList_Buf)-1 ) = Re_LineTypeList_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_LineTypeList_Buf)
  ENDIF
  IF(ALLOCATED(Db_LineTypeList_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_LineTypeList_Buf)-1 ) = Db_LineTypeList_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_LineTypeList_Buf)
  ENDIF
  IF(ALLOCATED(Int_LineTypeList_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_LineTypeList_Buf)-1 ) = Int_LineTypeList_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_LineTypeList_Buf)
  ENDIF
  IF( ALLOCATED(Re_LineTypeList_Buf) )  DEALLOCATE(Re_LineTypeList_Buf)
  IF( ALLOCATED(Db_LineTypeList_Buf) )  DEALLOCATE(Db_LineTypeList_Buf)
  IF( ALLOCATED(Int_LineTypeList_Buf) ) DEALLOCATE(Int_LineTypeList_Buf)
ENDDO
DO i1 = LBOUND(InData%ConnectList,1), UBOUND(InData%ConnectList,1)
  CALL MD_Packconnect( Re_ConnectList_Buf, Db_ConnectList_Buf, Int_ConnectList_Buf, InData%ConnectList(i1), ErrStat, ErrMsg, OnlySize ) ! ConnectList 
  IF(ALLOCATED(Re_ConnectList_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_ConnectList_Buf)-1 ) = Re_ConnectList_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_ConnectList_Buf)
  ENDIF
  IF(ALLOCATED(Db_ConnectList_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_ConnectList_Buf)-1 ) = Db_ConnectList_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_ConnectList_Buf)
  ENDIF
  IF(ALLOCATED(Int_ConnectList_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_ConnectList_Buf)-1 ) = Int_ConnectList_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_ConnectList_Buf)
  ENDIF
  IF( ALLOCATED(Re_ConnectList_Buf) )  DEALLOCATE(Re_ConnectList_Buf)
  IF( ALLOCATED(Db_ConnectList_Buf) )  DEALLOCATE(Db_ConnectList_Buf)
  IF( ALLOCATED(Int_ConnectList_Buf) ) DEALLOCATE(Int_ConnectList_Buf)
ENDDO
DO i1 = LBOUND(InData%LineList,1), UBOUND(InData%LineList,1)
  CALL MD_Packline( Re_LineList_Buf, Db_LineList_Buf, Int_LineList_Buf, InData%LineList(i1), ErrStat, ErrMsg, OnlySize ) ! LineList 
  IF(ALLOCATED(Re_LineList_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_LineList_Buf)-1 ) = Re_LineList_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_LineList_Buf)
  ENDIF
  IF(ALLOCATED(Db_LineList_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_LineList_Buf)-1 ) = Db_LineList_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_LineList_Buf)
  ENDIF
  IF(ALLOCATED(Int_LineList_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_LineList_Buf)-1 ) = Int_LineList_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_LineList_Buf)
  ENDIF
  IF( ALLOCATED(Re_LineList_Buf) )  DEALLOCATE(Re_LineList_Buf)
  IF( ALLOCATED(Db_LineList_Buf) )  DEALLOCATE(Db_LineList_Buf)
  IF( ALLOCATED(Int_LineList_Buf) ) DEALLOCATE(Int_LineList_Buf)
ENDDO
  IF ( ALLOCATED(InData%FairIdList) ) THEN
    IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%FairIdList))-1 ) = PACK(InData%FairIdList ,.TRUE.)
    Int_Xferred   = Int_Xferred   + SIZE(InData%FairIdList)
  ENDIF
  IF ( ALLOCATED(InData%LineStateIndList) ) THEN
    IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%LineStateIndList))-1 ) = PACK(InData%LineStateIndList ,.TRUE.)
    Int_Xferred   = Int_Xferred   + SIZE(InData%LineStateIndList)
  ENDIF
  IF ( ALLOCATED(InData%F) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%F))-1 ) =  PACK(InData%F ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%F)
  ENDIF
 END SUBROUTINE MD_PackOtherState

 SUBROUTINE MD_UnPackOtherState( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(MD_OtherStateType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_LineTypeList_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_LineTypeList_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_LineTypeList_Buf(:)
  REAL(ReKi),    ALLOCATABLE :: Re_ConnectList_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_ConnectList_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_ConnectList_Buf(:)
  REAL(ReKi),    ALLOCATABLE :: Re_LineList_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_LineList_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_LineList_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
DO i1 = LBOUND(OutData%LineTypeList,1), UBOUND(OutData%LineTypeList,1)
 ! first call MD_Packlineprop to get correctly sized buffers for unpacking
  CALL MD_Packlineprop( Re_LineTypeList_Buf, Db_LineTypeList_Buf, Int_LineTypeList_Buf, OutData%LineTypeList(i1), ErrStat, ErrMsg, .TRUE. ) ! LineTypeList 
  IF(ALLOCATED(Re_LineTypeList_Buf)) THEN
    Re_LineTypeList_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_LineTypeList_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_LineTypeList_Buf)
  ENDIF
  IF(ALLOCATED(Db_LineTypeList_Buf)) THEN
    Db_LineTypeList_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_LineTypeList_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_LineTypeList_Buf)
  ENDIF
  IF(ALLOCATED(Int_LineTypeList_Buf)) THEN
    Int_LineTypeList_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_LineTypeList_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_LineTypeList_Buf)
  ENDIF
  CALL MD_UnPacklineprop( Re_LineTypeList_Buf, Db_LineTypeList_Buf, Int_LineTypeList_Buf, OutData%LineTypeList(i1), ErrStat, ErrMsg ) ! LineTypeList 
ENDDO
DO i1 = LBOUND(OutData%ConnectList,1), UBOUND(OutData%ConnectList,1)
 ! first call MD_Packconnect to get correctly sized buffers for unpacking
  CALL MD_Packconnect( Re_ConnectList_Buf, Db_ConnectList_Buf, Int_ConnectList_Buf, OutData%ConnectList(i1), ErrStat, ErrMsg, .TRUE. ) ! ConnectList 
  IF(ALLOCATED(Re_ConnectList_Buf)) THEN
    Re_ConnectList_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_ConnectList_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_ConnectList_Buf)
  ENDIF
  IF(ALLOCATED(Db_ConnectList_Buf)) THEN
    Db_ConnectList_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_ConnectList_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_ConnectList_Buf)
  ENDIF
  IF(ALLOCATED(Int_ConnectList_Buf)) THEN
    Int_ConnectList_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_ConnectList_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_ConnectList_Buf)
  ENDIF
  CALL MD_UnPackconnect( Re_ConnectList_Buf, Db_ConnectList_Buf, Int_ConnectList_Buf, OutData%ConnectList(i1), ErrStat, ErrMsg ) ! ConnectList 
ENDDO
DO i1 = LBOUND(OutData%LineList,1), UBOUND(OutData%LineList,1)
 ! first call MD_Packline to get correctly sized buffers for unpacking
  CALL MD_Packline( Re_LineList_Buf, Db_LineList_Buf, Int_LineList_Buf, OutData%LineList(i1), ErrStat, ErrMsg, .TRUE. ) ! LineList 
  IF(ALLOCATED(Re_LineList_Buf)) THEN
    Re_LineList_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_LineList_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_LineList_Buf)
  ENDIF
  IF(ALLOCATED(Db_LineList_Buf)) THEN
    Db_LineList_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_LineList_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_LineList_Buf)
  ENDIF
  IF(ALLOCATED(Int_LineList_Buf)) THEN
    Int_LineList_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_LineList_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_LineList_Buf)
  ENDIF
  CALL MD_UnPackline( Re_LineList_Buf, Db_LineList_Buf, Int_LineList_Buf, OutData%LineList(i1), ErrStat, ErrMsg ) ! LineList 
ENDDO
  IF ( ALLOCATED(OutData%FairIdList) ) THEN
  ALLOCATE(mask1(SIZE(OutData%FairIdList,1)))
  mask1 = .TRUE.
    OutData%FairIdList = UNPACK(IntKiBuf( Int_Xferred:Re_Xferred+(SIZE(OutData%FairIdList))-1 ),mask1,OutData%FairIdList)
  DEALLOCATE(mask1)
    Int_Xferred   = Int_Xferred   + SIZE(OutData%FairIdList)
  ENDIF
  IF ( ALLOCATED(OutData%LineStateIndList) ) THEN
  ALLOCATE(mask1(SIZE(OutData%LineStateIndList,1)))
  mask1 = .TRUE.
    OutData%LineStateIndList = UNPACK(IntKiBuf( Int_Xferred:Re_Xferred+(SIZE(OutData%LineStateIndList))-1 ),mask1,OutData%LineStateIndList)
  DEALLOCATE(mask1)
    Int_Xferred   = Int_Xferred   + SIZE(OutData%LineStateIndList)
  ENDIF
  IF ( ALLOCATED(OutData%F) ) THEN
  ALLOCATE(mask1(SIZE(OutData%F,1)))
  mask1 = .TRUE.
    OutData%F = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%F))-1 ),mask1,OutData%F)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%F)
  ENDIF
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE MD_UnPackOtherState

 SUBROUTINE MD_CopyConstrState( SrcConstrStateData, DstConstrStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(MD_ConstraintStateType), INTENT(IN) :: SrcConstrStateData
   TYPE(MD_ConstraintStateType), INTENT(INOUT) :: DstConstrStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcConstrStateData%dummy)) THEN
   i1_l = LBOUND(SrcConstrStateData%dummy,1)
   i1_u = UBOUND(SrcConstrStateData%dummy,1)
   IF (.NOT. ALLOCATED(DstConstrStateData%dummy)) THEN 
      ALLOCATE(DstConstrStateData%dummy(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstConstrStateData%dummy.', ErrStat, ErrMsg,'MD_CopyConstrState')
         RETURN
      END IF
   END IF
   DstConstrStateData%dummy = SrcConstrStateData%dummy
ENDIF
 END SUBROUTINE MD_CopyConstrState

 SUBROUTINE MD_DestroyConstrState( ConstrStateData, ErrStat, ErrMsg )
  TYPE(MD_ConstraintStateType), INTENT(INOUT) :: ConstrStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(ConstrStateData%dummy)) THEN
   DEALLOCATE(ConstrStateData%dummy)
ENDIF
 END SUBROUTINE MD_DestroyConstrState

 SUBROUTINE MD_PackConstrState( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(MD_ConstraintStateType),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  IF ( ALLOCATED(InData%dummy) )   Re_BufSz    = Re_BufSz    + SIZE( InData%dummy )  ! dummy 
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( ALLOCATED(InData%dummy) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%dummy))-1 ) =  PACK(InData%dummy ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%dummy)
  ENDIF
 END SUBROUTINE MD_PackConstrState

 SUBROUTINE MD_UnPackConstrState( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(MD_ConstraintStateType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  IF ( ALLOCATED(OutData%dummy) ) THEN
  ALLOCATE(mask1(SIZE(OutData%dummy,1)))
  mask1 = .TRUE.
    OutData%dummy = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%dummy))-1 ),mask1,OutData%dummy)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%dummy)
  ENDIF
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE MD_UnPackConstrState

 SUBROUTINE MD_CopyParam( SrcParamData, DstParamData, CtrlCode, ErrStat, ErrMsg )
   TYPE(MD_ParameterType), INTENT(IN) :: SrcParamData
   TYPE(MD_ParameterType), INTENT(INOUT) :: DstParamData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
   DstParamData%NTypes = SrcParamData%NTypes
   DstParamData%NConnects = SrcParamData%NConnects
   DstParamData%NLines = SrcParamData%NLines
   DstParamData%NFairs = SrcParamData%NFairs
   DstParamData%g = SrcParamData%g
   DstParamData%rhoW = SrcParamData%rhoW
   DstParamData%WtrDpth = SrcParamData%WtrDpth
   DstParamData%kBot = SrcParamData%kBot
   DstParamData%cBot = SrcParamData%cBot
   DstParamData%dtM0 = SrcParamData%dtM0
   DstParamData%dtCoupling = SrcParamData%dtCoupling
   DstParamData%NumOuts = SrcParamData%NumOuts
   DstParamData%RootName = SrcParamData%RootName
IF (ALLOCATED(SrcParamData%OutParam)) THEN
   i1_l = LBOUND(SrcParamData%OutParam,1)
   i1_u = UBOUND(SrcParamData%OutParam,1)
   IF (.NOT. ALLOCATED(DstParamData%OutParam)) THEN 
      ALLOCATE(DstParamData%OutParam(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%OutParam.', ErrStat, ErrMsg,'MD_CopyParam')
         RETURN
      END IF
   END IF
   DO i1 = LBOUND(SrcParamData%OutParam,1), UBOUND(SrcParamData%OutParam,1)
      CALL MD_Copyoutparmtype( SrcParamData%OutParam(i1), DstParamData%OutParam(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'MD_CopyParam:OutParam(i1)')
         IF (ErrStat>=AbortErrLev) RETURN
   ENDDO
ENDIF
   DstParamData%Delim = SrcParamData%Delim
 END SUBROUTINE MD_CopyParam

 SUBROUTINE MD_DestroyParam( ParamData, ErrStat, ErrMsg )
  TYPE(MD_ParameterType), INTENT(INOUT) :: ParamData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(ParamData%OutParam)) THEN
DO i1 = LBOUND(ParamData%OutParam,1), UBOUND(ParamData%OutParam,1)
  CALL MD_Destroyoutparmtype( ParamData%OutParam(i1), ErrStat, ErrMsg )
ENDDO
   DEALLOCATE(ParamData%OutParam)
ENDIF
 END SUBROUTINE MD_DestroyParam

 SUBROUTINE MD_PackParam( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(MD_ParameterType),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_OutParam_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_OutParam_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_OutParam_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Int_BufSz  = Int_BufSz  + 1  ! NTypes
  Int_BufSz  = Int_BufSz  + 1  ! NConnects
  Int_BufSz  = Int_BufSz  + 1  ! NLines
  Int_BufSz  = Int_BufSz  + 1  ! NFairs
  Re_BufSz   = Re_BufSz   + 1  ! g
  Re_BufSz   = Re_BufSz   + 1  ! rhoW
  Re_BufSz   = Re_BufSz   + 1  ! WtrDpth
  Re_BufSz   = Re_BufSz   + 1  ! kBot
  Re_BufSz   = Re_BufSz   + 1  ! cBot
  Re_BufSz   = Re_BufSz   + 1  ! dtM0
  Re_BufSz   = Re_BufSz   + 1  ! dtCoupling
  Int_BufSz  = Int_BufSz  + 1  ! NumOuts
!  missing buffer for RootName
DO i1 = LBOUND(InData%OutParam,1), UBOUND(InData%OutParam,1)
  CALL MD_Packoutparmtype( Re_OutParam_Buf, Db_OutParam_Buf, Int_OutParam_Buf, InData%OutParam(i1), ErrStat, ErrMsg, .TRUE. ) ! OutParam 
  IF(ALLOCATED(Re_OutParam_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_OutParam_Buf  ) ! OutParam
  IF(ALLOCATED(Db_OutParam_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_OutParam_Buf  ) ! OutParam
  IF(ALLOCATED(Int_OutParam_Buf))Int_BufSz = Int_BufSz + SIZE( Int_OutParam_Buf ) ! OutParam
  IF(ALLOCATED(Re_OutParam_Buf))  DEALLOCATE(Re_OutParam_Buf)
  IF(ALLOCATED(Db_OutParam_Buf))  DEALLOCATE(Db_OutParam_Buf)
  IF(ALLOCATED(Int_OutParam_Buf)) DEALLOCATE(Int_OutParam_Buf)
ENDDO
!  missing buffer for Delim
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NTypes )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NConnects )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NLines )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NFairs )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%g )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%rhoW )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%WtrDpth )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%kBot )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%cBot )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%dtM0 )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%dtCoupling )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NumOuts )
  Int_Xferred   = Int_Xferred   + 1
DO i1 = LBOUND(InData%OutParam,1), UBOUND(InData%OutParam,1)
  CALL MD_Packoutparmtype( Re_OutParam_Buf, Db_OutParam_Buf, Int_OutParam_Buf, InData%OutParam(i1), ErrStat, ErrMsg, OnlySize ) ! OutParam 
  IF(ALLOCATED(Re_OutParam_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_OutParam_Buf)-1 ) = Re_OutParam_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_OutParam_Buf)
  ENDIF
  IF(ALLOCATED(Db_OutParam_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_OutParam_Buf)-1 ) = Db_OutParam_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_OutParam_Buf)
  ENDIF
  IF(ALLOCATED(Int_OutParam_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_OutParam_Buf)-1 ) = Int_OutParam_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_OutParam_Buf)
  ENDIF
  IF( ALLOCATED(Re_OutParam_Buf) )  DEALLOCATE(Re_OutParam_Buf)
  IF( ALLOCATED(Db_OutParam_Buf) )  DEALLOCATE(Db_OutParam_Buf)
  IF( ALLOCATED(Int_OutParam_Buf) ) DEALLOCATE(Int_OutParam_Buf)
ENDDO
 END SUBROUTINE MD_PackParam

 SUBROUTINE MD_UnPackParam( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(MD_ParameterType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_OutParam_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_OutParam_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_OutParam_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  OutData%NTypes = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%NConnects = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%NLines = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%NFairs = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%g = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%rhoW = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%WtrDpth = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%kBot = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%cBot = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%dtM0 = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%dtCoupling = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%NumOuts = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
DO i1 = LBOUND(OutData%OutParam,1), UBOUND(OutData%OutParam,1)
 ! first call MD_Packoutparmtype to get correctly sized buffers for unpacking
  CALL MD_Packoutparmtype( Re_OutParam_Buf, Db_OutParam_Buf, Int_OutParam_Buf, OutData%OutParam(i1), ErrStat, ErrMsg, .TRUE. ) ! OutParam 
  IF(ALLOCATED(Re_OutParam_Buf)) THEN
    Re_OutParam_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_OutParam_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_OutParam_Buf)
  ENDIF
  IF(ALLOCATED(Db_OutParam_Buf)) THEN
    Db_OutParam_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_OutParam_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_OutParam_Buf)
  ENDIF
  IF(ALLOCATED(Int_OutParam_Buf)) THEN
    Int_OutParam_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_OutParam_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_OutParam_Buf)
  ENDIF
  CALL MD_UnPackoutparmtype( Re_OutParam_Buf, Db_OutParam_Buf, Int_OutParam_Buf, OutData%OutParam(i1), ErrStat, ErrMsg ) ! OutParam 
ENDDO
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE MD_UnPackParam

 SUBROUTINE MD_CopyInput( SrcInputData, DstInputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(MD_InputType), INTENT(INOUT) :: SrcInputData
   TYPE(MD_InputType), INTENT(INOUT) :: DstInputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
     CALL MeshCopy( SrcInputData%PtFairleadDisplacement, DstInputData%PtFairleadDisplacement, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'MD_CopyInput:PtFairleadDisplacement')
         IF (ErrStat>=AbortErrLev) RETURN
 END SUBROUTINE MD_CopyInput

 SUBROUTINE MD_DestroyInput( InputData, ErrStat, ErrMsg )
  TYPE(MD_InputType), INTENT(INOUT) :: InputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  CALL MeshDestroy( InputData%PtFairleadDisplacement, ErrStat, ErrMsg )
 END SUBROUTINE MD_DestroyInput

 SUBROUTINE MD_PackInput( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(MD_InputType),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_PtFairleadDisplacement_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_PtFairleadDisplacement_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_PtFairleadDisplacement_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
 ! Allocate mesh buffers, if any (we'll also get sizes from these) 
  CALL MeshPack( InData%PtFairleadDisplacement, Re_PtFairleadDisplacement_Buf, Db_PtFairleadDisplacement_Buf, Int_PtFairleadDisplacement_Buf, ErrStat, ErrMsg, .TRUE. ) ! PtFairleadDisplacement 
  IF(ALLOCATED(Re_PtFairleadDisplacement_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_PtFairleadDisplacement_Buf  ) ! PtFairleadDisplacement
  IF(ALLOCATED(Db_PtFairleadDisplacement_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_PtFairleadDisplacement_Buf  ) ! PtFairleadDisplacement
  IF(ALLOCATED(Int_PtFairleadDisplacement_Buf))Int_BufSz = Int_BufSz + SIZE( Int_PtFairleadDisplacement_Buf ) ! PtFairleadDisplacement
  IF(ALLOCATED(Re_PtFairleadDisplacement_Buf))  DEALLOCATE(Re_PtFairleadDisplacement_Buf)
  IF(ALLOCATED(Db_PtFairleadDisplacement_Buf))  DEALLOCATE(Db_PtFairleadDisplacement_Buf)
  IF(ALLOCATED(Int_PtFairleadDisplacement_Buf)) DEALLOCATE(Int_PtFairleadDisplacement_Buf)
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  CALL MeshPack( InData%PtFairleadDisplacement, Re_PtFairleadDisplacement_Buf, Db_PtFairleadDisplacement_Buf, Int_PtFairleadDisplacement_Buf, ErrStat, ErrMsg, OnlySize ) ! PtFairleadDisplacement 
  IF(ALLOCATED(Re_PtFairleadDisplacement_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_PtFairleadDisplacement_Buf)-1 ) = Re_PtFairleadDisplacement_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_PtFairleadDisplacement_Buf)
  ENDIF
  IF(ALLOCATED(Db_PtFairleadDisplacement_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_PtFairleadDisplacement_Buf)-1 ) = Db_PtFairleadDisplacement_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_PtFairleadDisplacement_Buf)
  ENDIF
  IF(ALLOCATED(Int_PtFairleadDisplacement_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_PtFairleadDisplacement_Buf)-1 ) = Int_PtFairleadDisplacement_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_PtFairleadDisplacement_Buf)
  ENDIF
  IF( ALLOCATED(Re_PtFairleadDisplacement_Buf) )  DEALLOCATE(Re_PtFairleadDisplacement_Buf)
  IF( ALLOCATED(Db_PtFairleadDisplacement_Buf) )  DEALLOCATE(Db_PtFairleadDisplacement_Buf)
  IF( ALLOCATED(Int_PtFairleadDisplacement_Buf) ) DEALLOCATE(Int_PtFairleadDisplacement_Buf)
 END SUBROUTINE MD_PackInput

 SUBROUTINE MD_UnPackInput( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(MD_InputType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_PtFairleadDisplacement_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_PtFairleadDisplacement_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_PtFairleadDisplacement_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
 ! first call MeshPack to get correctly sized buffers for unpacking
  CALL MeshPack( OutData%PtFairleadDisplacement, Re_PtFairleadDisplacement_Buf, Db_PtFairleadDisplacement_Buf, Int_PtFairleadDisplacement_Buf, ErrStat, ErrMsg , .TRUE. ) ! PtFairleadDisplacement 
  IF(ALLOCATED(Re_PtFairleadDisplacement_Buf)) THEN
    Re_PtFairleadDisplacement_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_PtFairleadDisplacement_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_PtFairleadDisplacement_Buf)
  ENDIF
  IF(ALLOCATED(Db_PtFairleadDisplacement_Buf)) THEN
    Db_PtFairleadDisplacement_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_PtFairleadDisplacement_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_PtFairleadDisplacement_Buf)
  ENDIF
  IF(ALLOCATED(Int_PtFairleadDisplacement_Buf)) THEN
    Int_PtFairleadDisplacement_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_PtFairleadDisplacement_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_PtFairleadDisplacement_Buf)
  ENDIF
  CALL MeshUnPack( OutData%PtFairleadDisplacement, Re_PtFairleadDisplacement_Buf, Db_PtFairleadDisplacement_Buf, Int_PtFairleadDisplacement_Buf, ErrStat, ErrMsg ) ! PtFairleadDisplacement 
  IF( ALLOCATED(Re_PtFairleadDisplacement_Buf) )  DEALLOCATE(Re_PtFairleadDisplacement_Buf)
  IF( ALLOCATED(Db_PtFairleadDisplacement_Buf) )  DEALLOCATE(Db_PtFairleadDisplacement_Buf)
  IF( ALLOCATED(Int_PtFairleadDisplacement_Buf) ) DEALLOCATE(Int_PtFairleadDisplacement_Buf)
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE MD_UnPackInput

 SUBROUTINE MD_CopyOutput( SrcOutputData, DstOutputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(MD_OutputType), INTENT(INOUT) :: SrcOutputData
   TYPE(MD_OutputType), INTENT(INOUT) :: DstOutputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
     CALL MeshCopy( SrcOutputData%PtFairleadLoad, DstOutputData%PtFairleadLoad, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'MD_CopyOutput:PtFairleadLoad')
         IF (ErrStat>=AbortErrLev) RETURN
IF (ALLOCATED(SrcOutputData%WriteOutput)) THEN
   i1_l = LBOUND(SrcOutputData%WriteOutput,1)
   i1_u = UBOUND(SrcOutputData%WriteOutput,1)
   IF (.NOT. ALLOCATED(DstOutputData%WriteOutput)) THEN 
      ALLOCATE(DstOutputData%WriteOutput(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOutputData%WriteOutput.', ErrStat, ErrMsg,'MD_CopyOutput')
         RETURN
      END IF
   END IF
   DstOutputData%WriteOutput = SrcOutputData%WriteOutput
ENDIF
 END SUBROUTINE MD_CopyOutput

 SUBROUTINE MD_DestroyOutput( OutputData, ErrStat, ErrMsg )
  TYPE(MD_OutputType), INTENT(INOUT) :: OutputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  CALL MeshDestroy( OutputData%PtFairleadLoad, ErrStat, ErrMsg )
IF (ALLOCATED(OutputData%WriteOutput)) THEN
   DEALLOCATE(OutputData%WriteOutput)
ENDIF
 END SUBROUTINE MD_DestroyOutput

 SUBROUTINE MD_PackOutput( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(MD_OutputType),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_PtFairleadLoad_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_PtFairleadLoad_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_PtFairleadLoad_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
 ! Allocate mesh buffers, if any (we'll also get sizes from these) 
  CALL MeshPack( InData%PtFairleadLoad, Re_PtFairleadLoad_Buf, Db_PtFairleadLoad_Buf, Int_PtFairleadLoad_Buf, ErrStat, ErrMsg, .TRUE. ) ! PtFairleadLoad 
  IF(ALLOCATED(Re_PtFairleadLoad_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_PtFairleadLoad_Buf  ) ! PtFairleadLoad
  IF(ALLOCATED(Db_PtFairleadLoad_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_PtFairleadLoad_Buf  ) ! PtFairleadLoad
  IF(ALLOCATED(Int_PtFairleadLoad_Buf))Int_BufSz = Int_BufSz + SIZE( Int_PtFairleadLoad_Buf ) ! PtFairleadLoad
  IF(ALLOCATED(Re_PtFairleadLoad_Buf))  DEALLOCATE(Re_PtFairleadLoad_Buf)
  IF(ALLOCATED(Db_PtFairleadLoad_Buf))  DEALLOCATE(Db_PtFairleadLoad_Buf)
  IF(ALLOCATED(Int_PtFairleadLoad_Buf)) DEALLOCATE(Int_PtFairleadLoad_Buf)
  IF ( ALLOCATED(InData%WriteOutput) )   Re_BufSz    = Re_BufSz    + SIZE( InData%WriteOutput )  ! WriteOutput 
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  CALL MeshPack( InData%PtFairleadLoad, Re_PtFairleadLoad_Buf, Db_PtFairleadLoad_Buf, Int_PtFairleadLoad_Buf, ErrStat, ErrMsg, OnlySize ) ! PtFairleadLoad 
  IF(ALLOCATED(Re_PtFairleadLoad_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_PtFairleadLoad_Buf)-1 ) = Re_PtFairleadLoad_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_PtFairleadLoad_Buf)
  ENDIF
  IF(ALLOCATED(Db_PtFairleadLoad_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_PtFairleadLoad_Buf)-1 ) = Db_PtFairleadLoad_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_PtFairleadLoad_Buf)
  ENDIF
  IF(ALLOCATED(Int_PtFairleadLoad_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_PtFairleadLoad_Buf)-1 ) = Int_PtFairleadLoad_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_PtFairleadLoad_Buf)
  ENDIF
  IF( ALLOCATED(Re_PtFairleadLoad_Buf) )  DEALLOCATE(Re_PtFairleadLoad_Buf)
  IF( ALLOCATED(Db_PtFairleadLoad_Buf) )  DEALLOCATE(Db_PtFairleadLoad_Buf)
  IF( ALLOCATED(Int_PtFairleadLoad_Buf) ) DEALLOCATE(Int_PtFairleadLoad_Buf)
  IF ( ALLOCATED(InData%WriteOutput) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%WriteOutput))-1 ) =  PACK(InData%WriteOutput ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%WriteOutput)
  ENDIF
 END SUBROUTINE MD_PackOutput

 SUBROUTINE MD_UnPackOutput( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(MD_OutputType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_PtFairleadLoad_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_PtFairleadLoad_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_PtFairleadLoad_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
 ! first call MeshPack to get correctly sized buffers for unpacking
  CALL MeshPack( OutData%PtFairleadLoad, Re_PtFairleadLoad_Buf, Db_PtFairleadLoad_Buf, Int_PtFairleadLoad_Buf, ErrStat, ErrMsg , .TRUE. ) ! PtFairleadLoad 
  IF(ALLOCATED(Re_PtFairleadLoad_Buf)) THEN
    Re_PtFairleadLoad_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_PtFairleadLoad_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_PtFairleadLoad_Buf)
  ENDIF
  IF(ALLOCATED(Db_PtFairleadLoad_Buf)) THEN
    Db_PtFairleadLoad_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_PtFairleadLoad_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_PtFairleadLoad_Buf)
  ENDIF
  IF(ALLOCATED(Int_PtFairleadLoad_Buf)) THEN
    Int_PtFairleadLoad_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_PtFairleadLoad_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_PtFairleadLoad_Buf)
  ENDIF
  CALL MeshUnPack( OutData%PtFairleadLoad, Re_PtFairleadLoad_Buf, Db_PtFairleadLoad_Buf, Int_PtFairleadLoad_Buf, ErrStat, ErrMsg ) ! PtFairleadLoad 
  IF( ALLOCATED(Re_PtFairleadLoad_Buf) )  DEALLOCATE(Re_PtFairleadLoad_Buf)
  IF( ALLOCATED(Db_PtFairleadLoad_Buf) )  DEALLOCATE(Db_PtFairleadLoad_Buf)
  IF( ALLOCATED(Int_PtFairleadLoad_Buf) ) DEALLOCATE(Int_PtFairleadLoad_Buf)
  IF ( ALLOCATED(OutData%WriteOutput) ) THEN
  ALLOCATE(mask1(SIZE(OutData%WriteOutput,1)))
  mask1 = .TRUE.
    OutData%WriteOutput = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%WriteOutput))-1 ),mask1,OutData%WriteOutput)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%WriteOutput)
  ENDIF
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE MD_UnPackOutput


 SUBROUTINE MD_Input_ExtrapInterp(u, tin, u_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) input u_out at time t_out, from previous/future time
! values of u (which has values associated with times in t).  Order of the interpolation is given by the size of u
!
!  expressions below based on either
!
!  f(t) = a
!  f(t) = a + b * t, or
!  f(t) = a + b * t + c * t**2
!
!  where a, b and c are determined as the solution to
!  f(t1) = u1, f(t2) = u2, f(t3) = u3  (as appropriate)
!
!..................................................................................................................................

 TYPE(MD_inputtype), INTENT(INOUT)  :: u(:)      ! Inputs at t1 > t2 > t3
 REAL(DbKi),         INTENT(IN   )  :: tin(:)      ! Times associated with the inputs
 TYPE(MD_inputtype), INTENT(INOUT)  :: u_out     ! Inputs at tin_out
 REAL(DbKi),         INTENT(IN   )  :: tin_out     ! time to be extrap/interp'd to
 INTEGER(IntKi),     INTENT(  OUT)  :: ErrStat   ! Error status of the operation
 CHARACTER(*),       INTENT(  OUT)  :: ErrMsg    ! Error message if ErrStat /= ErrID_None
   ! local variables
 REAL(DbKi) :: t(SIZE(tin))    ! Times associated with the inputs
 REAL(DbKi) :: t_out           ! Time to which to be extrap/interpd
 INTEGER(IntKi)                 :: order    ! order of polynomial fit (max 2)
 REAL(DbKi)                                 :: b0       ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: c0       ! temporary for extrapolation/interpolation
 INTEGER(IntKi)                             :: ErrStat2 ! local errors
 CHARACTER(1024)                            :: ErrMsg2  ! local errors
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
    ! we'll subtract a constant from the times to resolve some 
    ! numerical issues when t gets large (and to simplify the equations)
 t = tin - tin(1)
 t_out = tin_out - tin(1)

 if ( size(t) .ne. size(u)) then
    ErrStat = ErrID_Fatal
    ErrMsg = ' Error in MD_Input_ExtrapInterp: size(t) must equal size(u) '
    RETURN
 endif
 if (size(u) .gt. 3) then
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in MD_Input_ExtrapInterp: size(u) must be less than 4 '
    RETURN
 endif
 order = SIZE(u) - 1
 IF ( order .eq. 0 ) THEN
  CALL MeshCopy(u(1)%PtFairleadDisplacement, u_out%PtFairleadDisplacement, MESH_UPDATECOPY, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'MD_Input_ExtrapInterp:%PtFairleadDisplacement')
         IF (ErrStat>=AbortErrLev) RETURN
 ELSE IF ( order .eq. 1 ) THEN
  IF ( EqualRealNos( t(1), t(2) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in MD_Input_ExtrapInterp: t(1) must not equal t(2) to avoid a division-by-zero error.'
    RETURN
  END IF
  CALL MeshExtrapInterp1(u(1)%PtFairleadDisplacement, u(2)%PtFairleadDisplacement, tin, u_out%PtFairleadDisplacement, tin_out, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'MD_Input_ExtrapInterp:%PtFairleadDisplacement')
         IF (ErrStat>=AbortErrLev) RETURN
 ELSE IF ( order .eq. 2 ) THEN
  IF ( EqualRealNos( t(1), t(2) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in MD_Input_ExtrapInterp: t(1) must not equal t(2) to avoid a division-by-zero error.'
    RETURN
  END IF
  IF ( EqualRealNos( t(2), t(3) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in MD_Input_ExtrapInterp: t(2) must not equal t(3) to avoid a division-by-zero error.'
    RETURN
  END IF
  IF ( EqualRealNos( t(1), t(3) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in MD_Input_ExtrapInterp: t(1) must not equal t(3) to avoid a division-by-zero error.'
    RETURN
  END IF
  CALL MeshExtrapInterp2(u(1)%PtFairleadDisplacement, u(2)%PtFairleadDisplacement, u(3)%PtFairleadDisplacement, tin, u_out%PtFairleadDisplacement, tin_out, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'MD_Input_ExtrapInterp:%PtFairleadDisplacement')
         IF (ErrStat>=AbortErrLev) RETURN
 ELSE 
   ErrStat = ErrID_Fatal
   ErrMsg = ' order must be less than 3 in MD_Input_ExtrapInterp '
   RETURN
 ENDIF 
 END SUBROUTINE MD_Input_ExtrapInterp


 SUBROUTINE MD_Output_ExtrapInterp(u, tin, u_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) input u_out at time t_out, from previous/future time
! values of u (which has values associated with times in t).  Order of the interpolation is given by the size of u
!
!  expressions below based on either
!
!  f(t) = a
!  f(t) = a + b * t, or
!  f(t) = a + b * t + c * t**2
!
!  where a, b and c are determined as the solution to
!  f(t1) = u1, f(t2) = u2, f(t3) = u3  (as appropriate)
!
!..................................................................................................................................

 TYPE(MD_outputtype), INTENT(INOUT)  :: u(:)      ! Inputs at t1 > t2 > t3
 REAL(DbKi),         INTENT(IN   )  :: tin(:)      ! Times associated with the inputs
 TYPE(MD_outputtype), INTENT(INOUT)  :: u_out     ! Inputs at tin_out
 REAL(DbKi),         INTENT(IN   )  :: tin_out     ! time to be extrap/interp'd to
 INTEGER(IntKi),     INTENT(  OUT)  :: ErrStat   ! Error status of the operation
 CHARACTER(*),       INTENT(  OUT)  :: ErrMsg    ! Error message if ErrStat /= ErrID_None
   ! local variables
 REAL(DbKi) :: t(SIZE(tin))    ! Times associated with the inputs
 REAL(DbKi) :: t_out           ! Time to which to be extrap/interpd
 INTEGER(IntKi)                 :: order    ! order of polynomial fit (max 2)
 REAL(DbKi)                                 :: b0       ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: c0       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:)        :: b1       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:)        :: c1       ! temporary for extrapolation/interpolation
 INTEGER(IntKi)                             :: ErrStat2 ! local errors
 CHARACTER(1024)                            :: ErrMsg2  ! local errors
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
    ! we'll subtract a constant from the times to resolve some 
    ! numerical issues when t gets large (and to simplify the equations)
 t = tin - tin(1)
 t_out = tin_out - tin(1)

 if ( size(t) .ne. size(u)) then
    ErrStat = ErrID_Fatal
    ErrMsg = ' Error in MD_Output_ExtrapInterp: size(t) must equal size(u) '
    RETURN
 endif
 if (size(u) .gt. 3) then
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in MD_Output_ExtrapInterp: size(u) must be less than 4 '
    RETURN
 endif
 order = SIZE(u) - 1
 IF ( order .eq. 0 ) THEN
  CALL MeshCopy(u(1)%PtFairleadLoad, u_out%PtFairleadLoad, MESH_UPDATECOPY, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'MD_Output_ExtrapInterp:%PtFairleadLoad')
         IF (ErrStat>=AbortErrLev) RETURN
IF (ALLOCATED(u_out%WriteOutput) .AND. ALLOCATED(u(1)%WriteOutput)) THEN
  u_out%WriteOutput = u(1)%WriteOutput
END IF ! check if allocated
 ELSE IF ( order .eq. 1 ) THEN
  IF ( EqualRealNos( t(1), t(2) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in MD_Output_ExtrapInterp: t(1) must not equal t(2) to avoid a division-by-zero error.'
    RETURN
  END IF
  CALL MeshExtrapInterp1(u(1)%PtFairleadLoad, u(2)%PtFairleadLoad, tin, u_out%PtFairleadLoad, tin_out, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'MD_Output_ExtrapInterp:%PtFairleadLoad')
         IF (ErrStat>=AbortErrLev) RETURN
IF (ALLOCATED(u_out%WriteOutput) .AND. ALLOCATED(u(1)%WriteOutput)) THEN
  ALLOCATE(b1(SIZE(u_out%WriteOutput,1)))
  ALLOCATE(c1(SIZE(u_out%WriteOutput,1)))
  b1 = -(u(1)%WriteOutput - u(2)%WriteOutput)/t(2)
  u_out%WriteOutput = u(1)%WriteOutput + b1 * t_out
  DEALLOCATE(b1)
  DEALLOCATE(c1)
END IF ! check if allocated
 ELSE IF ( order .eq. 2 ) THEN
  IF ( EqualRealNos( t(1), t(2) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in MD_Output_ExtrapInterp: t(1) must not equal t(2) to avoid a division-by-zero error.'
    RETURN
  END IF
  IF ( EqualRealNos( t(2), t(3) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in MD_Output_ExtrapInterp: t(2) must not equal t(3) to avoid a division-by-zero error.'
    RETURN
  END IF
  IF ( EqualRealNos( t(1), t(3) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in MD_Output_ExtrapInterp: t(1) must not equal t(3) to avoid a division-by-zero error.'
    RETURN
  END IF
  CALL MeshExtrapInterp2(u(1)%PtFairleadLoad, u(2)%PtFairleadLoad, u(3)%PtFairleadLoad, tin, u_out%PtFairleadLoad, tin_out, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'MD_Output_ExtrapInterp:%PtFairleadLoad')
         IF (ErrStat>=AbortErrLev) RETURN
IF (ALLOCATED(u_out%WriteOutput) .AND. ALLOCATED(u(1)%WriteOutput)) THEN
  ALLOCATE(b1(SIZE(u_out%WriteOutput,1)))
  ALLOCATE(c1(SIZE(u_out%WriteOutput,1)))
  b1 = (t(3)**2*(u(1)%WriteOutput - u(2)%WriteOutput) + t(2)**2*(-u(1)%WriteOutput + u(3)%WriteOutput))/(t(2)*t(3)*(t(2) - t(3)))
  c1 = ( (t(2)-t(3))*u(1)%WriteOutput + t(3)*u(2)%WriteOutput - t(2)*u(3)%WriteOutput ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%WriteOutput = u(1)%WriteOutput + b1 * t_out + c1 * t_out**2
  DEALLOCATE(b1)
  DEALLOCATE(c1)
END IF ! check if allocated
 ELSE 
   ErrStat = ErrID_Fatal
   ErrMsg = ' order must be less than 3 in MD_Output_ExtrapInterp '
   RETURN
 ENDIF 
 END SUBROUTINE MD_Output_ExtrapInterp

END MODULE MoorDyn_Types
!ENDOFREGISTRYGENERATEDFILE
