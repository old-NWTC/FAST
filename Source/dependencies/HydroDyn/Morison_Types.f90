!STARTOFREGISTRYGENERATEDFILE './Morison_Types.f90'
!
! WARNING This file is generated automatically by the FAST registry
! Do not edit.  Your changes to this file will be lost.
!
! FAST Registry (v2.04.01, 20-Nov-2014)
!*********************************************************************************************************************************
! Morison_Types
!.................................................................................................................................
! This file is part of Morison.
!
! Copyright (C) 2012-2014 National Renewable Energy Laboratory
!
! Licensed under the Apache License, Version 2.0 (the "License");
! you may not use this file except in compliance with the License.
! You may obtain a copy of the License at
!
!     http://www.apache.org/licenses/LICENSE-2.0
!
! Unless required by applicable law or agreed to in writing, software
! distributed under the License is distributed on an "AS IS" BASIS,
! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
! See the License for the specific language governing permissions and
! limitations under the License.
!
!
! W A R N I N G : This file was automatically generated from the FAST registry.  Changes made to this file may be lost.
!
!*********************************************************************************************************************************
MODULE Morison_Types
! This module contains all of the user-defined types needed in Morison. It also contains copy, destroy, pack, and
! unpack routines associated with each defined data type. This code will be generated by the FAST Registry.
!---------------------------------------------------------------------------------------------------------------------------------
USE NWTC_Library
IMPLICIT NONE
    INTEGER(IntKi), PUBLIC, PARAMETER  :: MaxMrsnOutputs = 4032      !  [-]
! =========  Morison_JointType  =======
  TYPE, PUBLIC :: Morison_JointType
    INTEGER(IntKi)  :: JointID      !  [-]
    REAL(ReKi) , DIMENSION(1:3)  :: JointPos      !  [-]
    INTEGER(IntKi)  :: JointAxID      !  [-]
    INTEGER(IntKi)  :: JointAxIDIndx      !  [-]
    INTEGER(IntKi)  :: JointOvrlp      !  [-]
    INTEGER(IntKi)  :: NConnections      !  [-]
    INTEGER(IntKi) , DIMENSION(1:10)  :: ConnectionList      !  [-]
  END TYPE Morison_JointType
! =======================
! =========  Morison_MemberPropType  =======
  TYPE, PUBLIC :: Morison_MemberPropType
    INTEGER(IntKi)  :: PropSetID      !  [-]
    REAL(ReKi)  :: PropD      !  [-]
    REAL(ReKi)  :: PropThck      !  [-]
  END TYPE Morison_MemberPropType
! =======================
! =========  Morison_FilledGroupType  =======
  TYPE, PUBLIC :: Morison_FilledGroupType
    INTEGER(IntKi)  :: FillNumM      !  [-]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: FillMList      !  [-]
    REAL(ReKi)  :: FillFSLoc      !  [-]
    CHARACTER(80)  :: FillDensChr      !  [-]
    REAL(ReKi)  :: FillDens      !  [-]
  END TYPE Morison_FilledGroupType
! =======================
! =========  Morison_CoefDpths  =======
  TYPE, PUBLIC :: Morison_CoefDpths
    REAL(ReKi)  :: Dpth      !  [-]
    REAL(ReKi)  :: DpthCd      !  [-]
    REAL(ReKi)  :: DpthCdMG      !  [-]
    REAL(ReKi)  :: DpthCa      !  [-]
    REAL(ReKi)  :: DpthCaMG      !  [-]
    REAL(ReKi)  :: DpthCp      !  [-]
    REAL(ReKi)  :: DpthCpMG      !  [-]
    REAL(ReKi)  :: DpthAxCa      !  [-]
    REAL(ReKi)  :: DpthAxCaMG      !  [-]
    REAL(ReKi)  :: DpthAxCp      !  [-]
    REAL(ReKi)  :: DpthAxCpMG      !  [-]
  END TYPE Morison_CoefDpths
! =======================
! =========  Morison_AxialCoefType  =======
  TYPE, PUBLIC :: Morison_AxialCoefType
    INTEGER(IntKi)  :: AxCoefID      !  [-]
    REAL(ReKi)  :: AxCd      !  [-]
    REAL(ReKi)  :: AxCa      !  [-]
    REAL(ReKi)  :: AxCp      !  [-]
  END TYPE Morison_AxialCoefType
! =======================
! =========  Morison_MemberInputType  =======
  TYPE, PUBLIC :: Morison_MemberInputType
    INTEGER(IntKi)  :: MemberID      !  [-]
    INTEGER(IntKi)  :: MJointID1      !  [-]
    INTEGER(IntKi)  :: MJointID2      !  [-]
    INTEGER(IntKi)  :: MJointID1Indx      !  [-]
    INTEGER(IntKi)  :: MJointID2Indx      !  [-]
    INTEGER(IntKi)  :: MPropSetID1      !  [-]
    INTEGER(IntKi)  :: MPropSetID2      !  [-]
    INTEGER(IntKi)  :: MPropSetID1Indx      !  [-]
    INTEGER(IntKi)  :: MPropSetID2Indx      !  [-]
    REAL(ReKi)  :: MDivSize      !  [-]
    INTEGER(IntKi)  :: MCoefMod      !  [-]
    INTEGER(IntKi)  :: MmbrCoefIDIndx      !  [-]
    INTEGER(IntKi)  :: MmbrFilledIDIndx      !  [-]
    LOGICAL  :: PropWAMIT      !  [-]
    INTEGER(IntKi)  :: NumSplits      !  [-]
    REAL(ReKi) , DIMENSION(1:5)  :: Splits      !  [-]
    REAL(ReKi) , DIMENSION(1:3,1:3)  :: R_LToG      !  [-]
  END TYPE Morison_MemberInputType
! =======================
! =========  Morison_NodeType  =======
  TYPE, PUBLIC :: Morison_NodeType
    INTEGER(IntKi)  :: NodeType      !  [-]
    INTEGER(IntKi)  :: JointIndx      !  [-]
    REAL(ReKi) , DIMENSION(1:3)  :: JointPos      !  [-]
    INTEGER(IntKi)  :: JointOvrlp      !  [-]
    INTEGER(IntKi)  :: JointAxIDIndx      !  [-]
    INTEGER(IntKi)  :: NConnections      !  [-]
    INTEGER(IntKi) , DIMENSION(1:10)  :: ConnectionList      !  [-]
    INTEGER(IntKi)  :: NConnectPreSplit      !  [-]
    REAL(ReKi)  :: Cd      !  [-]
    REAL(ReKi)  :: CdMG      !  [-]
    REAL(ReKi)  :: Ca      !  [-]
    REAL(ReKi)  :: CaMG      !  [-]
    REAL(ReKi)  :: Cp      !  [-]
    REAL(ReKi)  :: CpMG      !  [-]
    REAL(ReKi)  :: JAxCd      !  [-]
    REAL(ReKi)  :: JAxCa      !  [-]
    REAL(ReKi)  :: JAxCp      !  [-]
    REAL(ReKi)  :: AxCa      !  [-]
    REAL(ReKi)  :: AxCp      !  [-]
    REAL(ReKi)  :: AxCaMG      !  [-]
    REAL(ReKi)  :: AxCpMG      !  [-]
    REAL(ReKi)  :: R      !  [-]
    REAL(ReKi)  :: t      !  [-]
    REAL(ReKi)  :: tMG      !  [-]
    REAL(ReKi)  :: dRdz      !  [-]
    REAL(ReKi)  :: MGdensity      !  [-]
    REAL(ReKi)  :: FillFSLoc      !  [-]
    LOGICAL  :: FillFlag      !  [-]
    REAL(ReKi)  :: FillDensity      !  [-]
    INTEGER(IntKi)  :: InpMbrIndx      !  [-]
    REAL(ReKi)  :: InpMbrDist      !  [-]
    LOGICAL  :: PropWAMIT      !  [-]
    REAL(ReKi) , DIMENSION(1:3,1:3)  :: R_LToG      !  [-]
  END TYPE Morison_NodeType
! =======================
! =========  Morison_MemberType  =======
  TYPE, PUBLIC :: Morison_MemberType
    INTEGER(IntKi)  :: Node1Indx      !  [-]
    INTEGER(IntKi)  :: Node2Indx      !  [-]
    REAL(ReKi)  :: R1      !  [-]
    REAL(ReKi)  :: t1      !  [-]
    REAL(ReKi)  :: R2      !  [-]
    REAL(ReKi)  :: t2      !  [-]
    REAL(ReKi)  :: Cd1      !  [-]
    REAL(ReKi)  :: CdMG1      !  [-]
    REAL(ReKi)  :: Ca1      !  [-]
    REAL(ReKi)  :: CaMG1      !  [-]
    REAL(ReKi)  :: Cp1      !  [-]
    REAL(ReKi)  :: CpMG1      !  [-]
    REAL(ReKi)  :: AxCa1      !  [-]
    REAL(ReKi)  :: AxCaMG1      !  [-]
    REAL(ReKi)  :: AxCp1      !  [-]
    REAL(ReKi)  :: AxCpMG1      !  [-]
    REAL(ReKi)  :: Cd2      !  [-]
    REAL(ReKi)  :: CdMG2      !  [-]
    REAL(ReKi)  :: Ca2      !  [-]
    REAL(ReKi)  :: CaMG2      !  [-]
    REAL(ReKi)  :: Cp2      !  [-]
    REAL(ReKi)  :: CpMG2      !  [-]
    REAL(ReKi)  :: AxCa2      !  [-]
    REAL(ReKi)  :: AxCaMG2      !  [-]
    REAL(ReKi)  :: AxCp2      !  [-]
    REAL(ReKi)  :: AxCpMG2      !  [-]
    REAL(ReKi)  :: InpMbrDist1      !  [-]
    REAL(ReKi)  :: InpMbrDist2      !  [-]
    REAL(ReKi)  :: InpMbrLen      !  [-]
    INTEGER(IntKi)  :: InpMbrIndx      !  [-]
    REAL(ReKi) , DIMENSION(1:3,1:3)  :: R_LToG      !  [-]
    INTEGER(IntKi)  :: NumSplits      !  [-]
    REAL(ReKi) , DIMENSION(1:5)  :: Splits      !  [-]
    REAL(ReKi)  :: MGvolume      !  [-]
    REAL(ReKi)  :: MDivSize      !  [-]
    INTEGER(IntKi)  :: MCoefMod      !  [-]
    INTEGER(IntKi)  :: MmbrCoefIDIndx      !  [-]
    INTEGER(IntKi)  :: MmbrFilledIDIndx      !  [-]
    REAL(ReKi)  :: FillFSLoc      !  [-]
    REAL(ReKi)  :: FillDens      !  [-]
    REAL(ReKi) , DIMENSION(1:6)  :: F_Bouy      !  [-]
    REAL(ReKi) , DIMENSION(1:6)  :: F_DP      !  [-]
    LOGICAL  :: PropWAMIT      !  [-]
  END TYPE Morison_MemberType
! =======================
! =========  Morison_CoefMembers  =======
  TYPE, PUBLIC :: Morison_CoefMembers
    INTEGER(IntKi)  :: MemberID      !  [-]
    REAL(ReKi)  :: MemberCd1      !  [-]
    REAL(ReKi)  :: MemberCd2      !  [-]
    REAL(ReKi)  :: MemberCdMG1      !  [-]
    REAL(ReKi)  :: MemberCdMG2      !  [-]
    REAL(ReKi)  :: MemberCa1      !  [-]
    REAL(ReKi)  :: MemberCa2      !  [-]
    REAL(ReKi)  :: MemberCaMG1      !  [-]
    REAL(ReKi)  :: MemberCaMG2      !  [-]
    REAL(ReKi)  :: MemberCp1      !  [-]
    REAL(ReKi)  :: MemberCp2      !  [-]
    REAL(ReKi)  :: MemberCpMG1      !  [-]
    REAL(ReKi)  :: MemberCpMG2      !  [-]
    REAL(ReKi)  :: MemberAxCa1      !  [-]
    REAL(ReKi)  :: MemberAxCa2      !  [-]
    REAL(ReKi)  :: MemberAxCaMG1      !  [-]
    REAL(ReKi)  :: MemberAxCaMG2      !  [-]
    REAL(ReKi)  :: MemberAxCp1      !  [-]
    REAL(ReKi)  :: MemberAxCp2      !  [-]
    REAL(ReKi)  :: MemberAxCpMG1      !  [-]
    REAL(ReKi)  :: MemberAxCpMG2      !  [-]
  END TYPE Morison_CoefMembers
! =======================
! =========  Morison_MGDepthsType  =======
  TYPE, PUBLIC :: Morison_MGDepthsType
    REAL(ReKi)  :: MGDpth      !  [-]
    REAL(ReKi)  :: MGThck      !  [-]
    REAL(ReKi)  :: MGDens      !  [-]
  END TYPE Morison_MGDepthsType
! =======================
! =========  Morison_MOutput  =======
  TYPE, PUBLIC :: Morison_MOutput
    INTEGER(IntKi)  :: MemberID      !  [-]
    INTEGER(IntKi)  :: NOutLoc      !  [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: NodeLocs      !  [-]
    INTEGER(IntKi)  :: MemberIDIndx      !  [-]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: Marker1      !  [-]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: Marker2      !  [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: s      !  [-]
  END TYPE Morison_MOutput
! =======================
! =========  Morison_JOutput  =======
  TYPE, PUBLIC :: Morison_JOutput
    INTEGER(IntKi)  :: JointID      !  [-]
    INTEGER(IntKi)  :: JointIDIndx      !  [-]
    INTEGER(IntKi)  :: NumMarkers      !  [-]
    INTEGER(IntKi) , DIMENSION(1:10)  :: Markers      !  [-]
  END TYPE Morison_JOutput
! =======================
! =========  Morison_InitInputType  =======
  TYPE, PUBLIC :: Morison_InitInputType
    REAL(ReKi)  :: Gravity      !  [-]
    REAL(ReKi)  :: WtrDens      !  [-]
    REAL(ReKi)  :: WtrDpth      !  [-]
    REAL(ReKi)  :: MSL2SWL      !  [-]
    INTEGER(IntKi)  :: NJoints      !  [-]
    INTEGER(IntKi)  :: NNodes      !  [-]
    INTEGER(IntKi)  :: TotalPossibleSuperMembers      !  [-]
    TYPE(Morison_JointType) , DIMENSION(:), ALLOCATABLE  :: InpJoints      !  [-]
    TYPE(Morison_NodeType) , DIMENSION(:), ALLOCATABLE  :: Nodes      !  [-]
    INTEGER(IntKi)  :: NElements      !  [-]
    TYPE(Morison_MemberType) , DIMENSION(:), ALLOCATABLE  :: Elements      !  [-]
    INTEGER(IntKi)  :: NAxCoefs      !  [-]
    TYPE(Morison_AxialCoefType) , DIMENSION(:), ALLOCATABLE  :: AxialCoefs      !  [-]
    INTEGER(IntKi)  :: NPropSets      !  [-]
    TYPE(Morison_MemberPropType) , DIMENSION(:), ALLOCATABLE  :: MPropSets      !  [-]
    REAL(ReKi)  :: SimplCd      !  [-]
    REAL(ReKi)  :: SimplCdMG      !  [-]
    REAL(ReKi)  :: SimplCa      !  [-]
    REAL(ReKi)  :: SimplCaMG      !  [-]
    REAL(ReKi)  :: SimplCp      !  [-]
    REAL(ReKi)  :: SimplCpMG      !  [-]
    REAL(ReKi)  :: SimplAxCa      !  [-]
    REAL(ReKi)  :: SimplAxCaMG      !  [-]
    REAL(ReKi)  :: SimplAxCp      !  [-]
    REAL(ReKi)  :: SimplAxCpMG      !  [-]
    INTEGER(IntKi)  :: NCoefDpth      !  [-]
    TYPE(Morison_CoefDpths) , DIMENSION(:), ALLOCATABLE  :: CoefDpths      !  [-]
    INTEGER(IntKi)  :: NCoefMembers      !  [-]
    TYPE(Morison_CoefMembers) , DIMENSION(:), ALLOCATABLE  :: CoefMembers      !  [-]
    INTEGER(IntKi)  :: NMembers      !  [-]
    TYPE(Morison_MemberInputType) , DIMENSION(:), ALLOCATABLE  :: InpMembers      !  [-]
    INTEGER(IntKi)  :: NFillGroups      !  [-]
    TYPE(Morison_FilledGroupType) , DIMENSION(:), ALLOCATABLE  :: FilledGroups      !  [-]
    INTEGER(IntKi)  :: NMGDepths      !  [-]
    TYPE(Morison_MGDepthsType) , DIMENSION(:), ALLOCATABLE  :: MGDepths      !  [-]
    REAL(ReKi)  :: MGTop      !  [-]
    REAL(ReKi)  :: MGBottom      !  [-]
    INTEGER(IntKi)  :: NMOutputs      !  [-]
    TYPE(Morison_MOutput) , DIMENSION(:), ALLOCATABLE  :: MOutLst      !  [-]
    INTEGER(IntKi)  :: NJOutputs      !  [-]
    TYPE(Morison_JOutput) , DIMENSION(:), ALLOCATABLE  :: JOutLst      !  [-]
    CHARACTER(10) , DIMENSION(1:4032)  :: OutList      ! This list size needs to be the maximum   of possible outputs because of the use of ReadAry() [-]
    LOGICAL , DIMENSION(:), ALLOCATABLE  :: ValidOutList      !  [-]
    INTEGER(IntKi)  :: NumOuts      !  [-]
    INTEGER(IntKi)  :: OutSwtch      !  [-]
    LOGICAL  :: OutAll      !  [-]
    CHARACTER(1024)  :: OutRootName      !  [-]
    INTEGER(IntKi)  :: UnOutFile      !  [-]
    INTEGER(IntKi)  :: UnSum      !  [-]
    INTEGER(IntKi)  :: NStepWave      !  [-]
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: WaveAcc0      !  [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: WaveTime      !  [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: WaveDynP0      !  [-]
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: WaveVel0      !  [-]
  END TYPE Morison_InitInputType
! =======================
! =========  Morison_InitOutputType  =======
  TYPE, PUBLIC :: Morison_InitOutputType
    TYPE(MeshType)  :: DistribMesh      !  [-]
    TYPE(MeshType)  :: LumpedMesh      !  [-]
    CHARACTER(10) , DIMENSION(:), ALLOCATABLE  :: WriteOutputHdr      !  [-]
    CHARACTER(10) , DIMENSION(:), ALLOCATABLE  :: WriteOutputUnt      !  [-]
  END TYPE Morison_InitOutputType
! =======================
! =========  Morison_ContinuousStateType  =======
  TYPE, PUBLIC :: Morison_ContinuousStateType
    REAL(ReKi)  :: DummyContState      ! Remove this variable if you have continuous states [-]
  END TYPE Morison_ContinuousStateType
! =======================
! =========  Morison_DiscreteStateType  =======
  TYPE, PUBLIC :: Morison_DiscreteStateType
    REAL(ReKi)  :: DummyDiscState      !  [-]
  END TYPE Morison_DiscreteStateType
! =======================
! =========  Morison_ConstraintStateType  =======
  TYPE, PUBLIC :: Morison_ConstraintStateType
    REAL(ReKi)  :: DummyConstrState      ! Remove this variable if you have constraint states [-]
  END TYPE Morison_ConstraintStateType
! =======================
! =========  Morison_OtherStateType  =======
  TYPE, PUBLIC :: Morison_OtherStateType
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: D_F_D      ! Distributed viscous drag loads [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: D_F_I      ! Distributed inertial loads [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: D_F_DP      ! Distributed dynamic pressure loads [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: D_F_AM      ! Distributed total added mass loads [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: D_F_AM_M      ! Distributed member added mass loads [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: D_F_AM_MG      ! Distributed marine growth added mass (weight) loads [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: D_F_AM_F      ! Distributed added mass loads due to flooding/filled fluid [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: D_FV      ! Fluid velocity at line element node [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: D_FA      ! Fluid acceleration at line element node [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: D_FDynP      ! Fluid dynamic pressure at line element node [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: L_F_D      ! Lumped viscous drag loads [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: L_F_I      ! Lumped intertia loads [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: L_F_DP      ! Lumped dynamic pressure loads [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: L_F_AM      ! Lumped added mass loads [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: L_FV      ! Fluid velocity at point element node [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: L_FA      ! Fluid acceleration at point element node [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: L_FDynP      ! Fluid dynamic pressure at point element node [-]
    INTEGER(IntKi)  :: LastIndWave      ! Last time index used in the wave kinematics arrays [-]
  END TYPE Morison_OtherStateType
! =======================
! =========  Morison_ParameterType  =======
  TYPE, PUBLIC :: Morison_ParameterType
    REAL(DbKi)  :: DT      ! Time step for continuous state integration & discrete state update [(sec)]
    REAL(ReKi)  :: WtrDens      !  [-]
    INTEGER(IntKi)  :: NNodes      !  [-]
    TYPE(Morison_NodeType) , DIMENSION(:), ALLOCATABLE  :: Nodes      !  [-]
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: D_F_I      !  [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: D_F_B      !  [-]
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: D_F_DP      !  [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: D_F_MG      !  [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: D_F_BF      !  [-]
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: D_AM_M      !  [-]
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: D_AM_MG      !  [-]
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: D_AM_F      !  [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: D_dragConst      !  [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: L_An      !  [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: L_F_B      !  [-]
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: L_F_I      !  [-]
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: L_F_DP      !  [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: L_F_BF      !  [-]
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: L_AM_M      !  [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: L_dragConst      !  [-]
    INTEGER(IntKi)  :: NDistribMarkers      !  [-]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: distribToNodeIndx      !  [-]
    INTEGER(IntKi)  :: NLumpedMarkers      !  [-]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: lumpedToNodeIndx      !  [-]
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: WaveVel0      !  [-]
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: WaveAcc0      !  [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: WaveDynP0      !  [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: WaveTime      !  [-]
    INTEGER(IntKi)  :: NStepWave      !  [-]
    INTEGER(IntKi)  :: NMOutputs      !  [-]
    TYPE(Morison_MOutput) , DIMENSION(:), ALLOCATABLE  :: MOutLst      !  [-]
    INTEGER(IntKi)  :: NJOutputs      !  [-]
    TYPE(Morison_JOutput) , DIMENSION(:), ALLOCATABLE  :: JOutLst      !  [-]
    TYPE(OutParmType) , DIMENSION(:), ALLOCATABLE  :: OutParam      !  [-]
    INTEGER(IntKi)  :: NumOuts      !  [-]
    INTEGER(IntKi)  :: NumOutAll      !  [-]
    INTEGER(IntKi)  :: OutSwtch      !  [-]
    INTEGER(IntKi)  :: UnOutFile      !  [-]
    CHARACTER(20)  :: OutFmt      !  [-]
    CHARACTER(20)  :: OutSFmt      !  [-]
    CHARACTER(10)  :: Delim      !  [-]
  END TYPE Morison_ParameterType
! =======================
! =========  Morison_InputType  =======
  TYPE, PUBLIC :: Morison_InputType
    TYPE(MeshType)  :: DistribMesh      ! Distributed Loads Meshed input data [-]
    TYPE(MeshType)  :: LumpedMesh      ! Lumped Loads Meshed input data [-]
  END TYPE Morison_InputType
! =======================
! =========  Morison_OutputType  =======
  TYPE, PUBLIC :: Morison_OutputType
    TYPE(MeshType)  :: DistribMesh      ! Distributed Loads Meshed output data [-]
    TYPE(MeshType)  :: LumpedMesh      ! Lumped Loads Meshed output data [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: WriteOutput      !  [-]
  END TYPE Morison_OutputType
! =======================
CONTAINS
 SUBROUTINE Morison_Copyjointtype( SrcjointtypeData, DstjointtypeData, CtrlCode, ErrStat, ErrMsg )
   TYPE(morison_jointtype), INTENT(INOUT) :: SrcjointtypeData
   TYPE(morison_jointtype), INTENT(INOUT) :: DstjointtypeData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
   DstjointtypeData%JointID = SrcjointtypeData%JointID
   DstjointtypeData%JointPos = SrcjointtypeData%JointPos
   DstjointtypeData%JointAxID = SrcjointtypeData%JointAxID
   DstjointtypeData%JointAxIDIndx = SrcjointtypeData%JointAxIDIndx
   DstjointtypeData%JointOvrlp = SrcjointtypeData%JointOvrlp
   DstjointtypeData%NConnections = SrcjointtypeData%NConnections
   DstjointtypeData%ConnectionList = SrcjointtypeData%ConnectionList
 END SUBROUTINE Morison_Copyjointtype

 SUBROUTINE Morison_Destroyjointtype( jointtypeData, ErrStat, ErrMsg )
  TYPE(morison_jointtype), INTENT(INOUT) :: jointtypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
 END SUBROUTINE Morison_Destroyjointtype

 SUBROUTINE Morison_Packjointtype( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(morison_jointtype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Int_BufSz  = Int_BufSz  + 1  ! JointID
  Re_BufSz    = Re_BufSz    + SIZE( InData%JointPos )  ! JointPos 
  Int_BufSz  = Int_BufSz  + 1  ! JointAxID
  Int_BufSz  = Int_BufSz  + 1  ! JointAxIDIndx
  Int_BufSz  = Int_BufSz  + 1  ! JointOvrlp
  Int_BufSz  = Int_BufSz  + 1  ! NConnections
  Int_BufSz   = Int_BufSz   + SIZE( InData%ConnectionList )  ! ConnectionList 
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%JointID )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%JointPos))-1 ) =  PACK(InData%JointPos ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%JointPos)
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%JointAxID )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%JointAxIDIndx )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%JointOvrlp )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NConnections )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%ConnectionList))-1 ) = PACK(InData%ConnectionList ,.TRUE.)
  Int_Xferred   = Int_Xferred   + SIZE(InData%ConnectionList)
 END SUBROUTINE Morison_Packjointtype

 SUBROUTINE Morison_UnPackjointtype( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(morison_jointtype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  OutData%JointID = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  ALLOCATE(mask1(SIZE(OutData%JointPos,1))); mask1 = .TRUE.
  OutData%JointPos = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%JointPos))-1 ),mask1,OutData%JointPos)
  DEALLOCATE(mask1)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%JointPos)
  OutData%JointAxID = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%JointAxIDIndx = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%JointOvrlp = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%NConnections = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  ALLOCATE(mask1(SIZE(OutData%ConnectionList,1))); mask1 = .TRUE.
  OutData%ConnectionList = UNPACK(IntKiBuf( Int_Xferred:Re_Xferred+(SIZE(OutData%ConnectionList))-1 ),mask1,OutData%ConnectionList)
  DEALLOCATE(mask1)
  Int_Xferred   = Int_Xferred   + SIZE(OutData%ConnectionList)
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE Morison_UnPackjointtype

 SUBROUTINE Morison_Copymemberproptype( SrcmemberproptypeData, DstmemberproptypeData, CtrlCode, ErrStat, ErrMsg )
   TYPE(morison_memberproptype), INTENT(INOUT) :: SrcmemberproptypeData
   TYPE(morison_memberproptype), INTENT(INOUT) :: DstmemberproptypeData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
   DstmemberproptypeData%PropSetID = SrcmemberproptypeData%PropSetID
   DstmemberproptypeData%PropD = SrcmemberproptypeData%PropD
   DstmemberproptypeData%PropThck = SrcmemberproptypeData%PropThck
 END SUBROUTINE Morison_Copymemberproptype

 SUBROUTINE Morison_Destroymemberproptype( memberproptypeData, ErrStat, ErrMsg )
  TYPE(morison_memberproptype), INTENT(INOUT) :: memberproptypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
 END SUBROUTINE Morison_Destroymemberproptype

 SUBROUTINE Morison_Packmemberproptype( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(morison_memberproptype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Int_BufSz  = Int_BufSz  + 1  ! PropSetID
  Re_BufSz   = Re_BufSz   + 1  ! PropD
  Re_BufSz   = Re_BufSz   + 1  ! PropThck
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%PropSetID )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%PropD )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%PropThck )
  Re_Xferred   = Re_Xferred   + 1
 END SUBROUTINE Morison_Packmemberproptype

 SUBROUTINE Morison_UnPackmemberproptype( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(morison_memberproptype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  OutData%PropSetID = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%PropD = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%PropThck = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE Morison_UnPackmemberproptype

 SUBROUTINE Morison_Copyfilledgrouptype( SrcfilledgrouptypeData, DstfilledgrouptypeData, CtrlCode, ErrStat, ErrMsg )
   TYPE(morison_filledgrouptype), INTENT(INOUT) :: SrcfilledgrouptypeData
   TYPE(morison_filledgrouptype), INTENT(INOUT) :: DstfilledgrouptypeData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
   DstfilledgrouptypeData%FillNumM = SrcfilledgrouptypeData%FillNumM
IF (ALLOCATED(SrcfilledgrouptypeData%FillMList)) THEN
   i1_l = LBOUND(SrcfilledgrouptypeData%FillMList,1)
   i1_u = UBOUND(SrcfilledgrouptypeData%FillMList,1)
   IF (.NOT. ALLOCATED(DstfilledgrouptypeData%FillMList)) THEN 
      ALLOCATE(DstfilledgrouptypeData%FillMList(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstfilledgrouptypeData%FillMList.', ErrStat, ErrMsg,'Morison_Copyfilledgrouptype')
         RETURN
      END IF
   END IF
   DstfilledgrouptypeData%FillMList = SrcfilledgrouptypeData%FillMList
ENDIF
   DstfilledgrouptypeData%FillFSLoc = SrcfilledgrouptypeData%FillFSLoc
   DstfilledgrouptypeData%FillDensChr = SrcfilledgrouptypeData%FillDensChr
   DstfilledgrouptypeData%FillDens = SrcfilledgrouptypeData%FillDens
 END SUBROUTINE Morison_Copyfilledgrouptype

 SUBROUTINE Morison_Destroyfilledgrouptype( filledgrouptypeData, ErrStat, ErrMsg )
  TYPE(morison_filledgrouptype), INTENT(INOUT) :: filledgrouptypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(filledgrouptypeData%FillMList)) THEN
   DEALLOCATE(filledgrouptypeData%FillMList)
ENDIF
 END SUBROUTINE Morison_Destroyfilledgrouptype

 SUBROUTINE Morison_Packfilledgrouptype( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(morison_filledgrouptype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Int_BufSz  = Int_BufSz  + 1  ! FillNumM
  IF ( ALLOCATED(InData%FillMList) )   Int_BufSz   = Int_BufSz   + SIZE( InData%FillMList )  ! FillMList 
  Re_BufSz   = Re_BufSz   + 1  ! FillFSLoc
!  missing buffer for FillDensChr
  Re_BufSz   = Re_BufSz   + 1  ! FillDens
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%FillNumM )
  Int_Xferred   = Int_Xferred   + 1
  IF ( ALLOCATED(InData%FillMList) ) THEN
    IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%FillMList))-1 ) = PACK(InData%FillMList ,.TRUE.)
    Int_Xferred   = Int_Xferred   + SIZE(InData%FillMList)
  ENDIF
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%FillFSLoc )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%FillDens )
  Re_Xferred   = Re_Xferred   + 1
 END SUBROUTINE Morison_Packfilledgrouptype

 SUBROUTINE Morison_UnPackfilledgrouptype( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(morison_filledgrouptype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  OutData%FillNumM = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  IF ( ALLOCATED(OutData%FillMList) ) THEN
  ALLOCATE(mask1(SIZE(OutData%FillMList,1))); mask1 = .TRUE.
    OutData%FillMList = UNPACK(IntKiBuf( Int_Xferred:Re_Xferred+(SIZE(OutData%FillMList))-1 ),mask1,OutData%FillMList)
  DEALLOCATE(mask1)
    Int_Xferred   = Int_Xferred   + SIZE(OutData%FillMList)
  ENDIF
  OutData%FillFSLoc = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%FillDens = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE Morison_UnPackfilledgrouptype

 SUBROUTINE Morison_Copycoefdpths( SrccoefdpthsData, DstcoefdpthsData, CtrlCode, ErrStat, ErrMsg )
   TYPE(morison_coefdpths), INTENT(INOUT) :: SrccoefdpthsData
   TYPE(morison_coefdpths), INTENT(INOUT) :: DstcoefdpthsData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
   DstcoefdpthsData%Dpth = SrccoefdpthsData%Dpth
   DstcoefdpthsData%DpthCd = SrccoefdpthsData%DpthCd
   DstcoefdpthsData%DpthCdMG = SrccoefdpthsData%DpthCdMG
   DstcoefdpthsData%DpthCa = SrccoefdpthsData%DpthCa
   DstcoefdpthsData%DpthCaMG = SrccoefdpthsData%DpthCaMG
   DstcoefdpthsData%DpthCp = SrccoefdpthsData%DpthCp
   DstcoefdpthsData%DpthCpMG = SrccoefdpthsData%DpthCpMG
   DstcoefdpthsData%DpthAxCa = SrccoefdpthsData%DpthAxCa
   DstcoefdpthsData%DpthAxCaMG = SrccoefdpthsData%DpthAxCaMG
   DstcoefdpthsData%DpthAxCp = SrccoefdpthsData%DpthAxCp
   DstcoefdpthsData%DpthAxCpMG = SrccoefdpthsData%DpthAxCpMG
 END SUBROUTINE Morison_Copycoefdpths

 SUBROUTINE Morison_Destroycoefdpths( coefdpthsData, ErrStat, ErrMsg )
  TYPE(morison_coefdpths), INTENT(INOUT) :: coefdpthsData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
 END SUBROUTINE Morison_Destroycoefdpths

 SUBROUTINE Morison_Packcoefdpths( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(morison_coefdpths),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Re_BufSz   = Re_BufSz   + 1  ! Dpth
  Re_BufSz   = Re_BufSz   + 1  ! DpthCd
  Re_BufSz   = Re_BufSz   + 1  ! DpthCdMG
  Re_BufSz   = Re_BufSz   + 1  ! DpthCa
  Re_BufSz   = Re_BufSz   + 1  ! DpthCaMG
  Re_BufSz   = Re_BufSz   + 1  ! DpthCp
  Re_BufSz   = Re_BufSz   + 1  ! DpthCpMG
  Re_BufSz   = Re_BufSz   + 1  ! DpthAxCa
  Re_BufSz   = Re_BufSz   + 1  ! DpthAxCaMG
  Re_BufSz   = Re_BufSz   + 1  ! DpthAxCp
  Re_BufSz   = Re_BufSz   + 1  ! DpthAxCpMG
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%Dpth )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%DpthCd )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%DpthCdMG )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%DpthCa )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%DpthCaMG )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%DpthCp )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%DpthCpMG )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%DpthAxCa )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%DpthAxCaMG )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%DpthAxCp )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%DpthAxCpMG )
  Re_Xferred   = Re_Xferred   + 1
 END SUBROUTINE Morison_Packcoefdpths

 SUBROUTINE Morison_UnPackcoefdpths( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(morison_coefdpths), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  OutData%Dpth = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%DpthCd = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%DpthCdMG = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%DpthCa = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%DpthCaMG = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%DpthCp = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%DpthCpMG = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%DpthAxCa = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%DpthAxCaMG = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%DpthAxCp = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%DpthAxCpMG = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE Morison_UnPackcoefdpths

 SUBROUTINE Morison_Copyaxialcoeftype( SrcaxialcoeftypeData, DstaxialcoeftypeData, CtrlCode, ErrStat, ErrMsg )
   TYPE(morison_axialcoeftype), INTENT(INOUT) :: SrcaxialcoeftypeData
   TYPE(morison_axialcoeftype), INTENT(INOUT) :: DstaxialcoeftypeData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
   DstaxialcoeftypeData%AxCoefID = SrcaxialcoeftypeData%AxCoefID
   DstaxialcoeftypeData%AxCd = SrcaxialcoeftypeData%AxCd
   DstaxialcoeftypeData%AxCa = SrcaxialcoeftypeData%AxCa
   DstaxialcoeftypeData%AxCp = SrcaxialcoeftypeData%AxCp
 END SUBROUTINE Morison_Copyaxialcoeftype

 SUBROUTINE Morison_Destroyaxialcoeftype( axialcoeftypeData, ErrStat, ErrMsg )
  TYPE(morison_axialcoeftype), INTENT(INOUT) :: axialcoeftypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
 END SUBROUTINE Morison_Destroyaxialcoeftype

 SUBROUTINE Morison_Packaxialcoeftype( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(morison_axialcoeftype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Int_BufSz  = Int_BufSz  + 1  ! AxCoefID
  Re_BufSz   = Re_BufSz   + 1  ! AxCd
  Re_BufSz   = Re_BufSz   + 1  ! AxCa
  Re_BufSz   = Re_BufSz   + 1  ! AxCp
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%AxCoefID )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%AxCd )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%AxCa )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%AxCp )
  Re_Xferred   = Re_Xferred   + 1
 END SUBROUTINE Morison_Packaxialcoeftype

 SUBROUTINE Morison_UnPackaxialcoeftype( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(morison_axialcoeftype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  OutData%AxCoefID = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%AxCd = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%AxCa = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%AxCp = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE Morison_UnPackaxialcoeftype

 SUBROUTINE Morison_Copymemberinputtype( SrcmemberinputtypeData, DstmemberinputtypeData, CtrlCode, ErrStat, ErrMsg )
   TYPE(morison_memberinputtype), INTENT(INOUT) :: SrcmemberinputtypeData
   TYPE(morison_memberinputtype), INTENT(INOUT) :: DstmemberinputtypeData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
   DstmemberinputtypeData%MemberID = SrcmemberinputtypeData%MemberID
   DstmemberinputtypeData%MJointID1 = SrcmemberinputtypeData%MJointID1
   DstmemberinputtypeData%MJointID2 = SrcmemberinputtypeData%MJointID2
   DstmemberinputtypeData%MJointID1Indx = SrcmemberinputtypeData%MJointID1Indx
   DstmemberinputtypeData%MJointID2Indx = SrcmemberinputtypeData%MJointID2Indx
   DstmemberinputtypeData%MPropSetID1 = SrcmemberinputtypeData%MPropSetID1
   DstmemberinputtypeData%MPropSetID2 = SrcmemberinputtypeData%MPropSetID2
   DstmemberinputtypeData%MPropSetID1Indx = SrcmemberinputtypeData%MPropSetID1Indx
   DstmemberinputtypeData%MPropSetID2Indx = SrcmemberinputtypeData%MPropSetID2Indx
   DstmemberinputtypeData%MDivSize = SrcmemberinputtypeData%MDivSize
   DstmemberinputtypeData%MCoefMod = SrcmemberinputtypeData%MCoefMod
   DstmemberinputtypeData%MmbrCoefIDIndx = SrcmemberinputtypeData%MmbrCoefIDIndx
   DstmemberinputtypeData%MmbrFilledIDIndx = SrcmemberinputtypeData%MmbrFilledIDIndx
   DstmemberinputtypeData%PropWAMIT = SrcmemberinputtypeData%PropWAMIT
   DstmemberinputtypeData%NumSplits = SrcmemberinputtypeData%NumSplits
   DstmemberinputtypeData%Splits = SrcmemberinputtypeData%Splits
   DstmemberinputtypeData%R_LToG = SrcmemberinputtypeData%R_LToG
 END SUBROUTINE Morison_Copymemberinputtype

 SUBROUTINE Morison_Destroymemberinputtype( memberinputtypeData, ErrStat, ErrMsg )
  TYPE(morison_memberinputtype), INTENT(INOUT) :: memberinputtypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
 END SUBROUTINE Morison_Destroymemberinputtype

 SUBROUTINE Morison_Packmemberinputtype( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(morison_memberinputtype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Int_BufSz  = Int_BufSz  + 1  ! MemberID
  Int_BufSz  = Int_BufSz  + 1  ! MJointID1
  Int_BufSz  = Int_BufSz  + 1  ! MJointID2
  Int_BufSz  = Int_BufSz  + 1  ! MJointID1Indx
  Int_BufSz  = Int_BufSz  + 1  ! MJointID2Indx
  Int_BufSz  = Int_BufSz  + 1  ! MPropSetID1
  Int_BufSz  = Int_BufSz  + 1  ! MPropSetID2
  Int_BufSz  = Int_BufSz  + 1  ! MPropSetID1Indx
  Int_BufSz  = Int_BufSz  + 1  ! MPropSetID2Indx
  Re_BufSz   = Re_BufSz   + 1  ! MDivSize
  Int_BufSz  = Int_BufSz  + 1  ! MCoefMod
  Int_BufSz  = Int_BufSz  + 1  ! MmbrCoefIDIndx
  Int_BufSz  = Int_BufSz  + 1  ! MmbrFilledIDIndx
  Int_BufSz  = Int_BufSz  + 1  ! PropWAMIT
  Int_BufSz  = Int_BufSz  + 1  ! NumSplits
  Re_BufSz    = Re_BufSz    + SIZE( InData%Splits )  ! Splits 
  Re_BufSz    = Re_BufSz    + SIZE( InData%R_LToG )  ! R_LToG 
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%MemberID )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%MJointID1 )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%MJointID2 )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%MJointID1Indx )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%MJointID2Indx )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%MPropSetID1 )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%MPropSetID2 )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%MPropSetID1Indx )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%MPropSetID2Indx )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%MDivSize )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%MCoefMod )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%MmbrCoefIDIndx )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%MmbrFilledIDIndx )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = TRANSFER( (InData%PropWAMIT ), IntKiBuf(1), 1)
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NumSplits )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Splits))-1 ) =  PACK(InData%Splits ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%Splits)
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%R_LToG))-1 ) =  PACK(InData%R_LToG ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%R_LToG)
 END SUBROUTINE Morison_Packmemberinputtype

 SUBROUTINE Morison_UnPackmemberinputtype( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(morison_memberinputtype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  OutData%MemberID = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%MJointID1 = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%MJointID2 = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%MJointID1Indx = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%MJointID2Indx = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%MPropSetID1 = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%MPropSetID2 = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%MPropSetID1Indx = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%MPropSetID2Indx = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%MDivSize = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%MCoefMod = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%MmbrCoefIDIndx = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%MmbrFilledIDIndx = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%NumSplits = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  ALLOCATE(mask1(SIZE(OutData%Splits,1))); mask1 = .TRUE.
  OutData%Splits = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Splits))-1 ),mask1,OutData%Splits)
  DEALLOCATE(mask1)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%Splits)
  ALLOCATE(mask2(SIZE(OutData%R_LToG,1),SIZE(OutData%R_LToG,2))); mask2 = .TRUE.
  OutData%R_LToG = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%R_LToG))-1 ),mask2,OutData%R_LToG)
  DEALLOCATE(mask2)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%R_LToG)
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE Morison_UnPackmemberinputtype

 SUBROUTINE Morison_Copynodetype( SrcnodetypeData, DstnodetypeData, CtrlCode, ErrStat, ErrMsg )
   TYPE(morison_nodetype), INTENT(INOUT) :: SrcnodetypeData
   TYPE(morison_nodetype), INTENT(INOUT) :: DstnodetypeData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
   DstnodetypeData%NodeType = SrcnodetypeData%NodeType
   DstnodetypeData%JointIndx = SrcnodetypeData%JointIndx
   DstnodetypeData%JointPos = SrcnodetypeData%JointPos
   DstnodetypeData%JointOvrlp = SrcnodetypeData%JointOvrlp
   DstnodetypeData%JointAxIDIndx = SrcnodetypeData%JointAxIDIndx
   DstnodetypeData%NConnections = SrcnodetypeData%NConnections
   DstnodetypeData%ConnectionList = SrcnodetypeData%ConnectionList
   DstnodetypeData%NConnectPreSplit = SrcnodetypeData%NConnectPreSplit
   DstnodetypeData%Cd = SrcnodetypeData%Cd
   DstnodetypeData%CdMG = SrcnodetypeData%CdMG
   DstnodetypeData%Ca = SrcnodetypeData%Ca
   DstnodetypeData%CaMG = SrcnodetypeData%CaMG
   DstnodetypeData%Cp = SrcnodetypeData%Cp
   DstnodetypeData%CpMG = SrcnodetypeData%CpMG
   DstnodetypeData%JAxCd = SrcnodetypeData%JAxCd
   DstnodetypeData%JAxCa = SrcnodetypeData%JAxCa
   DstnodetypeData%JAxCp = SrcnodetypeData%JAxCp
   DstnodetypeData%AxCa = SrcnodetypeData%AxCa
   DstnodetypeData%AxCp = SrcnodetypeData%AxCp
   DstnodetypeData%AxCaMG = SrcnodetypeData%AxCaMG
   DstnodetypeData%AxCpMG = SrcnodetypeData%AxCpMG
   DstnodetypeData%R = SrcnodetypeData%R
   DstnodetypeData%t = SrcnodetypeData%t
   DstnodetypeData%tMG = SrcnodetypeData%tMG
   DstnodetypeData%dRdz = SrcnodetypeData%dRdz
   DstnodetypeData%MGdensity = SrcnodetypeData%MGdensity
   DstnodetypeData%FillFSLoc = SrcnodetypeData%FillFSLoc
   DstnodetypeData%FillFlag = SrcnodetypeData%FillFlag
   DstnodetypeData%FillDensity = SrcnodetypeData%FillDensity
   DstnodetypeData%InpMbrIndx = SrcnodetypeData%InpMbrIndx
   DstnodetypeData%InpMbrDist = SrcnodetypeData%InpMbrDist
   DstnodetypeData%PropWAMIT = SrcnodetypeData%PropWAMIT
   DstnodetypeData%R_LToG = SrcnodetypeData%R_LToG
 END SUBROUTINE Morison_Copynodetype

 SUBROUTINE Morison_Destroynodetype( nodetypeData, ErrStat, ErrMsg )
  TYPE(morison_nodetype), INTENT(INOUT) :: nodetypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
 END SUBROUTINE Morison_Destroynodetype

 SUBROUTINE Morison_Packnodetype( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(morison_nodetype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Int_BufSz  = Int_BufSz  + 1  ! NodeType
  Int_BufSz  = Int_BufSz  + 1  ! JointIndx
  Re_BufSz    = Re_BufSz    + SIZE( InData%JointPos )  ! JointPos 
  Int_BufSz  = Int_BufSz  + 1  ! JointOvrlp
  Int_BufSz  = Int_BufSz  + 1  ! JointAxIDIndx
  Int_BufSz  = Int_BufSz  + 1  ! NConnections
  Int_BufSz   = Int_BufSz   + SIZE( InData%ConnectionList )  ! ConnectionList 
  Int_BufSz  = Int_BufSz  + 1  ! NConnectPreSplit
  Re_BufSz   = Re_BufSz   + 1  ! Cd
  Re_BufSz   = Re_BufSz   + 1  ! CdMG
  Re_BufSz   = Re_BufSz   + 1  ! Ca
  Re_BufSz   = Re_BufSz   + 1  ! CaMG
  Re_BufSz   = Re_BufSz   + 1  ! Cp
  Re_BufSz   = Re_BufSz   + 1  ! CpMG
  Re_BufSz   = Re_BufSz   + 1  ! JAxCd
  Re_BufSz   = Re_BufSz   + 1  ! JAxCa
  Re_BufSz   = Re_BufSz   + 1  ! JAxCp
  Re_BufSz   = Re_BufSz   + 1  ! AxCa
  Re_BufSz   = Re_BufSz   + 1  ! AxCp
  Re_BufSz   = Re_BufSz   + 1  ! AxCaMG
  Re_BufSz   = Re_BufSz   + 1  ! AxCpMG
  Re_BufSz   = Re_BufSz   + 1  ! R
  Re_BufSz   = Re_BufSz   + 1  ! t
  Re_BufSz   = Re_BufSz   + 1  ! tMG
  Re_BufSz   = Re_BufSz   + 1  ! dRdz
  Re_BufSz   = Re_BufSz   + 1  ! MGdensity
  Re_BufSz   = Re_BufSz   + 1  ! FillFSLoc
  Int_BufSz  = Int_BufSz  + 1  ! FillFlag
  Re_BufSz   = Re_BufSz   + 1  ! FillDensity
  Int_BufSz  = Int_BufSz  + 1  ! InpMbrIndx
  Re_BufSz   = Re_BufSz   + 1  ! InpMbrDist
  Int_BufSz  = Int_BufSz  + 1  ! PropWAMIT
  Re_BufSz    = Re_BufSz    + SIZE( InData%R_LToG )  ! R_LToG 
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NodeType )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%JointIndx )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%JointPos))-1 ) =  PACK(InData%JointPos ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%JointPos)
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%JointOvrlp )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%JointAxIDIndx )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NConnections )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%ConnectionList))-1 ) = PACK(InData%ConnectionList ,.TRUE.)
  Int_Xferred   = Int_Xferred   + SIZE(InData%ConnectionList)
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NConnectPreSplit )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%Cd )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%CdMG )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%Ca )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%CaMG )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%Cp )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%CpMG )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%JAxCd )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%JAxCa )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%JAxCp )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%AxCa )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%AxCp )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%AxCaMG )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%AxCpMG )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%R )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%t )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%tMG )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%dRdz )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%MGdensity )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%FillFSLoc )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = TRANSFER( (InData%FillFlag ), IntKiBuf(1), 1)
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%FillDensity )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%InpMbrIndx )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%InpMbrDist )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = TRANSFER( (InData%PropWAMIT ), IntKiBuf(1), 1)
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%R_LToG))-1 ) =  PACK(InData%R_LToG ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%R_LToG)
 END SUBROUTINE Morison_Packnodetype

 SUBROUTINE Morison_UnPacknodetype( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(morison_nodetype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  OutData%NodeType = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%JointIndx = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  ALLOCATE(mask1(SIZE(OutData%JointPos,1))); mask1 = .TRUE.
  OutData%JointPos = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%JointPos))-1 ),mask1,OutData%JointPos)
  DEALLOCATE(mask1)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%JointPos)
  OutData%JointOvrlp = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%JointAxIDIndx = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%NConnections = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  ALLOCATE(mask1(SIZE(OutData%ConnectionList,1))); mask1 = .TRUE.
  OutData%ConnectionList = UNPACK(IntKiBuf( Int_Xferred:Re_Xferred+(SIZE(OutData%ConnectionList))-1 ),mask1,OutData%ConnectionList)
  DEALLOCATE(mask1)
  Int_Xferred   = Int_Xferred   + SIZE(OutData%ConnectionList)
  OutData%NConnectPreSplit = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%Cd = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%CdMG = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%Ca = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%CaMG = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%Cp = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%CpMG = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%JAxCd = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%JAxCa = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%JAxCp = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%AxCa = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%AxCp = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%AxCaMG = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%AxCpMG = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%R = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%t = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%tMG = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%dRdz = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%MGdensity = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%FillFSLoc = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%FillDensity = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%InpMbrIndx = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%InpMbrDist = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  ALLOCATE(mask2(SIZE(OutData%R_LToG,1),SIZE(OutData%R_LToG,2))); mask2 = .TRUE.
  OutData%R_LToG = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%R_LToG))-1 ),mask2,OutData%R_LToG)
  DEALLOCATE(mask2)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%R_LToG)
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE Morison_UnPacknodetype

 SUBROUTINE Morison_Copymembertype( SrcmembertypeData, DstmembertypeData, CtrlCode, ErrStat, ErrMsg )
   TYPE(morison_membertype), INTENT(INOUT) :: SrcmembertypeData
   TYPE(morison_membertype), INTENT(INOUT) :: DstmembertypeData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
   DstmembertypeData%Node1Indx = SrcmembertypeData%Node1Indx
   DstmembertypeData%Node2Indx = SrcmembertypeData%Node2Indx
   DstmembertypeData%R1 = SrcmembertypeData%R1
   DstmembertypeData%t1 = SrcmembertypeData%t1
   DstmembertypeData%R2 = SrcmembertypeData%R2
   DstmembertypeData%t2 = SrcmembertypeData%t2
   DstmembertypeData%Cd1 = SrcmembertypeData%Cd1
   DstmembertypeData%CdMG1 = SrcmembertypeData%CdMG1
   DstmembertypeData%Ca1 = SrcmembertypeData%Ca1
   DstmembertypeData%CaMG1 = SrcmembertypeData%CaMG1
   DstmembertypeData%Cp1 = SrcmembertypeData%Cp1
   DstmembertypeData%CpMG1 = SrcmembertypeData%CpMG1
   DstmembertypeData%AxCa1 = SrcmembertypeData%AxCa1
   DstmembertypeData%AxCaMG1 = SrcmembertypeData%AxCaMG1
   DstmembertypeData%AxCp1 = SrcmembertypeData%AxCp1
   DstmembertypeData%AxCpMG1 = SrcmembertypeData%AxCpMG1
   DstmembertypeData%Cd2 = SrcmembertypeData%Cd2
   DstmembertypeData%CdMG2 = SrcmembertypeData%CdMG2
   DstmembertypeData%Ca2 = SrcmembertypeData%Ca2
   DstmembertypeData%CaMG2 = SrcmembertypeData%CaMG2
   DstmembertypeData%Cp2 = SrcmembertypeData%Cp2
   DstmembertypeData%CpMG2 = SrcmembertypeData%CpMG2
   DstmembertypeData%AxCa2 = SrcmembertypeData%AxCa2
   DstmembertypeData%AxCaMG2 = SrcmembertypeData%AxCaMG2
   DstmembertypeData%AxCp2 = SrcmembertypeData%AxCp2
   DstmembertypeData%AxCpMG2 = SrcmembertypeData%AxCpMG2
   DstmembertypeData%InpMbrDist1 = SrcmembertypeData%InpMbrDist1
   DstmembertypeData%InpMbrDist2 = SrcmembertypeData%InpMbrDist2
   DstmembertypeData%InpMbrLen = SrcmembertypeData%InpMbrLen
   DstmembertypeData%InpMbrIndx = SrcmembertypeData%InpMbrIndx
   DstmembertypeData%R_LToG = SrcmembertypeData%R_LToG
   DstmembertypeData%NumSplits = SrcmembertypeData%NumSplits
   DstmembertypeData%Splits = SrcmembertypeData%Splits
   DstmembertypeData%MGvolume = SrcmembertypeData%MGvolume
   DstmembertypeData%MDivSize = SrcmembertypeData%MDivSize
   DstmembertypeData%MCoefMod = SrcmembertypeData%MCoefMod
   DstmembertypeData%MmbrCoefIDIndx = SrcmembertypeData%MmbrCoefIDIndx
   DstmembertypeData%MmbrFilledIDIndx = SrcmembertypeData%MmbrFilledIDIndx
   DstmembertypeData%FillFSLoc = SrcmembertypeData%FillFSLoc
   DstmembertypeData%FillDens = SrcmembertypeData%FillDens
   DstmembertypeData%F_Bouy = SrcmembertypeData%F_Bouy
   DstmembertypeData%F_DP = SrcmembertypeData%F_DP
   DstmembertypeData%PropWAMIT = SrcmembertypeData%PropWAMIT
 END SUBROUTINE Morison_Copymembertype

 SUBROUTINE Morison_Destroymembertype( membertypeData, ErrStat, ErrMsg )
  TYPE(morison_membertype), INTENT(INOUT) :: membertypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
 END SUBROUTINE Morison_Destroymembertype

 SUBROUTINE Morison_Packmembertype( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(morison_membertype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Int_BufSz  = Int_BufSz  + 1  ! Node1Indx
  Int_BufSz  = Int_BufSz  + 1  ! Node2Indx
  Re_BufSz   = Re_BufSz   + 1  ! R1
  Re_BufSz   = Re_BufSz   + 1  ! t1
  Re_BufSz   = Re_BufSz   + 1  ! R2
  Re_BufSz   = Re_BufSz   + 1  ! t2
  Re_BufSz   = Re_BufSz   + 1  ! Cd1
  Re_BufSz   = Re_BufSz   + 1  ! CdMG1
  Re_BufSz   = Re_BufSz   + 1  ! Ca1
  Re_BufSz   = Re_BufSz   + 1  ! CaMG1
  Re_BufSz   = Re_BufSz   + 1  ! Cp1
  Re_BufSz   = Re_BufSz   + 1  ! CpMG1
  Re_BufSz   = Re_BufSz   + 1  ! AxCa1
  Re_BufSz   = Re_BufSz   + 1  ! AxCaMG1
  Re_BufSz   = Re_BufSz   + 1  ! AxCp1
  Re_BufSz   = Re_BufSz   + 1  ! AxCpMG1
  Re_BufSz   = Re_BufSz   + 1  ! Cd2
  Re_BufSz   = Re_BufSz   + 1  ! CdMG2
  Re_BufSz   = Re_BufSz   + 1  ! Ca2
  Re_BufSz   = Re_BufSz   + 1  ! CaMG2
  Re_BufSz   = Re_BufSz   + 1  ! Cp2
  Re_BufSz   = Re_BufSz   + 1  ! CpMG2
  Re_BufSz   = Re_BufSz   + 1  ! AxCa2
  Re_BufSz   = Re_BufSz   + 1  ! AxCaMG2
  Re_BufSz   = Re_BufSz   + 1  ! AxCp2
  Re_BufSz   = Re_BufSz   + 1  ! AxCpMG2
  Re_BufSz   = Re_BufSz   + 1  ! InpMbrDist1
  Re_BufSz   = Re_BufSz   + 1  ! InpMbrDist2
  Re_BufSz   = Re_BufSz   + 1  ! InpMbrLen
  Int_BufSz  = Int_BufSz  + 1  ! InpMbrIndx
  Re_BufSz    = Re_BufSz    + SIZE( InData%R_LToG )  ! R_LToG 
  Int_BufSz  = Int_BufSz  + 1  ! NumSplits
  Re_BufSz    = Re_BufSz    + SIZE( InData%Splits )  ! Splits 
  Re_BufSz   = Re_BufSz   + 1  ! MGvolume
  Re_BufSz   = Re_BufSz   + 1  ! MDivSize
  Int_BufSz  = Int_BufSz  + 1  ! MCoefMod
  Int_BufSz  = Int_BufSz  + 1  ! MmbrCoefIDIndx
  Int_BufSz  = Int_BufSz  + 1  ! MmbrFilledIDIndx
  Re_BufSz   = Re_BufSz   + 1  ! FillFSLoc
  Re_BufSz   = Re_BufSz   + 1  ! FillDens
  Re_BufSz    = Re_BufSz    + SIZE( InData%F_Bouy )  ! F_Bouy 
  Re_BufSz    = Re_BufSz    + SIZE( InData%F_DP )  ! F_DP 
  Int_BufSz  = Int_BufSz  + 1  ! PropWAMIT
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%Node1Indx )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%Node2Indx )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%R1 )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%t1 )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%R2 )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%t2 )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%Cd1 )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%CdMG1 )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%Ca1 )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%CaMG1 )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%Cp1 )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%CpMG1 )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%AxCa1 )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%AxCaMG1 )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%AxCp1 )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%AxCpMG1 )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%Cd2 )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%CdMG2 )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%Ca2 )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%CaMG2 )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%Cp2 )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%CpMG2 )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%AxCa2 )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%AxCaMG2 )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%AxCp2 )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%AxCpMG2 )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%InpMbrDist1 )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%InpMbrDist2 )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%InpMbrLen )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%InpMbrIndx )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%R_LToG))-1 ) =  PACK(InData%R_LToG ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%R_LToG)
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NumSplits )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Splits))-1 ) =  PACK(InData%Splits ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%Splits)
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%MGvolume )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%MDivSize )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%MCoefMod )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%MmbrCoefIDIndx )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%MmbrFilledIDIndx )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%FillFSLoc )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%FillDens )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%F_Bouy))-1 ) =  PACK(InData%F_Bouy ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%F_Bouy)
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%F_DP))-1 ) =  PACK(InData%F_DP ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%F_DP)
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = TRANSFER( (InData%PropWAMIT ), IntKiBuf(1), 1)
  Int_Xferred   = Int_Xferred   + 1
 END SUBROUTINE Morison_Packmembertype

 SUBROUTINE Morison_UnPackmembertype( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(morison_membertype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  OutData%Node1Indx = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%Node2Indx = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%R1 = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%t1 = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%R2 = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%t2 = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%Cd1 = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%CdMG1 = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%Ca1 = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%CaMG1 = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%Cp1 = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%CpMG1 = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%AxCa1 = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%AxCaMG1 = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%AxCp1 = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%AxCpMG1 = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%Cd2 = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%CdMG2 = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%Ca2 = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%CaMG2 = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%Cp2 = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%CpMG2 = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%AxCa2 = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%AxCaMG2 = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%AxCp2 = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%AxCpMG2 = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%InpMbrDist1 = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%InpMbrDist2 = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%InpMbrLen = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%InpMbrIndx = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  ALLOCATE(mask2(SIZE(OutData%R_LToG,1),SIZE(OutData%R_LToG,2))); mask2 = .TRUE.
  OutData%R_LToG = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%R_LToG))-1 ),mask2,OutData%R_LToG)
  DEALLOCATE(mask2)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%R_LToG)
  OutData%NumSplits = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  ALLOCATE(mask1(SIZE(OutData%Splits,1))); mask1 = .TRUE.
  OutData%Splits = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Splits))-1 ),mask1,OutData%Splits)
  DEALLOCATE(mask1)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%Splits)
  OutData%MGvolume = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%MDivSize = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%MCoefMod = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%MmbrCoefIDIndx = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%MmbrFilledIDIndx = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%FillFSLoc = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%FillDens = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  ALLOCATE(mask1(SIZE(OutData%F_Bouy,1))); mask1 = .TRUE.
  OutData%F_Bouy = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%F_Bouy))-1 ),mask1,OutData%F_Bouy)
  DEALLOCATE(mask1)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%F_Bouy)
  ALLOCATE(mask1(SIZE(OutData%F_DP,1))); mask1 = .TRUE.
  OutData%F_DP = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%F_DP))-1 ),mask1,OutData%F_DP)
  DEALLOCATE(mask1)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%F_DP)
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE Morison_UnPackmembertype

 SUBROUTINE Morison_Copycoefmembers( SrccoefmembersData, DstcoefmembersData, CtrlCode, ErrStat, ErrMsg )
   TYPE(morison_coefmembers), INTENT(INOUT) :: SrccoefmembersData
   TYPE(morison_coefmembers), INTENT(INOUT) :: DstcoefmembersData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
   DstcoefmembersData%MemberID = SrccoefmembersData%MemberID
   DstcoefmembersData%MemberCd1 = SrccoefmembersData%MemberCd1
   DstcoefmembersData%MemberCd2 = SrccoefmembersData%MemberCd2
   DstcoefmembersData%MemberCdMG1 = SrccoefmembersData%MemberCdMG1
   DstcoefmembersData%MemberCdMG2 = SrccoefmembersData%MemberCdMG2
   DstcoefmembersData%MemberCa1 = SrccoefmembersData%MemberCa1
   DstcoefmembersData%MemberCa2 = SrccoefmembersData%MemberCa2
   DstcoefmembersData%MemberCaMG1 = SrccoefmembersData%MemberCaMG1
   DstcoefmembersData%MemberCaMG2 = SrccoefmembersData%MemberCaMG2
   DstcoefmembersData%MemberCp1 = SrccoefmembersData%MemberCp1
   DstcoefmembersData%MemberCp2 = SrccoefmembersData%MemberCp2
   DstcoefmembersData%MemberCpMG1 = SrccoefmembersData%MemberCpMG1
   DstcoefmembersData%MemberCpMG2 = SrccoefmembersData%MemberCpMG2
   DstcoefmembersData%MemberAxCa1 = SrccoefmembersData%MemberAxCa1
   DstcoefmembersData%MemberAxCa2 = SrccoefmembersData%MemberAxCa2
   DstcoefmembersData%MemberAxCaMG1 = SrccoefmembersData%MemberAxCaMG1
   DstcoefmembersData%MemberAxCaMG2 = SrccoefmembersData%MemberAxCaMG2
   DstcoefmembersData%MemberAxCp1 = SrccoefmembersData%MemberAxCp1
   DstcoefmembersData%MemberAxCp2 = SrccoefmembersData%MemberAxCp2
   DstcoefmembersData%MemberAxCpMG1 = SrccoefmembersData%MemberAxCpMG1
   DstcoefmembersData%MemberAxCpMG2 = SrccoefmembersData%MemberAxCpMG2
 END SUBROUTINE Morison_Copycoefmembers

 SUBROUTINE Morison_Destroycoefmembers( coefmembersData, ErrStat, ErrMsg )
  TYPE(morison_coefmembers), INTENT(INOUT) :: coefmembersData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
 END SUBROUTINE Morison_Destroycoefmembers

 SUBROUTINE Morison_Packcoefmembers( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(morison_coefmembers),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Int_BufSz  = Int_BufSz  + 1  ! MemberID
  Re_BufSz   = Re_BufSz   + 1  ! MemberCd1
  Re_BufSz   = Re_BufSz   + 1  ! MemberCd2
  Re_BufSz   = Re_BufSz   + 1  ! MemberCdMG1
  Re_BufSz   = Re_BufSz   + 1  ! MemberCdMG2
  Re_BufSz   = Re_BufSz   + 1  ! MemberCa1
  Re_BufSz   = Re_BufSz   + 1  ! MemberCa2
  Re_BufSz   = Re_BufSz   + 1  ! MemberCaMG1
  Re_BufSz   = Re_BufSz   + 1  ! MemberCaMG2
  Re_BufSz   = Re_BufSz   + 1  ! MemberCp1
  Re_BufSz   = Re_BufSz   + 1  ! MemberCp2
  Re_BufSz   = Re_BufSz   + 1  ! MemberCpMG1
  Re_BufSz   = Re_BufSz   + 1  ! MemberCpMG2
  Re_BufSz   = Re_BufSz   + 1  ! MemberAxCa1
  Re_BufSz   = Re_BufSz   + 1  ! MemberAxCa2
  Re_BufSz   = Re_BufSz   + 1  ! MemberAxCaMG1
  Re_BufSz   = Re_BufSz   + 1  ! MemberAxCaMG2
  Re_BufSz   = Re_BufSz   + 1  ! MemberAxCp1
  Re_BufSz   = Re_BufSz   + 1  ! MemberAxCp2
  Re_BufSz   = Re_BufSz   + 1  ! MemberAxCpMG1
  Re_BufSz   = Re_BufSz   + 1  ! MemberAxCpMG2
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%MemberID )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%MemberCd1 )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%MemberCd2 )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%MemberCdMG1 )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%MemberCdMG2 )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%MemberCa1 )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%MemberCa2 )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%MemberCaMG1 )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%MemberCaMG2 )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%MemberCp1 )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%MemberCp2 )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%MemberCpMG1 )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%MemberCpMG2 )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%MemberAxCa1 )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%MemberAxCa2 )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%MemberAxCaMG1 )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%MemberAxCaMG2 )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%MemberAxCp1 )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%MemberAxCp2 )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%MemberAxCpMG1 )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%MemberAxCpMG2 )
  Re_Xferred   = Re_Xferred   + 1
 END SUBROUTINE Morison_Packcoefmembers

 SUBROUTINE Morison_UnPackcoefmembers( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(morison_coefmembers), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  OutData%MemberID = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%MemberCd1 = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%MemberCd2 = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%MemberCdMG1 = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%MemberCdMG2 = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%MemberCa1 = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%MemberCa2 = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%MemberCaMG1 = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%MemberCaMG2 = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%MemberCp1 = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%MemberCp2 = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%MemberCpMG1 = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%MemberCpMG2 = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%MemberAxCa1 = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%MemberAxCa2 = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%MemberAxCaMG1 = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%MemberAxCaMG2 = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%MemberAxCp1 = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%MemberAxCp2 = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%MemberAxCpMG1 = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%MemberAxCpMG2 = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE Morison_UnPackcoefmembers

 SUBROUTINE Morison_Copymgdepthstype( SrcmgdepthstypeData, DstmgdepthstypeData, CtrlCode, ErrStat, ErrMsg )
   TYPE(morison_mgdepthstype), INTENT(INOUT) :: SrcmgdepthstypeData
   TYPE(morison_mgdepthstype), INTENT(INOUT) :: DstmgdepthstypeData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
   DstmgdepthstypeData%MGDpth = SrcmgdepthstypeData%MGDpth
   DstmgdepthstypeData%MGThck = SrcmgdepthstypeData%MGThck
   DstmgdepthstypeData%MGDens = SrcmgdepthstypeData%MGDens
 END SUBROUTINE Morison_Copymgdepthstype

 SUBROUTINE Morison_Destroymgdepthstype( mgdepthstypeData, ErrStat, ErrMsg )
  TYPE(morison_mgdepthstype), INTENT(INOUT) :: mgdepthstypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
 END SUBROUTINE Morison_Destroymgdepthstype

 SUBROUTINE Morison_Packmgdepthstype( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(morison_mgdepthstype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Re_BufSz   = Re_BufSz   + 1  ! MGDpth
  Re_BufSz   = Re_BufSz   + 1  ! MGThck
  Re_BufSz   = Re_BufSz   + 1  ! MGDens
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%MGDpth )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%MGThck )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%MGDens )
  Re_Xferred   = Re_Xferred   + 1
 END SUBROUTINE Morison_Packmgdepthstype

 SUBROUTINE Morison_UnPackmgdepthstype( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(morison_mgdepthstype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  OutData%MGDpth = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%MGThck = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%MGDens = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE Morison_UnPackmgdepthstype

 SUBROUTINE Morison_Copymoutput( SrcmoutputData, DstmoutputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(morison_moutput), INTENT(INOUT) :: SrcmoutputData
   TYPE(morison_moutput), INTENT(INOUT) :: DstmoutputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
   DstmoutputData%MemberID = SrcmoutputData%MemberID
   DstmoutputData%NOutLoc = SrcmoutputData%NOutLoc
IF (ALLOCATED(SrcmoutputData%NodeLocs)) THEN
   i1_l = LBOUND(SrcmoutputData%NodeLocs,1)
   i1_u = UBOUND(SrcmoutputData%NodeLocs,1)
   IF (.NOT. ALLOCATED(DstmoutputData%NodeLocs)) THEN 
      ALLOCATE(DstmoutputData%NodeLocs(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstmoutputData%NodeLocs.', ErrStat, ErrMsg,'Morison_Copymoutput')
         RETURN
      END IF
   END IF
   DstmoutputData%NodeLocs = SrcmoutputData%NodeLocs
ENDIF
   DstmoutputData%MemberIDIndx = SrcmoutputData%MemberIDIndx
IF (ALLOCATED(SrcmoutputData%Marker1)) THEN
   i1_l = LBOUND(SrcmoutputData%Marker1,1)
   i1_u = UBOUND(SrcmoutputData%Marker1,1)
   IF (.NOT. ALLOCATED(DstmoutputData%Marker1)) THEN 
      ALLOCATE(DstmoutputData%Marker1(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstmoutputData%Marker1.', ErrStat, ErrMsg,'Morison_Copymoutput')
         RETURN
      END IF
   END IF
   DstmoutputData%Marker1 = SrcmoutputData%Marker1
ENDIF
IF (ALLOCATED(SrcmoutputData%Marker2)) THEN
   i1_l = LBOUND(SrcmoutputData%Marker2,1)
   i1_u = UBOUND(SrcmoutputData%Marker2,1)
   IF (.NOT. ALLOCATED(DstmoutputData%Marker2)) THEN 
      ALLOCATE(DstmoutputData%Marker2(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstmoutputData%Marker2.', ErrStat, ErrMsg,'Morison_Copymoutput')
         RETURN
      END IF
   END IF
   DstmoutputData%Marker2 = SrcmoutputData%Marker2
ENDIF
IF (ALLOCATED(SrcmoutputData%s)) THEN
   i1_l = LBOUND(SrcmoutputData%s,1)
   i1_u = UBOUND(SrcmoutputData%s,1)
   IF (.NOT. ALLOCATED(DstmoutputData%s)) THEN 
      ALLOCATE(DstmoutputData%s(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstmoutputData%s.', ErrStat, ErrMsg,'Morison_Copymoutput')
         RETURN
      END IF
   END IF
   DstmoutputData%s = SrcmoutputData%s
ENDIF
 END SUBROUTINE Morison_Copymoutput

 SUBROUTINE Morison_Destroymoutput( moutputData, ErrStat, ErrMsg )
  TYPE(morison_moutput), INTENT(INOUT) :: moutputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(moutputData%NodeLocs)) THEN
   DEALLOCATE(moutputData%NodeLocs)
ENDIF
IF (ALLOCATED(moutputData%Marker1)) THEN
   DEALLOCATE(moutputData%Marker1)
ENDIF
IF (ALLOCATED(moutputData%Marker2)) THEN
   DEALLOCATE(moutputData%Marker2)
ENDIF
IF (ALLOCATED(moutputData%s)) THEN
   DEALLOCATE(moutputData%s)
ENDIF
 END SUBROUTINE Morison_Destroymoutput

 SUBROUTINE Morison_Packmoutput( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(morison_moutput),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Int_BufSz  = Int_BufSz  + 1  ! MemberID
  Int_BufSz  = Int_BufSz  + 1  ! NOutLoc
  IF ( ALLOCATED(InData%NodeLocs) )   Re_BufSz    = Re_BufSz    + SIZE( InData%NodeLocs )  ! NodeLocs 
  Int_BufSz  = Int_BufSz  + 1  ! MemberIDIndx
  IF ( ALLOCATED(InData%Marker1) )   Int_BufSz   = Int_BufSz   + SIZE( InData%Marker1 )  ! Marker1 
  IF ( ALLOCATED(InData%Marker2) )   Int_BufSz   = Int_BufSz   + SIZE( InData%Marker2 )  ! Marker2 
  IF ( ALLOCATED(InData%s) )   Re_BufSz    = Re_BufSz    + SIZE( InData%s )  ! s 
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%MemberID )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NOutLoc )
  Int_Xferred   = Int_Xferred   + 1
  IF ( ALLOCATED(InData%NodeLocs) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%NodeLocs))-1 ) =  PACK(InData%NodeLocs ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%NodeLocs)
  ENDIF
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%MemberIDIndx )
  Int_Xferred   = Int_Xferred   + 1
  IF ( ALLOCATED(InData%Marker1) ) THEN
    IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%Marker1))-1 ) = PACK(InData%Marker1 ,.TRUE.)
    Int_Xferred   = Int_Xferred   + SIZE(InData%Marker1)
  ENDIF
  IF ( ALLOCATED(InData%Marker2) ) THEN
    IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%Marker2))-1 ) = PACK(InData%Marker2 ,.TRUE.)
    Int_Xferred   = Int_Xferred   + SIZE(InData%Marker2)
  ENDIF
  IF ( ALLOCATED(InData%s) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%s))-1 ) =  PACK(InData%s ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%s)
  ENDIF
 END SUBROUTINE Morison_Packmoutput

 SUBROUTINE Morison_UnPackmoutput( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(morison_moutput), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  OutData%MemberID = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%NOutLoc = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  IF ( ALLOCATED(OutData%NodeLocs) ) THEN
  ALLOCATE(mask1(SIZE(OutData%NodeLocs,1))); mask1 = .TRUE.
    OutData%NodeLocs = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%NodeLocs))-1 ),mask1,OutData%NodeLocs)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%NodeLocs)
  ENDIF
  OutData%MemberIDIndx = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  IF ( ALLOCATED(OutData%Marker1) ) THEN
  ALLOCATE(mask1(SIZE(OutData%Marker1,1))); mask1 = .TRUE.
    OutData%Marker1 = UNPACK(IntKiBuf( Int_Xferred:Re_Xferred+(SIZE(OutData%Marker1))-1 ),mask1,OutData%Marker1)
  DEALLOCATE(mask1)
    Int_Xferred   = Int_Xferred   + SIZE(OutData%Marker1)
  ENDIF
  IF ( ALLOCATED(OutData%Marker2) ) THEN
  ALLOCATE(mask1(SIZE(OutData%Marker2,1))); mask1 = .TRUE.
    OutData%Marker2 = UNPACK(IntKiBuf( Int_Xferred:Re_Xferred+(SIZE(OutData%Marker2))-1 ),mask1,OutData%Marker2)
  DEALLOCATE(mask1)
    Int_Xferred   = Int_Xferred   + SIZE(OutData%Marker2)
  ENDIF
  IF ( ALLOCATED(OutData%s) ) THEN
  ALLOCATE(mask1(SIZE(OutData%s,1))); mask1 = .TRUE.
    OutData%s = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%s))-1 ),mask1,OutData%s)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%s)
  ENDIF
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE Morison_UnPackmoutput

 SUBROUTINE Morison_Copyjoutput( SrcjoutputData, DstjoutputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(morison_joutput), INTENT(INOUT) :: SrcjoutputData
   TYPE(morison_joutput), INTENT(INOUT) :: DstjoutputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
   DstjoutputData%JointID = SrcjoutputData%JointID
   DstjoutputData%JointIDIndx = SrcjoutputData%JointIDIndx
   DstjoutputData%NumMarkers = SrcjoutputData%NumMarkers
   DstjoutputData%Markers = SrcjoutputData%Markers
 END SUBROUTINE Morison_Copyjoutput

 SUBROUTINE Morison_Destroyjoutput( joutputData, ErrStat, ErrMsg )
  TYPE(morison_joutput), INTENT(INOUT) :: joutputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
 END SUBROUTINE Morison_Destroyjoutput

 SUBROUTINE Morison_Packjoutput( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(morison_joutput),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Int_BufSz  = Int_BufSz  + 1  ! JointID
  Int_BufSz  = Int_BufSz  + 1  ! JointIDIndx
  Int_BufSz  = Int_BufSz  + 1  ! NumMarkers
  Int_BufSz   = Int_BufSz   + SIZE( InData%Markers )  ! Markers 
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%JointID )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%JointIDIndx )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NumMarkers )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%Markers))-1 ) = PACK(InData%Markers ,.TRUE.)
  Int_Xferred   = Int_Xferred   + SIZE(InData%Markers)
 END SUBROUTINE Morison_Packjoutput

 SUBROUTINE Morison_UnPackjoutput( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(morison_joutput), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  OutData%JointID = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%JointIDIndx = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%NumMarkers = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  ALLOCATE(mask1(SIZE(OutData%Markers,1))); mask1 = .TRUE.
  OutData%Markers = UNPACK(IntKiBuf( Int_Xferred:Re_Xferred+(SIZE(OutData%Markers))-1 ),mask1,OutData%Markers)
  DEALLOCATE(mask1)
  Int_Xferred   = Int_Xferred   + SIZE(OutData%Markers)
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE Morison_UnPackjoutput

 SUBROUTINE Morison_CopyInitInput( SrcInitInputData, DstInitInputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(Morison_initinputtype), INTENT(INOUT) :: SrcInitInputData
   TYPE(Morison_initinputtype), INTENT(INOUT) :: DstInitInputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
   DstInitInputData%Gravity = SrcInitInputData%Gravity
   DstInitInputData%WtrDens = SrcInitInputData%WtrDens
   DstInitInputData%WtrDpth = SrcInitInputData%WtrDpth
   DstInitInputData%MSL2SWL = SrcInitInputData%MSL2SWL
   DstInitInputData%NJoints = SrcInitInputData%NJoints
   DstInitInputData%NNodes = SrcInitInputData%NNodes
   DstInitInputData%TotalPossibleSuperMembers = SrcInitInputData%TotalPossibleSuperMembers
IF (ALLOCATED(SrcInitInputData%InpJoints)) THEN
   i1_l = LBOUND(SrcInitInputData%InpJoints,1)
   i1_u = UBOUND(SrcInitInputData%InpJoints,1)
   IF (.NOT. ALLOCATED(DstInitInputData%InpJoints)) THEN 
      ALLOCATE(DstInitInputData%InpJoints(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%InpJoints.', ErrStat, ErrMsg,'Morison_CopyInitInput')
         RETURN
      END IF
   END IF
   DO i1 = LBOUND(SrcInitInputData%InpJoints,1), UBOUND(SrcInitInputData%InpJoints,1)
      CALL Morison_Copyjointtype( SrcInitInputData%InpJoints(i1), DstInitInputData%InpJoints(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'Morison_CopyInitInput:InpJoints(i1)')
         IF (ErrStat>=AbortErrLev) RETURN
   ENDDO
ENDIF
IF (ALLOCATED(SrcInitInputData%Nodes)) THEN
   i1_l = LBOUND(SrcInitInputData%Nodes,1)
   i1_u = UBOUND(SrcInitInputData%Nodes,1)
   IF (.NOT. ALLOCATED(DstInitInputData%Nodes)) THEN 
      ALLOCATE(DstInitInputData%Nodes(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%Nodes.', ErrStat, ErrMsg,'Morison_CopyInitInput')
         RETURN
      END IF
   END IF
   DO i1 = LBOUND(SrcInitInputData%Nodes,1), UBOUND(SrcInitInputData%Nodes,1)
      CALL Morison_Copynodetype( SrcInitInputData%Nodes(i1), DstInitInputData%Nodes(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'Morison_CopyInitInput:Nodes(i1)')
         IF (ErrStat>=AbortErrLev) RETURN
   ENDDO
ENDIF
   DstInitInputData%NElements = SrcInitInputData%NElements
IF (ALLOCATED(SrcInitInputData%Elements)) THEN
   i1_l = LBOUND(SrcInitInputData%Elements,1)
   i1_u = UBOUND(SrcInitInputData%Elements,1)
   IF (.NOT. ALLOCATED(DstInitInputData%Elements)) THEN 
      ALLOCATE(DstInitInputData%Elements(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%Elements.', ErrStat, ErrMsg,'Morison_CopyInitInput')
         RETURN
      END IF
   END IF
   DO i1 = LBOUND(SrcInitInputData%Elements,1), UBOUND(SrcInitInputData%Elements,1)
      CALL Morison_Copymembertype( SrcInitInputData%Elements(i1), DstInitInputData%Elements(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'Morison_CopyInitInput:Elements(i1)')
         IF (ErrStat>=AbortErrLev) RETURN
   ENDDO
ENDIF
   DstInitInputData%NAxCoefs = SrcInitInputData%NAxCoefs
IF (ALLOCATED(SrcInitInputData%AxialCoefs)) THEN
   i1_l = LBOUND(SrcInitInputData%AxialCoefs,1)
   i1_u = UBOUND(SrcInitInputData%AxialCoefs,1)
   IF (.NOT. ALLOCATED(DstInitInputData%AxialCoefs)) THEN 
      ALLOCATE(DstInitInputData%AxialCoefs(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%AxialCoefs.', ErrStat, ErrMsg,'Morison_CopyInitInput')
         RETURN
      END IF
   END IF
   DO i1 = LBOUND(SrcInitInputData%AxialCoefs,1), UBOUND(SrcInitInputData%AxialCoefs,1)
      CALL Morison_Copyaxialcoeftype( SrcInitInputData%AxialCoefs(i1), DstInitInputData%AxialCoefs(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'Morison_CopyInitInput:AxialCoefs(i1)')
         IF (ErrStat>=AbortErrLev) RETURN
   ENDDO
ENDIF
   DstInitInputData%NPropSets = SrcInitInputData%NPropSets
IF (ALLOCATED(SrcInitInputData%MPropSets)) THEN
   i1_l = LBOUND(SrcInitInputData%MPropSets,1)
   i1_u = UBOUND(SrcInitInputData%MPropSets,1)
   IF (.NOT. ALLOCATED(DstInitInputData%MPropSets)) THEN 
      ALLOCATE(DstInitInputData%MPropSets(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%MPropSets.', ErrStat, ErrMsg,'Morison_CopyInitInput')
         RETURN
      END IF
   END IF
   DO i1 = LBOUND(SrcInitInputData%MPropSets,1), UBOUND(SrcInitInputData%MPropSets,1)
      CALL Morison_Copymemberproptype( SrcInitInputData%MPropSets(i1), DstInitInputData%MPropSets(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'Morison_CopyInitInput:MPropSets(i1)')
         IF (ErrStat>=AbortErrLev) RETURN
   ENDDO
ENDIF
   DstInitInputData%SimplCd = SrcInitInputData%SimplCd
   DstInitInputData%SimplCdMG = SrcInitInputData%SimplCdMG
   DstInitInputData%SimplCa = SrcInitInputData%SimplCa
   DstInitInputData%SimplCaMG = SrcInitInputData%SimplCaMG
   DstInitInputData%SimplCp = SrcInitInputData%SimplCp
   DstInitInputData%SimplCpMG = SrcInitInputData%SimplCpMG
   DstInitInputData%SimplAxCa = SrcInitInputData%SimplAxCa
   DstInitInputData%SimplAxCaMG = SrcInitInputData%SimplAxCaMG
   DstInitInputData%SimplAxCp = SrcInitInputData%SimplAxCp
   DstInitInputData%SimplAxCpMG = SrcInitInputData%SimplAxCpMG
   DstInitInputData%NCoefDpth = SrcInitInputData%NCoefDpth
IF (ALLOCATED(SrcInitInputData%CoefDpths)) THEN
   i1_l = LBOUND(SrcInitInputData%CoefDpths,1)
   i1_u = UBOUND(SrcInitInputData%CoefDpths,1)
   IF (.NOT. ALLOCATED(DstInitInputData%CoefDpths)) THEN 
      ALLOCATE(DstInitInputData%CoefDpths(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%CoefDpths.', ErrStat, ErrMsg,'Morison_CopyInitInput')
         RETURN
      END IF
   END IF
   DO i1 = LBOUND(SrcInitInputData%CoefDpths,1), UBOUND(SrcInitInputData%CoefDpths,1)
      CALL Morison_Copycoefdpths( SrcInitInputData%CoefDpths(i1), DstInitInputData%CoefDpths(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'Morison_CopyInitInput:CoefDpths(i1)')
         IF (ErrStat>=AbortErrLev) RETURN
   ENDDO
ENDIF
   DstInitInputData%NCoefMembers = SrcInitInputData%NCoefMembers
IF (ALLOCATED(SrcInitInputData%CoefMembers)) THEN
   i1_l = LBOUND(SrcInitInputData%CoefMembers,1)
   i1_u = UBOUND(SrcInitInputData%CoefMembers,1)
   IF (.NOT. ALLOCATED(DstInitInputData%CoefMembers)) THEN 
      ALLOCATE(DstInitInputData%CoefMembers(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%CoefMembers.', ErrStat, ErrMsg,'Morison_CopyInitInput')
         RETURN
      END IF
   END IF
   DO i1 = LBOUND(SrcInitInputData%CoefMembers,1), UBOUND(SrcInitInputData%CoefMembers,1)
      CALL Morison_Copycoefmembers( SrcInitInputData%CoefMembers(i1), DstInitInputData%CoefMembers(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'Morison_CopyInitInput:CoefMembers(i1)')
         IF (ErrStat>=AbortErrLev) RETURN
   ENDDO
ENDIF
   DstInitInputData%NMembers = SrcInitInputData%NMembers
IF (ALLOCATED(SrcInitInputData%InpMembers)) THEN
   i1_l = LBOUND(SrcInitInputData%InpMembers,1)
   i1_u = UBOUND(SrcInitInputData%InpMembers,1)
   IF (.NOT. ALLOCATED(DstInitInputData%InpMembers)) THEN 
      ALLOCATE(DstInitInputData%InpMembers(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%InpMembers.', ErrStat, ErrMsg,'Morison_CopyInitInput')
         RETURN
      END IF
   END IF
   DO i1 = LBOUND(SrcInitInputData%InpMembers,1), UBOUND(SrcInitInputData%InpMembers,1)
      CALL Morison_Copymemberinputtype( SrcInitInputData%InpMembers(i1), DstInitInputData%InpMembers(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'Morison_CopyInitInput:InpMembers(i1)')
         IF (ErrStat>=AbortErrLev) RETURN
   ENDDO
ENDIF
   DstInitInputData%NFillGroups = SrcInitInputData%NFillGroups
IF (ALLOCATED(SrcInitInputData%FilledGroups)) THEN
   i1_l = LBOUND(SrcInitInputData%FilledGroups,1)
   i1_u = UBOUND(SrcInitInputData%FilledGroups,1)
   IF (.NOT. ALLOCATED(DstInitInputData%FilledGroups)) THEN 
      ALLOCATE(DstInitInputData%FilledGroups(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%FilledGroups.', ErrStat, ErrMsg,'Morison_CopyInitInput')
         RETURN
      END IF
   END IF
   DO i1 = LBOUND(SrcInitInputData%FilledGroups,1), UBOUND(SrcInitInputData%FilledGroups,1)
      CALL Morison_Copyfilledgrouptype( SrcInitInputData%FilledGroups(i1), DstInitInputData%FilledGroups(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'Morison_CopyInitInput:FilledGroups(i1)')
         IF (ErrStat>=AbortErrLev) RETURN
   ENDDO
ENDIF
   DstInitInputData%NMGDepths = SrcInitInputData%NMGDepths
IF (ALLOCATED(SrcInitInputData%MGDepths)) THEN
   i1_l = LBOUND(SrcInitInputData%MGDepths,1)
   i1_u = UBOUND(SrcInitInputData%MGDepths,1)
   IF (.NOT. ALLOCATED(DstInitInputData%MGDepths)) THEN 
      ALLOCATE(DstInitInputData%MGDepths(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%MGDepths.', ErrStat, ErrMsg,'Morison_CopyInitInput')
         RETURN
      END IF
   END IF
   DO i1 = LBOUND(SrcInitInputData%MGDepths,1), UBOUND(SrcInitInputData%MGDepths,1)
      CALL Morison_Copymgdepthstype( SrcInitInputData%MGDepths(i1), DstInitInputData%MGDepths(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'Morison_CopyInitInput:MGDepths(i1)')
         IF (ErrStat>=AbortErrLev) RETURN
   ENDDO
ENDIF
   DstInitInputData%MGTop = SrcInitInputData%MGTop
   DstInitInputData%MGBottom = SrcInitInputData%MGBottom
   DstInitInputData%NMOutputs = SrcInitInputData%NMOutputs
IF (ALLOCATED(SrcInitInputData%MOutLst)) THEN
   i1_l = LBOUND(SrcInitInputData%MOutLst,1)
   i1_u = UBOUND(SrcInitInputData%MOutLst,1)
   IF (.NOT. ALLOCATED(DstInitInputData%MOutLst)) THEN 
      ALLOCATE(DstInitInputData%MOutLst(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%MOutLst.', ErrStat, ErrMsg,'Morison_CopyInitInput')
         RETURN
      END IF
   END IF
   DO i1 = LBOUND(SrcInitInputData%MOutLst,1), UBOUND(SrcInitInputData%MOutLst,1)
      CALL Morison_Copymoutput( SrcInitInputData%MOutLst(i1), DstInitInputData%MOutLst(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'Morison_CopyInitInput:MOutLst(i1)')
         IF (ErrStat>=AbortErrLev) RETURN
   ENDDO
ENDIF
   DstInitInputData%NJOutputs = SrcInitInputData%NJOutputs
IF (ALLOCATED(SrcInitInputData%JOutLst)) THEN
   i1_l = LBOUND(SrcInitInputData%JOutLst,1)
   i1_u = UBOUND(SrcInitInputData%JOutLst,1)
   IF (.NOT. ALLOCATED(DstInitInputData%JOutLst)) THEN 
      ALLOCATE(DstInitInputData%JOutLst(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%JOutLst.', ErrStat, ErrMsg,'Morison_CopyInitInput')
         RETURN
      END IF
   END IF
   DO i1 = LBOUND(SrcInitInputData%JOutLst,1), UBOUND(SrcInitInputData%JOutLst,1)
      CALL Morison_Copyjoutput( SrcInitInputData%JOutLst(i1), DstInitInputData%JOutLst(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'Morison_CopyInitInput:JOutLst(i1)')
         IF (ErrStat>=AbortErrLev) RETURN
   ENDDO
ENDIF
   DstInitInputData%OutList = SrcInitInputData%OutList
IF (ALLOCATED(SrcInitInputData%ValidOutList)) THEN
   i1_l = LBOUND(SrcInitInputData%ValidOutList,1)
   i1_u = UBOUND(SrcInitInputData%ValidOutList,1)
   IF (.NOT. ALLOCATED(DstInitInputData%ValidOutList)) THEN 
      ALLOCATE(DstInitInputData%ValidOutList(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%ValidOutList.', ErrStat, ErrMsg,'Morison_CopyInitInput')
         RETURN
      END IF
   END IF
   DstInitInputData%ValidOutList = SrcInitInputData%ValidOutList
ENDIF
   DstInitInputData%NumOuts = SrcInitInputData%NumOuts
   DstInitInputData%OutSwtch = SrcInitInputData%OutSwtch
   DstInitInputData%OutAll = SrcInitInputData%OutAll
   DstInitInputData%OutRootName = SrcInitInputData%OutRootName
   DstInitInputData%UnOutFile = SrcInitInputData%UnOutFile
   DstInitInputData%UnSum = SrcInitInputData%UnSum
   DstInitInputData%NStepWave = SrcInitInputData%NStepWave
IF (ALLOCATED(SrcInitInputData%WaveAcc0)) THEN
   i1_l = LBOUND(SrcInitInputData%WaveAcc0,1)
   i1_u = UBOUND(SrcInitInputData%WaveAcc0,1)
   i2_l = LBOUND(SrcInitInputData%WaveAcc0,2)
   i2_u = UBOUND(SrcInitInputData%WaveAcc0,2)
   i3_l = LBOUND(SrcInitInputData%WaveAcc0,3)
   i3_u = UBOUND(SrcInitInputData%WaveAcc0,3)
   IF (.NOT. ALLOCATED(DstInitInputData%WaveAcc0)) THEN 
      ALLOCATE(DstInitInputData%WaveAcc0(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%WaveAcc0.', ErrStat, ErrMsg,'Morison_CopyInitInput')
         RETURN
      END IF
   END IF
   DstInitInputData%WaveAcc0 = SrcInitInputData%WaveAcc0
ENDIF
IF (ALLOCATED(SrcInitInputData%WaveTime)) THEN
   i1_l = LBOUND(SrcInitInputData%WaveTime,1)
   i1_u = UBOUND(SrcInitInputData%WaveTime,1)
   IF (.NOT. ALLOCATED(DstInitInputData%WaveTime)) THEN 
      ALLOCATE(DstInitInputData%WaveTime(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%WaveTime.', ErrStat, ErrMsg,'Morison_CopyInitInput')
         RETURN
      END IF
   END IF
   DstInitInputData%WaveTime = SrcInitInputData%WaveTime
ENDIF
IF (ALLOCATED(SrcInitInputData%WaveDynP0)) THEN
   i1_l = LBOUND(SrcInitInputData%WaveDynP0,1)
   i1_u = UBOUND(SrcInitInputData%WaveDynP0,1)
   i2_l = LBOUND(SrcInitInputData%WaveDynP0,2)
   i2_u = UBOUND(SrcInitInputData%WaveDynP0,2)
   IF (.NOT. ALLOCATED(DstInitInputData%WaveDynP0)) THEN 
      ALLOCATE(DstInitInputData%WaveDynP0(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%WaveDynP0.', ErrStat, ErrMsg,'Morison_CopyInitInput')
         RETURN
      END IF
   END IF
   DstInitInputData%WaveDynP0 = SrcInitInputData%WaveDynP0
ENDIF
IF (ALLOCATED(SrcInitInputData%WaveVel0)) THEN
   i1_l = LBOUND(SrcInitInputData%WaveVel0,1)
   i1_u = UBOUND(SrcInitInputData%WaveVel0,1)
   i2_l = LBOUND(SrcInitInputData%WaveVel0,2)
   i2_u = UBOUND(SrcInitInputData%WaveVel0,2)
   i3_l = LBOUND(SrcInitInputData%WaveVel0,3)
   i3_u = UBOUND(SrcInitInputData%WaveVel0,3)
   IF (.NOT. ALLOCATED(DstInitInputData%WaveVel0)) THEN 
      ALLOCATE(DstInitInputData%WaveVel0(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%WaveVel0.', ErrStat, ErrMsg,'Morison_CopyInitInput')
         RETURN
      END IF
   END IF
   DstInitInputData%WaveVel0 = SrcInitInputData%WaveVel0
ENDIF
 END SUBROUTINE Morison_CopyInitInput

 SUBROUTINE Morison_DestroyInitInput( InitInputData, ErrStat, ErrMsg )
  TYPE(Morison_initinputtype), INTENT(INOUT) :: InitInputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(InitInputData%InpJoints)) THEN
DO i1 = LBOUND(InitInputData%InpJoints,1), UBOUND(InitInputData%InpJoints,1)
  CALL Morison_Destroyjointtype( InitInputData%InpJoints(i1), ErrStat, ErrMsg )
ENDDO
   DEALLOCATE(InitInputData%InpJoints)
ENDIF
IF (ALLOCATED(InitInputData%Nodes)) THEN
DO i1 = LBOUND(InitInputData%Nodes,1), UBOUND(InitInputData%Nodes,1)
  CALL Morison_Destroynodetype( InitInputData%Nodes(i1), ErrStat, ErrMsg )
ENDDO
   DEALLOCATE(InitInputData%Nodes)
ENDIF
IF (ALLOCATED(InitInputData%Elements)) THEN
DO i1 = LBOUND(InitInputData%Elements,1), UBOUND(InitInputData%Elements,1)
  CALL Morison_Destroymembertype( InitInputData%Elements(i1), ErrStat, ErrMsg )
ENDDO
   DEALLOCATE(InitInputData%Elements)
ENDIF
IF (ALLOCATED(InitInputData%AxialCoefs)) THEN
DO i1 = LBOUND(InitInputData%AxialCoefs,1), UBOUND(InitInputData%AxialCoefs,1)
  CALL Morison_Destroyaxialcoeftype( InitInputData%AxialCoefs(i1), ErrStat, ErrMsg )
ENDDO
   DEALLOCATE(InitInputData%AxialCoefs)
ENDIF
IF (ALLOCATED(InitInputData%MPropSets)) THEN
DO i1 = LBOUND(InitInputData%MPropSets,1), UBOUND(InitInputData%MPropSets,1)
  CALL Morison_Destroymemberproptype( InitInputData%MPropSets(i1), ErrStat, ErrMsg )
ENDDO
   DEALLOCATE(InitInputData%MPropSets)
ENDIF
IF (ALLOCATED(InitInputData%CoefDpths)) THEN
DO i1 = LBOUND(InitInputData%CoefDpths,1), UBOUND(InitInputData%CoefDpths,1)
  CALL Morison_Destroycoefdpths( InitInputData%CoefDpths(i1), ErrStat, ErrMsg )
ENDDO
   DEALLOCATE(InitInputData%CoefDpths)
ENDIF
IF (ALLOCATED(InitInputData%CoefMembers)) THEN
DO i1 = LBOUND(InitInputData%CoefMembers,1), UBOUND(InitInputData%CoefMembers,1)
  CALL Morison_Destroycoefmembers( InitInputData%CoefMembers(i1), ErrStat, ErrMsg )
ENDDO
   DEALLOCATE(InitInputData%CoefMembers)
ENDIF
IF (ALLOCATED(InitInputData%InpMembers)) THEN
DO i1 = LBOUND(InitInputData%InpMembers,1), UBOUND(InitInputData%InpMembers,1)
  CALL Morison_Destroymemberinputtype( InitInputData%InpMembers(i1), ErrStat, ErrMsg )
ENDDO
   DEALLOCATE(InitInputData%InpMembers)
ENDIF
IF (ALLOCATED(InitInputData%FilledGroups)) THEN
DO i1 = LBOUND(InitInputData%FilledGroups,1), UBOUND(InitInputData%FilledGroups,1)
  CALL Morison_Destroyfilledgrouptype( InitInputData%FilledGroups(i1), ErrStat, ErrMsg )
ENDDO
   DEALLOCATE(InitInputData%FilledGroups)
ENDIF
IF (ALLOCATED(InitInputData%MGDepths)) THEN
DO i1 = LBOUND(InitInputData%MGDepths,1), UBOUND(InitInputData%MGDepths,1)
  CALL Morison_Destroymgdepthstype( InitInputData%MGDepths(i1), ErrStat, ErrMsg )
ENDDO
   DEALLOCATE(InitInputData%MGDepths)
ENDIF
IF (ALLOCATED(InitInputData%MOutLst)) THEN
DO i1 = LBOUND(InitInputData%MOutLst,1), UBOUND(InitInputData%MOutLst,1)
  CALL Morison_Destroymoutput( InitInputData%MOutLst(i1), ErrStat, ErrMsg )
ENDDO
   DEALLOCATE(InitInputData%MOutLst)
ENDIF
IF (ALLOCATED(InitInputData%JOutLst)) THEN
DO i1 = LBOUND(InitInputData%JOutLst,1), UBOUND(InitInputData%JOutLst,1)
  CALL Morison_Destroyjoutput( InitInputData%JOutLst(i1), ErrStat, ErrMsg )
ENDDO
   DEALLOCATE(InitInputData%JOutLst)
ENDIF
IF (ALLOCATED(InitInputData%ValidOutList)) THEN
   DEALLOCATE(InitInputData%ValidOutList)
ENDIF
IF (ALLOCATED(InitInputData%WaveAcc0)) THEN
   DEALLOCATE(InitInputData%WaveAcc0)
ENDIF
IF (ALLOCATED(InitInputData%WaveTime)) THEN
   DEALLOCATE(InitInputData%WaveTime)
ENDIF
IF (ALLOCATED(InitInputData%WaveDynP0)) THEN
   DEALLOCATE(InitInputData%WaveDynP0)
ENDIF
IF (ALLOCATED(InitInputData%WaveVel0)) THEN
   DEALLOCATE(InitInputData%WaveVel0)
ENDIF
 END SUBROUTINE Morison_DestroyInitInput

 SUBROUTINE Morison_PackInitInput( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(Morison_initinputtype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_InpJoints_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_InpJoints_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_InpJoints_Buf(:)
  REAL(ReKi),     ALLOCATABLE :: Re_Nodes_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_Nodes_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_Nodes_Buf(:)
  REAL(ReKi),     ALLOCATABLE :: Re_Elements_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_Elements_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_Elements_Buf(:)
  REAL(ReKi),     ALLOCATABLE :: Re_AxialCoefs_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_AxialCoefs_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_AxialCoefs_Buf(:)
  REAL(ReKi),     ALLOCATABLE :: Re_MPropSets_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_MPropSets_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_MPropSets_Buf(:)
  REAL(ReKi),     ALLOCATABLE :: Re_CoefDpths_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_CoefDpths_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_CoefDpths_Buf(:)
  REAL(ReKi),     ALLOCATABLE :: Re_CoefMembers_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_CoefMembers_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_CoefMembers_Buf(:)
  REAL(ReKi),     ALLOCATABLE :: Re_InpMembers_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_InpMembers_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_InpMembers_Buf(:)
  REAL(ReKi),     ALLOCATABLE :: Re_FilledGroups_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_FilledGroups_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_FilledGroups_Buf(:)
  REAL(ReKi),     ALLOCATABLE :: Re_MGDepths_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_MGDepths_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_MGDepths_Buf(:)
  REAL(ReKi),     ALLOCATABLE :: Re_MOutLst_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_MOutLst_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_MOutLst_Buf(:)
  REAL(ReKi),     ALLOCATABLE :: Re_JOutLst_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_JOutLst_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_JOutLst_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Re_BufSz   = Re_BufSz   + 1  ! Gravity
  Re_BufSz   = Re_BufSz   + 1  ! WtrDens
  Re_BufSz   = Re_BufSz   + 1  ! WtrDpth
  Re_BufSz   = Re_BufSz   + 1  ! MSL2SWL
  Int_BufSz  = Int_BufSz  + 1  ! NJoints
  Int_BufSz  = Int_BufSz  + 1  ! NNodes
  Int_BufSz  = Int_BufSz  + 1  ! TotalPossibleSuperMembers
DO i1 = LBOUND(InData%InpJoints,1), UBOUND(InData%InpJoints,1)
  CALL Morison_Packjointtype( Re_InpJoints_Buf, Db_InpJoints_Buf, Int_InpJoints_Buf, InData%InpJoints(i1), ErrStat, ErrMsg, .TRUE. ) ! InpJoints 
  IF(ALLOCATED(Re_InpJoints_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_InpJoints_Buf  ) ! InpJoints
  IF(ALLOCATED(Db_InpJoints_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_InpJoints_Buf  ) ! InpJoints
  IF(ALLOCATED(Int_InpJoints_Buf))Int_BufSz = Int_BufSz + SIZE( Int_InpJoints_Buf ) ! InpJoints
  IF(ALLOCATED(Re_InpJoints_Buf))  DEALLOCATE(Re_InpJoints_Buf)
  IF(ALLOCATED(Db_InpJoints_Buf))  DEALLOCATE(Db_InpJoints_Buf)
  IF(ALLOCATED(Int_InpJoints_Buf)) DEALLOCATE(Int_InpJoints_Buf)
ENDDO
DO i1 = LBOUND(InData%Nodes,1), UBOUND(InData%Nodes,1)
  CALL Morison_Packnodetype( Re_Nodes_Buf, Db_Nodes_Buf, Int_Nodes_Buf, InData%Nodes(i1), ErrStat, ErrMsg, .TRUE. ) ! Nodes 
  IF(ALLOCATED(Re_Nodes_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_Nodes_Buf  ) ! Nodes
  IF(ALLOCATED(Db_Nodes_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_Nodes_Buf  ) ! Nodes
  IF(ALLOCATED(Int_Nodes_Buf))Int_BufSz = Int_BufSz + SIZE( Int_Nodes_Buf ) ! Nodes
  IF(ALLOCATED(Re_Nodes_Buf))  DEALLOCATE(Re_Nodes_Buf)
  IF(ALLOCATED(Db_Nodes_Buf))  DEALLOCATE(Db_Nodes_Buf)
  IF(ALLOCATED(Int_Nodes_Buf)) DEALLOCATE(Int_Nodes_Buf)
ENDDO
  Int_BufSz  = Int_BufSz  + 1  ! NElements
DO i1 = LBOUND(InData%Elements,1), UBOUND(InData%Elements,1)
  CALL Morison_Packmembertype( Re_Elements_Buf, Db_Elements_Buf, Int_Elements_Buf, InData%Elements(i1), ErrStat, ErrMsg, .TRUE. ) ! Elements 
  IF(ALLOCATED(Re_Elements_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_Elements_Buf  ) ! Elements
  IF(ALLOCATED(Db_Elements_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_Elements_Buf  ) ! Elements
  IF(ALLOCATED(Int_Elements_Buf))Int_BufSz = Int_BufSz + SIZE( Int_Elements_Buf ) ! Elements
  IF(ALLOCATED(Re_Elements_Buf))  DEALLOCATE(Re_Elements_Buf)
  IF(ALLOCATED(Db_Elements_Buf))  DEALLOCATE(Db_Elements_Buf)
  IF(ALLOCATED(Int_Elements_Buf)) DEALLOCATE(Int_Elements_Buf)
ENDDO
  Int_BufSz  = Int_BufSz  + 1  ! NAxCoefs
DO i1 = LBOUND(InData%AxialCoefs,1), UBOUND(InData%AxialCoefs,1)
  CALL Morison_Packaxialcoeftype( Re_AxialCoefs_Buf, Db_AxialCoefs_Buf, Int_AxialCoefs_Buf, InData%AxialCoefs(i1), ErrStat, ErrMsg, .TRUE. ) ! AxialCoefs 
  IF(ALLOCATED(Re_AxialCoefs_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_AxialCoefs_Buf  ) ! AxialCoefs
  IF(ALLOCATED(Db_AxialCoefs_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_AxialCoefs_Buf  ) ! AxialCoefs
  IF(ALLOCATED(Int_AxialCoefs_Buf))Int_BufSz = Int_BufSz + SIZE( Int_AxialCoefs_Buf ) ! AxialCoefs
  IF(ALLOCATED(Re_AxialCoefs_Buf))  DEALLOCATE(Re_AxialCoefs_Buf)
  IF(ALLOCATED(Db_AxialCoefs_Buf))  DEALLOCATE(Db_AxialCoefs_Buf)
  IF(ALLOCATED(Int_AxialCoefs_Buf)) DEALLOCATE(Int_AxialCoefs_Buf)
ENDDO
  Int_BufSz  = Int_BufSz  + 1  ! NPropSets
DO i1 = LBOUND(InData%MPropSets,1), UBOUND(InData%MPropSets,1)
  CALL Morison_Packmemberproptype( Re_MPropSets_Buf, Db_MPropSets_Buf, Int_MPropSets_Buf, InData%MPropSets(i1), ErrStat, ErrMsg, .TRUE. ) ! MPropSets 
  IF(ALLOCATED(Re_MPropSets_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_MPropSets_Buf  ) ! MPropSets
  IF(ALLOCATED(Db_MPropSets_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_MPropSets_Buf  ) ! MPropSets
  IF(ALLOCATED(Int_MPropSets_Buf))Int_BufSz = Int_BufSz + SIZE( Int_MPropSets_Buf ) ! MPropSets
  IF(ALLOCATED(Re_MPropSets_Buf))  DEALLOCATE(Re_MPropSets_Buf)
  IF(ALLOCATED(Db_MPropSets_Buf))  DEALLOCATE(Db_MPropSets_Buf)
  IF(ALLOCATED(Int_MPropSets_Buf)) DEALLOCATE(Int_MPropSets_Buf)
ENDDO
  Re_BufSz   = Re_BufSz   + 1  ! SimplCd
  Re_BufSz   = Re_BufSz   + 1  ! SimplCdMG
  Re_BufSz   = Re_BufSz   + 1  ! SimplCa
  Re_BufSz   = Re_BufSz   + 1  ! SimplCaMG
  Re_BufSz   = Re_BufSz   + 1  ! SimplCp
  Re_BufSz   = Re_BufSz   + 1  ! SimplCpMG
  Re_BufSz   = Re_BufSz   + 1  ! SimplAxCa
  Re_BufSz   = Re_BufSz   + 1  ! SimplAxCaMG
  Re_BufSz   = Re_BufSz   + 1  ! SimplAxCp
  Re_BufSz   = Re_BufSz   + 1  ! SimplAxCpMG
  Int_BufSz  = Int_BufSz  + 1  ! NCoefDpth
DO i1 = LBOUND(InData%CoefDpths,1), UBOUND(InData%CoefDpths,1)
  CALL Morison_Packcoefdpths( Re_CoefDpths_Buf, Db_CoefDpths_Buf, Int_CoefDpths_Buf, InData%CoefDpths(i1), ErrStat, ErrMsg, .TRUE. ) ! CoefDpths 
  IF(ALLOCATED(Re_CoefDpths_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_CoefDpths_Buf  ) ! CoefDpths
  IF(ALLOCATED(Db_CoefDpths_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_CoefDpths_Buf  ) ! CoefDpths
  IF(ALLOCATED(Int_CoefDpths_Buf))Int_BufSz = Int_BufSz + SIZE( Int_CoefDpths_Buf ) ! CoefDpths
  IF(ALLOCATED(Re_CoefDpths_Buf))  DEALLOCATE(Re_CoefDpths_Buf)
  IF(ALLOCATED(Db_CoefDpths_Buf))  DEALLOCATE(Db_CoefDpths_Buf)
  IF(ALLOCATED(Int_CoefDpths_Buf)) DEALLOCATE(Int_CoefDpths_Buf)
ENDDO
  Int_BufSz  = Int_BufSz  + 1  ! NCoefMembers
DO i1 = LBOUND(InData%CoefMembers,1), UBOUND(InData%CoefMembers,1)
  CALL Morison_Packcoefmembers( Re_CoefMembers_Buf, Db_CoefMembers_Buf, Int_CoefMembers_Buf, InData%CoefMembers(i1), ErrStat, ErrMsg, .TRUE. ) ! CoefMembers 
  IF(ALLOCATED(Re_CoefMembers_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_CoefMembers_Buf  ) ! CoefMembers
  IF(ALLOCATED(Db_CoefMembers_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_CoefMembers_Buf  ) ! CoefMembers
  IF(ALLOCATED(Int_CoefMembers_Buf))Int_BufSz = Int_BufSz + SIZE( Int_CoefMembers_Buf ) ! CoefMembers
  IF(ALLOCATED(Re_CoefMembers_Buf))  DEALLOCATE(Re_CoefMembers_Buf)
  IF(ALLOCATED(Db_CoefMembers_Buf))  DEALLOCATE(Db_CoefMembers_Buf)
  IF(ALLOCATED(Int_CoefMembers_Buf)) DEALLOCATE(Int_CoefMembers_Buf)
ENDDO
  Int_BufSz  = Int_BufSz  + 1  ! NMembers
DO i1 = LBOUND(InData%InpMembers,1), UBOUND(InData%InpMembers,1)
  CALL Morison_Packmemberinputtype( Re_InpMembers_Buf, Db_InpMembers_Buf, Int_InpMembers_Buf, InData%InpMembers(i1), ErrStat, ErrMsg, .TRUE. ) ! InpMembers 
  IF(ALLOCATED(Re_InpMembers_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_InpMembers_Buf  ) ! InpMembers
  IF(ALLOCATED(Db_InpMembers_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_InpMembers_Buf  ) ! InpMembers
  IF(ALLOCATED(Int_InpMembers_Buf))Int_BufSz = Int_BufSz + SIZE( Int_InpMembers_Buf ) ! InpMembers
  IF(ALLOCATED(Re_InpMembers_Buf))  DEALLOCATE(Re_InpMembers_Buf)
  IF(ALLOCATED(Db_InpMembers_Buf))  DEALLOCATE(Db_InpMembers_Buf)
  IF(ALLOCATED(Int_InpMembers_Buf)) DEALLOCATE(Int_InpMembers_Buf)
ENDDO
  Int_BufSz  = Int_BufSz  + 1  ! NFillGroups
DO i1 = LBOUND(InData%FilledGroups,1), UBOUND(InData%FilledGroups,1)
  CALL Morison_Packfilledgrouptype( Re_FilledGroups_Buf, Db_FilledGroups_Buf, Int_FilledGroups_Buf, InData%FilledGroups(i1), ErrStat, ErrMsg, .TRUE. ) ! FilledGroups 
  IF(ALLOCATED(Re_FilledGroups_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_FilledGroups_Buf  ) ! FilledGroups
  IF(ALLOCATED(Db_FilledGroups_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_FilledGroups_Buf  ) ! FilledGroups
  IF(ALLOCATED(Int_FilledGroups_Buf))Int_BufSz = Int_BufSz + SIZE( Int_FilledGroups_Buf ) ! FilledGroups
  IF(ALLOCATED(Re_FilledGroups_Buf))  DEALLOCATE(Re_FilledGroups_Buf)
  IF(ALLOCATED(Db_FilledGroups_Buf))  DEALLOCATE(Db_FilledGroups_Buf)
  IF(ALLOCATED(Int_FilledGroups_Buf)) DEALLOCATE(Int_FilledGroups_Buf)
ENDDO
  Int_BufSz  = Int_BufSz  + 1  ! NMGDepths
DO i1 = LBOUND(InData%MGDepths,1), UBOUND(InData%MGDepths,1)
  CALL Morison_Packmgdepthstype( Re_MGDepths_Buf, Db_MGDepths_Buf, Int_MGDepths_Buf, InData%MGDepths(i1), ErrStat, ErrMsg, .TRUE. ) ! MGDepths 
  IF(ALLOCATED(Re_MGDepths_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_MGDepths_Buf  ) ! MGDepths
  IF(ALLOCATED(Db_MGDepths_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_MGDepths_Buf  ) ! MGDepths
  IF(ALLOCATED(Int_MGDepths_Buf))Int_BufSz = Int_BufSz + SIZE( Int_MGDepths_Buf ) ! MGDepths
  IF(ALLOCATED(Re_MGDepths_Buf))  DEALLOCATE(Re_MGDepths_Buf)
  IF(ALLOCATED(Db_MGDepths_Buf))  DEALLOCATE(Db_MGDepths_Buf)
  IF(ALLOCATED(Int_MGDepths_Buf)) DEALLOCATE(Int_MGDepths_Buf)
ENDDO
  Re_BufSz   = Re_BufSz   + 1  ! MGTop
  Re_BufSz   = Re_BufSz   + 1  ! MGBottom
  Int_BufSz  = Int_BufSz  + 1  ! NMOutputs
DO i1 = LBOUND(InData%MOutLst,1), UBOUND(InData%MOutLst,1)
  CALL Morison_Packmoutput( Re_MOutLst_Buf, Db_MOutLst_Buf, Int_MOutLst_Buf, InData%MOutLst(i1), ErrStat, ErrMsg, .TRUE. ) ! MOutLst 
  IF(ALLOCATED(Re_MOutLst_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_MOutLst_Buf  ) ! MOutLst
  IF(ALLOCATED(Db_MOutLst_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_MOutLst_Buf  ) ! MOutLst
  IF(ALLOCATED(Int_MOutLst_Buf))Int_BufSz = Int_BufSz + SIZE( Int_MOutLst_Buf ) ! MOutLst
  IF(ALLOCATED(Re_MOutLst_Buf))  DEALLOCATE(Re_MOutLst_Buf)
  IF(ALLOCATED(Db_MOutLst_Buf))  DEALLOCATE(Db_MOutLst_Buf)
  IF(ALLOCATED(Int_MOutLst_Buf)) DEALLOCATE(Int_MOutLst_Buf)
ENDDO
  Int_BufSz  = Int_BufSz  + 1  ! NJOutputs
DO i1 = LBOUND(InData%JOutLst,1), UBOUND(InData%JOutLst,1)
  CALL Morison_Packjoutput( Re_JOutLst_Buf, Db_JOutLst_Buf, Int_JOutLst_Buf, InData%JOutLst(i1), ErrStat, ErrMsg, .TRUE. ) ! JOutLst 
  IF(ALLOCATED(Re_JOutLst_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_JOutLst_Buf  ) ! JOutLst
  IF(ALLOCATED(Db_JOutLst_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_JOutLst_Buf  ) ! JOutLst
  IF(ALLOCATED(Int_JOutLst_Buf))Int_BufSz = Int_BufSz + SIZE( Int_JOutLst_Buf ) ! JOutLst
  IF(ALLOCATED(Re_JOutLst_Buf))  DEALLOCATE(Re_JOutLst_Buf)
  IF(ALLOCATED(Db_JOutLst_Buf))  DEALLOCATE(Db_JOutLst_Buf)
  IF(ALLOCATED(Int_JOutLst_Buf)) DEALLOCATE(Int_JOutLst_Buf)
ENDDO
!  missing buffer for OutList
  IF ( ALLOCATED(InData%ValidOutList) )   Int_BufSz   = Int_BufSz   + SIZE( InData%ValidOutList )  ! ValidOutList 
  Int_BufSz  = Int_BufSz  + 1  ! NumOuts
  Int_BufSz  = Int_BufSz  + 1  ! OutSwtch
  Int_BufSz  = Int_BufSz  + 1  ! OutAll
!  missing buffer for OutRootName
  Int_BufSz  = Int_BufSz  + 1  ! UnOutFile
  Int_BufSz  = Int_BufSz  + 1  ! UnSum
  Int_BufSz  = Int_BufSz  + 1  ! NStepWave
  IF ( ALLOCATED(InData%WaveAcc0) )   Re_BufSz    = Re_BufSz    + SIZE( InData%WaveAcc0 )  ! WaveAcc0 
  IF ( ALLOCATED(InData%WaveTime) )   Re_BufSz    = Re_BufSz    + SIZE( InData%WaveTime )  ! WaveTime 
  IF ( ALLOCATED(InData%WaveDynP0) )   Re_BufSz    = Re_BufSz    + SIZE( InData%WaveDynP0 )  ! WaveDynP0 
  IF ( ALLOCATED(InData%WaveVel0) )   Re_BufSz    = Re_BufSz    + SIZE( InData%WaveVel0 )  ! WaveVel0 
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%Gravity )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%WtrDens )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%WtrDpth )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%MSL2SWL )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NJoints )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NNodes )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%TotalPossibleSuperMembers )
  Int_Xferred   = Int_Xferred   + 1
DO i1 = LBOUND(InData%InpJoints,1), UBOUND(InData%InpJoints,1)
  CALL Morison_Packjointtype( Re_InpJoints_Buf, Db_InpJoints_Buf, Int_InpJoints_Buf, InData%InpJoints(i1), ErrStat, ErrMsg, OnlySize ) ! InpJoints 
  IF(ALLOCATED(Re_InpJoints_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_InpJoints_Buf)-1 ) = Re_InpJoints_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_InpJoints_Buf)
  ENDIF
  IF(ALLOCATED(Db_InpJoints_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_InpJoints_Buf)-1 ) = Db_InpJoints_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_InpJoints_Buf)
  ENDIF
  IF(ALLOCATED(Int_InpJoints_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_InpJoints_Buf)-1 ) = Int_InpJoints_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_InpJoints_Buf)
  ENDIF
  IF( ALLOCATED(Re_InpJoints_Buf) )  DEALLOCATE(Re_InpJoints_Buf)
  IF( ALLOCATED(Db_InpJoints_Buf) )  DEALLOCATE(Db_InpJoints_Buf)
  IF( ALLOCATED(Int_InpJoints_Buf) ) DEALLOCATE(Int_InpJoints_Buf)
ENDDO
DO i1 = LBOUND(InData%Nodes,1), UBOUND(InData%Nodes,1)
  CALL Morison_Packnodetype( Re_Nodes_Buf, Db_Nodes_Buf, Int_Nodes_Buf, InData%Nodes(i1), ErrStat, ErrMsg, OnlySize ) ! Nodes 
  IF(ALLOCATED(Re_Nodes_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Nodes_Buf)-1 ) = Re_Nodes_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_Nodes_Buf)
  ENDIF
  IF(ALLOCATED(Db_Nodes_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Nodes_Buf)-1 ) = Db_Nodes_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_Nodes_Buf)
  ENDIF
  IF(ALLOCATED(Int_Nodes_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Nodes_Buf)-1 ) = Int_Nodes_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_Nodes_Buf)
  ENDIF
  IF( ALLOCATED(Re_Nodes_Buf) )  DEALLOCATE(Re_Nodes_Buf)
  IF( ALLOCATED(Db_Nodes_Buf) )  DEALLOCATE(Db_Nodes_Buf)
  IF( ALLOCATED(Int_Nodes_Buf) ) DEALLOCATE(Int_Nodes_Buf)
ENDDO
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NElements )
  Int_Xferred   = Int_Xferred   + 1
DO i1 = LBOUND(InData%Elements,1), UBOUND(InData%Elements,1)
  CALL Morison_Packmembertype( Re_Elements_Buf, Db_Elements_Buf, Int_Elements_Buf, InData%Elements(i1), ErrStat, ErrMsg, OnlySize ) ! Elements 
  IF(ALLOCATED(Re_Elements_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Elements_Buf)-1 ) = Re_Elements_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_Elements_Buf)
  ENDIF
  IF(ALLOCATED(Db_Elements_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Elements_Buf)-1 ) = Db_Elements_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_Elements_Buf)
  ENDIF
  IF(ALLOCATED(Int_Elements_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Elements_Buf)-1 ) = Int_Elements_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_Elements_Buf)
  ENDIF
  IF( ALLOCATED(Re_Elements_Buf) )  DEALLOCATE(Re_Elements_Buf)
  IF( ALLOCATED(Db_Elements_Buf) )  DEALLOCATE(Db_Elements_Buf)
  IF( ALLOCATED(Int_Elements_Buf) ) DEALLOCATE(Int_Elements_Buf)
ENDDO
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NAxCoefs )
  Int_Xferred   = Int_Xferred   + 1
DO i1 = LBOUND(InData%AxialCoefs,1), UBOUND(InData%AxialCoefs,1)
  CALL Morison_Packaxialcoeftype( Re_AxialCoefs_Buf, Db_AxialCoefs_Buf, Int_AxialCoefs_Buf, InData%AxialCoefs(i1), ErrStat, ErrMsg, OnlySize ) ! AxialCoefs 
  IF(ALLOCATED(Re_AxialCoefs_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_AxialCoefs_Buf)-1 ) = Re_AxialCoefs_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_AxialCoefs_Buf)
  ENDIF
  IF(ALLOCATED(Db_AxialCoefs_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_AxialCoefs_Buf)-1 ) = Db_AxialCoefs_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_AxialCoefs_Buf)
  ENDIF
  IF(ALLOCATED(Int_AxialCoefs_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_AxialCoefs_Buf)-1 ) = Int_AxialCoefs_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_AxialCoefs_Buf)
  ENDIF
  IF( ALLOCATED(Re_AxialCoefs_Buf) )  DEALLOCATE(Re_AxialCoefs_Buf)
  IF( ALLOCATED(Db_AxialCoefs_Buf) )  DEALLOCATE(Db_AxialCoefs_Buf)
  IF( ALLOCATED(Int_AxialCoefs_Buf) ) DEALLOCATE(Int_AxialCoefs_Buf)
ENDDO
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NPropSets )
  Int_Xferred   = Int_Xferred   + 1
DO i1 = LBOUND(InData%MPropSets,1), UBOUND(InData%MPropSets,1)
  CALL Morison_Packmemberproptype( Re_MPropSets_Buf, Db_MPropSets_Buf, Int_MPropSets_Buf, InData%MPropSets(i1), ErrStat, ErrMsg, OnlySize ) ! MPropSets 
  IF(ALLOCATED(Re_MPropSets_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_MPropSets_Buf)-1 ) = Re_MPropSets_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_MPropSets_Buf)
  ENDIF
  IF(ALLOCATED(Db_MPropSets_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_MPropSets_Buf)-1 ) = Db_MPropSets_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_MPropSets_Buf)
  ENDIF
  IF(ALLOCATED(Int_MPropSets_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_MPropSets_Buf)-1 ) = Int_MPropSets_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_MPropSets_Buf)
  ENDIF
  IF( ALLOCATED(Re_MPropSets_Buf) )  DEALLOCATE(Re_MPropSets_Buf)
  IF( ALLOCATED(Db_MPropSets_Buf) )  DEALLOCATE(Db_MPropSets_Buf)
  IF( ALLOCATED(Int_MPropSets_Buf) ) DEALLOCATE(Int_MPropSets_Buf)
ENDDO
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%SimplCd )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%SimplCdMG )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%SimplCa )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%SimplCaMG )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%SimplCp )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%SimplCpMG )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%SimplAxCa )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%SimplAxCaMG )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%SimplAxCp )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%SimplAxCpMG )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NCoefDpth )
  Int_Xferred   = Int_Xferred   + 1
DO i1 = LBOUND(InData%CoefDpths,1), UBOUND(InData%CoefDpths,1)
  CALL Morison_Packcoefdpths( Re_CoefDpths_Buf, Db_CoefDpths_Buf, Int_CoefDpths_Buf, InData%CoefDpths(i1), ErrStat, ErrMsg, OnlySize ) ! CoefDpths 
  IF(ALLOCATED(Re_CoefDpths_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_CoefDpths_Buf)-1 ) = Re_CoefDpths_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_CoefDpths_Buf)
  ENDIF
  IF(ALLOCATED(Db_CoefDpths_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_CoefDpths_Buf)-1 ) = Db_CoefDpths_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_CoefDpths_Buf)
  ENDIF
  IF(ALLOCATED(Int_CoefDpths_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_CoefDpths_Buf)-1 ) = Int_CoefDpths_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_CoefDpths_Buf)
  ENDIF
  IF( ALLOCATED(Re_CoefDpths_Buf) )  DEALLOCATE(Re_CoefDpths_Buf)
  IF( ALLOCATED(Db_CoefDpths_Buf) )  DEALLOCATE(Db_CoefDpths_Buf)
  IF( ALLOCATED(Int_CoefDpths_Buf) ) DEALLOCATE(Int_CoefDpths_Buf)
ENDDO
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NCoefMembers )
  Int_Xferred   = Int_Xferred   + 1
DO i1 = LBOUND(InData%CoefMembers,1), UBOUND(InData%CoefMembers,1)
  CALL Morison_Packcoefmembers( Re_CoefMembers_Buf, Db_CoefMembers_Buf, Int_CoefMembers_Buf, InData%CoefMembers(i1), ErrStat, ErrMsg, OnlySize ) ! CoefMembers 
  IF(ALLOCATED(Re_CoefMembers_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_CoefMembers_Buf)-1 ) = Re_CoefMembers_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_CoefMembers_Buf)
  ENDIF
  IF(ALLOCATED(Db_CoefMembers_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_CoefMembers_Buf)-1 ) = Db_CoefMembers_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_CoefMembers_Buf)
  ENDIF
  IF(ALLOCATED(Int_CoefMembers_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_CoefMembers_Buf)-1 ) = Int_CoefMembers_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_CoefMembers_Buf)
  ENDIF
  IF( ALLOCATED(Re_CoefMembers_Buf) )  DEALLOCATE(Re_CoefMembers_Buf)
  IF( ALLOCATED(Db_CoefMembers_Buf) )  DEALLOCATE(Db_CoefMembers_Buf)
  IF( ALLOCATED(Int_CoefMembers_Buf) ) DEALLOCATE(Int_CoefMembers_Buf)
ENDDO
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NMembers )
  Int_Xferred   = Int_Xferred   + 1
DO i1 = LBOUND(InData%InpMembers,1), UBOUND(InData%InpMembers,1)
  CALL Morison_Packmemberinputtype( Re_InpMembers_Buf, Db_InpMembers_Buf, Int_InpMembers_Buf, InData%InpMembers(i1), ErrStat, ErrMsg, OnlySize ) ! InpMembers 
  IF(ALLOCATED(Re_InpMembers_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_InpMembers_Buf)-1 ) = Re_InpMembers_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_InpMembers_Buf)
  ENDIF
  IF(ALLOCATED(Db_InpMembers_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_InpMembers_Buf)-1 ) = Db_InpMembers_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_InpMembers_Buf)
  ENDIF
  IF(ALLOCATED(Int_InpMembers_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_InpMembers_Buf)-1 ) = Int_InpMembers_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_InpMembers_Buf)
  ENDIF
  IF( ALLOCATED(Re_InpMembers_Buf) )  DEALLOCATE(Re_InpMembers_Buf)
  IF( ALLOCATED(Db_InpMembers_Buf) )  DEALLOCATE(Db_InpMembers_Buf)
  IF( ALLOCATED(Int_InpMembers_Buf) ) DEALLOCATE(Int_InpMembers_Buf)
ENDDO
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NFillGroups )
  Int_Xferred   = Int_Xferred   + 1
DO i1 = LBOUND(InData%FilledGroups,1), UBOUND(InData%FilledGroups,1)
  CALL Morison_Packfilledgrouptype( Re_FilledGroups_Buf, Db_FilledGroups_Buf, Int_FilledGroups_Buf, InData%FilledGroups(i1), ErrStat, ErrMsg, OnlySize ) ! FilledGroups 
  IF(ALLOCATED(Re_FilledGroups_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_FilledGroups_Buf)-1 ) = Re_FilledGroups_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_FilledGroups_Buf)
  ENDIF
  IF(ALLOCATED(Db_FilledGroups_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_FilledGroups_Buf)-1 ) = Db_FilledGroups_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_FilledGroups_Buf)
  ENDIF
  IF(ALLOCATED(Int_FilledGroups_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_FilledGroups_Buf)-1 ) = Int_FilledGroups_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_FilledGroups_Buf)
  ENDIF
  IF( ALLOCATED(Re_FilledGroups_Buf) )  DEALLOCATE(Re_FilledGroups_Buf)
  IF( ALLOCATED(Db_FilledGroups_Buf) )  DEALLOCATE(Db_FilledGroups_Buf)
  IF( ALLOCATED(Int_FilledGroups_Buf) ) DEALLOCATE(Int_FilledGroups_Buf)
ENDDO
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NMGDepths )
  Int_Xferred   = Int_Xferred   + 1
DO i1 = LBOUND(InData%MGDepths,1), UBOUND(InData%MGDepths,1)
  CALL Morison_Packmgdepthstype( Re_MGDepths_Buf, Db_MGDepths_Buf, Int_MGDepths_Buf, InData%MGDepths(i1), ErrStat, ErrMsg, OnlySize ) ! MGDepths 
  IF(ALLOCATED(Re_MGDepths_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_MGDepths_Buf)-1 ) = Re_MGDepths_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_MGDepths_Buf)
  ENDIF
  IF(ALLOCATED(Db_MGDepths_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_MGDepths_Buf)-1 ) = Db_MGDepths_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_MGDepths_Buf)
  ENDIF
  IF(ALLOCATED(Int_MGDepths_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_MGDepths_Buf)-1 ) = Int_MGDepths_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_MGDepths_Buf)
  ENDIF
  IF( ALLOCATED(Re_MGDepths_Buf) )  DEALLOCATE(Re_MGDepths_Buf)
  IF( ALLOCATED(Db_MGDepths_Buf) )  DEALLOCATE(Db_MGDepths_Buf)
  IF( ALLOCATED(Int_MGDepths_Buf) ) DEALLOCATE(Int_MGDepths_Buf)
ENDDO
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%MGTop )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%MGBottom )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NMOutputs )
  Int_Xferred   = Int_Xferred   + 1
DO i1 = LBOUND(InData%MOutLst,1), UBOUND(InData%MOutLst,1)
  CALL Morison_Packmoutput( Re_MOutLst_Buf, Db_MOutLst_Buf, Int_MOutLst_Buf, InData%MOutLst(i1), ErrStat, ErrMsg, OnlySize ) ! MOutLst 
  IF(ALLOCATED(Re_MOutLst_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_MOutLst_Buf)-1 ) = Re_MOutLst_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_MOutLst_Buf)
  ENDIF
  IF(ALLOCATED(Db_MOutLst_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_MOutLst_Buf)-1 ) = Db_MOutLst_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_MOutLst_Buf)
  ENDIF
  IF(ALLOCATED(Int_MOutLst_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_MOutLst_Buf)-1 ) = Int_MOutLst_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_MOutLst_Buf)
  ENDIF
  IF( ALLOCATED(Re_MOutLst_Buf) )  DEALLOCATE(Re_MOutLst_Buf)
  IF( ALLOCATED(Db_MOutLst_Buf) )  DEALLOCATE(Db_MOutLst_Buf)
  IF( ALLOCATED(Int_MOutLst_Buf) ) DEALLOCATE(Int_MOutLst_Buf)
ENDDO
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NJOutputs )
  Int_Xferred   = Int_Xferred   + 1
DO i1 = LBOUND(InData%JOutLst,1), UBOUND(InData%JOutLst,1)
  CALL Morison_Packjoutput( Re_JOutLst_Buf, Db_JOutLst_Buf, Int_JOutLst_Buf, InData%JOutLst(i1), ErrStat, ErrMsg, OnlySize ) ! JOutLst 
  IF(ALLOCATED(Re_JOutLst_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_JOutLst_Buf)-1 ) = Re_JOutLst_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_JOutLst_Buf)
  ENDIF
  IF(ALLOCATED(Db_JOutLst_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_JOutLst_Buf)-1 ) = Db_JOutLst_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_JOutLst_Buf)
  ENDIF
  IF(ALLOCATED(Int_JOutLst_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_JOutLst_Buf)-1 ) = Int_JOutLst_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_JOutLst_Buf)
  ENDIF
  IF( ALLOCATED(Re_JOutLst_Buf) )  DEALLOCATE(Re_JOutLst_Buf)
  IF( ALLOCATED(Db_JOutLst_Buf) )  DEALLOCATE(Db_JOutLst_Buf)
  IF( ALLOCATED(Int_JOutLst_Buf) ) DEALLOCATE(Int_JOutLst_Buf)
ENDDO
  IF ( ALLOCATED(InData%ValidOutList) ) THEN
    IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%ValidOutList))-1 ) = TRANSFER( PACK(InData%ValidOutList ,.TRUE.), IntKiBuf(1), 1)
    Int_Xferred   = Int_Xferred   + SIZE(InData%ValidOutList)
  ENDIF
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NumOuts )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%OutSwtch )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = TRANSFER( (InData%OutAll ), IntKiBuf(1), 1)
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%UnOutFile )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%UnSum )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NStepWave )
  Int_Xferred   = Int_Xferred   + 1
  IF ( ALLOCATED(InData%WaveAcc0) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%WaveAcc0))-1 ) =  PACK(InData%WaveAcc0 ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%WaveAcc0)
  ENDIF
  IF ( ALLOCATED(InData%WaveTime) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%WaveTime))-1 ) =  PACK(InData%WaveTime ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%WaveTime)
  ENDIF
  IF ( ALLOCATED(InData%WaveDynP0) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%WaveDynP0))-1 ) =  PACK(InData%WaveDynP0 ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%WaveDynP0)
  ENDIF
  IF ( ALLOCATED(InData%WaveVel0) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%WaveVel0))-1 ) =  PACK(InData%WaveVel0 ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%WaveVel0)
  ENDIF
 END SUBROUTINE Morison_PackInitInput

 SUBROUTINE Morison_UnPackInitInput( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(Morison_initinputtype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_InpJoints_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_InpJoints_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_InpJoints_Buf(:)
  REAL(ReKi),    ALLOCATABLE :: Re_Nodes_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_Nodes_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_Nodes_Buf(:)
  REAL(ReKi),    ALLOCATABLE :: Re_Elements_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_Elements_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_Elements_Buf(:)
  REAL(ReKi),    ALLOCATABLE :: Re_AxialCoefs_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_AxialCoefs_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_AxialCoefs_Buf(:)
  REAL(ReKi),    ALLOCATABLE :: Re_MPropSets_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_MPropSets_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_MPropSets_Buf(:)
  REAL(ReKi),    ALLOCATABLE :: Re_CoefDpths_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_CoefDpths_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_CoefDpths_Buf(:)
  REAL(ReKi),    ALLOCATABLE :: Re_CoefMembers_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_CoefMembers_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_CoefMembers_Buf(:)
  REAL(ReKi),    ALLOCATABLE :: Re_InpMembers_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_InpMembers_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_InpMembers_Buf(:)
  REAL(ReKi),    ALLOCATABLE :: Re_FilledGroups_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_FilledGroups_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_FilledGroups_Buf(:)
  REAL(ReKi),    ALLOCATABLE :: Re_MGDepths_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_MGDepths_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_MGDepths_Buf(:)
  REAL(ReKi),    ALLOCATABLE :: Re_MOutLst_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_MOutLst_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_MOutLst_Buf(:)
  REAL(ReKi),    ALLOCATABLE :: Re_JOutLst_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_JOutLst_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_JOutLst_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  OutData%Gravity = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%WtrDens = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%WtrDpth = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%MSL2SWL = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%NJoints = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%NNodes = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%TotalPossibleSuperMembers = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
DO i1 = LBOUND(OutData%InpJoints,1), UBOUND(OutData%InpJoints,1)
 ! first call Morison_Packjointtype to get correctly sized buffers for unpacking
  CALL Morison_Packjointtype( Re_InpJoints_Buf, Db_InpJoints_Buf, Int_InpJoints_Buf, OutData%InpJoints(i1), ErrStat, ErrMsg, .TRUE. ) ! InpJoints 
  IF(ALLOCATED(Re_InpJoints_Buf)) THEN
    Re_InpJoints_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_InpJoints_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_InpJoints_Buf)
  ENDIF
  IF(ALLOCATED(Db_InpJoints_Buf)) THEN
    Db_InpJoints_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_InpJoints_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_InpJoints_Buf)
  ENDIF
  IF(ALLOCATED(Int_InpJoints_Buf)) THEN
    Int_InpJoints_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_InpJoints_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_InpJoints_Buf)
  ENDIF
  CALL Morison_UnPackjointtype( Re_InpJoints_Buf, Db_InpJoints_Buf, Int_InpJoints_Buf, OutData%InpJoints(i1), ErrStat, ErrMsg ) ! InpJoints 
ENDDO
DO i1 = LBOUND(OutData%Nodes,1), UBOUND(OutData%Nodes,1)
 ! first call Morison_Packnodetype to get correctly sized buffers for unpacking
  CALL Morison_Packnodetype( Re_Nodes_Buf, Db_Nodes_Buf, Int_Nodes_Buf, OutData%Nodes(i1), ErrStat, ErrMsg, .TRUE. ) ! Nodes 
  IF(ALLOCATED(Re_Nodes_Buf)) THEN
    Re_Nodes_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Nodes_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_Nodes_Buf)
  ENDIF
  IF(ALLOCATED(Db_Nodes_Buf)) THEN
    Db_Nodes_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Nodes_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_Nodes_Buf)
  ENDIF
  IF(ALLOCATED(Int_Nodes_Buf)) THEN
    Int_Nodes_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Nodes_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_Nodes_Buf)
  ENDIF
  CALL Morison_UnPacknodetype( Re_Nodes_Buf, Db_Nodes_Buf, Int_Nodes_Buf, OutData%Nodes(i1), ErrStat, ErrMsg ) ! Nodes 
ENDDO
  OutData%NElements = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
DO i1 = LBOUND(OutData%Elements,1), UBOUND(OutData%Elements,1)
 ! first call Morison_Packmembertype to get correctly sized buffers for unpacking
  CALL Morison_Packmembertype( Re_Elements_Buf, Db_Elements_Buf, Int_Elements_Buf, OutData%Elements(i1), ErrStat, ErrMsg, .TRUE. ) ! Elements 
  IF(ALLOCATED(Re_Elements_Buf)) THEN
    Re_Elements_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Elements_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_Elements_Buf)
  ENDIF
  IF(ALLOCATED(Db_Elements_Buf)) THEN
    Db_Elements_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Elements_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_Elements_Buf)
  ENDIF
  IF(ALLOCATED(Int_Elements_Buf)) THEN
    Int_Elements_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Elements_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_Elements_Buf)
  ENDIF
  CALL Morison_UnPackmembertype( Re_Elements_Buf, Db_Elements_Buf, Int_Elements_Buf, OutData%Elements(i1), ErrStat, ErrMsg ) ! Elements 
ENDDO
  OutData%NAxCoefs = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
DO i1 = LBOUND(OutData%AxialCoefs,1), UBOUND(OutData%AxialCoefs,1)
 ! first call Morison_Packaxialcoeftype to get correctly sized buffers for unpacking
  CALL Morison_Packaxialcoeftype( Re_AxialCoefs_Buf, Db_AxialCoefs_Buf, Int_AxialCoefs_Buf, OutData%AxialCoefs(i1), ErrStat, ErrMsg, .TRUE. ) ! AxialCoefs 
  IF(ALLOCATED(Re_AxialCoefs_Buf)) THEN
    Re_AxialCoefs_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_AxialCoefs_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_AxialCoefs_Buf)
  ENDIF
  IF(ALLOCATED(Db_AxialCoefs_Buf)) THEN
    Db_AxialCoefs_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_AxialCoefs_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_AxialCoefs_Buf)
  ENDIF
  IF(ALLOCATED(Int_AxialCoefs_Buf)) THEN
    Int_AxialCoefs_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_AxialCoefs_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_AxialCoefs_Buf)
  ENDIF
  CALL Morison_UnPackaxialcoeftype( Re_AxialCoefs_Buf, Db_AxialCoefs_Buf, Int_AxialCoefs_Buf, OutData%AxialCoefs(i1), ErrStat, ErrMsg ) ! AxialCoefs 
ENDDO
  OutData%NPropSets = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
DO i1 = LBOUND(OutData%MPropSets,1), UBOUND(OutData%MPropSets,1)
 ! first call Morison_Packmemberproptype to get correctly sized buffers for unpacking
  CALL Morison_Packmemberproptype( Re_MPropSets_Buf, Db_MPropSets_Buf, Int_MPropSets_Buf, OutData%MPropSets(i1), ErrStat, ErrMsg, .TRUE. ) ! MPropSets 
  IF(ALLOCATED(Re_MPropSets_Buf)) THEN
    Re_MPropSets_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_MPropSets_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_MPropSets_Buf)
  ENDIF
  IF(ALLOCATED(Db_MPropSets_Buf)) THEN
    Db_MPropSets_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_MPropSets_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_MPropSets_Buf)
  ENDIF
  IF(ALLOCATED(Int_MPropSets_Buf)) THEN
    Int_MPropSets_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_MPropSets_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_MPropSets_Buf)
  ENDIF
  CALL Morison_UnPackmemberproptype( Re_MPropSets_Buf, Db_MPropSets_Buf, Int_MPropSets_Buf, OutData%MPropSets(i1), ErrStat, ErrMsg ) ! MPropSets 
ENDDO
  OutData%SimplCd = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%SimplCdMG = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%SimplCa = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%SimplCaMG = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%SimplCp = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%SimplCpMG = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%SimplAxCa = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%SimplAxCaMG = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%SimplAxCp = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%SimplAxCpMG = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%NCoefDpth = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
DO i1 = LBOUND(OutData%CoefDpths,1), UBOUND(OutData%CoefDpths,1)
 ! first call Morison_Packcoefdpths to get correctly sized buffers for unpacking
  CALL Morison_Packcoefdpths( Re_CoefDpths_Buf, Db_CoefDpths_Buf, Int_CoefDpths_Buf, OutData%CoefDpths(i1), ErrStat, ErrMsg, .TRUE. ) ! CoefDpths 
  IF(ALLOCATED(Re_CoefDpths_Buf)) THEN
    Re_CoefDpths_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_CoefDpths_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_CoefDpths_Buf)
  ENDIF
  IF(ALLOCATED(Db_CoefDpths_Buf)) THEN
    Db_CoefDpths_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_CoefDpths_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_CoefDpths_Buf)
  ENDIF
  IF(ALLOCATED(Int_CoefDpths_Buf)) THEN
    Int_CoefDpths_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_CoefDpths_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_CoefDpths_Buf)
  ENDIF
  CALL Morison_UnPackcoefdpths( Re_CoefDpths_Buf, Db_CoefDpths_Buf, Int_CoefDpths_Buf, OutData%CoefDpths(i1), ErrStat, ErrMsg ) ! CoefDpths 
ENDDO
  OutData%NCoefMembers = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
DO i1 = LBOUND(OutData%CoefMembers,1), UBOUND(OutData%CoefMembers,1)
 ! first call Morison_Packcoefmembers to get correctly sized buffers for unpacking
  CALL Morison_Packcoefmembers( Re_CoefMembers_Buf, Db_CoefMembers_Buf, Int_CoefMembers_Buf, OutData%CoefMembers(i1), ErrStat, ErrMsg, .TRUE. ) ! CoefMembers 
  IF(ALLOCATED(Re_CoefMembers_Buf)) THEN
    Re_CoefMembers_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_CoefMembers_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_CoefMembers_Buf)
  ENDIF
  IF(ALLOCATED(Db_CoefMembers_Buf)) THEN
    Db_CoefMembers_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_CoefMembers_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_CoefMembers_Buf)
  ENDIF
  IF(ALLOCATED(Int_CoefMembers_Buf)) THEN
    Int_CoefMembers_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_CoefMembers_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_CoefMembers_Buf)
  ENDIF
  CALL Morison_UnPackcoefmembers( Re_CoefMembers_Buf, Db_CoefMembers_Buf, Int_CoefMembers_Buf, OutData%CoefMembers(i1), ErrStat, ErrMsg ) ! CoefMembers 
ENDDO
  OutData%NMembers = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
DO i1 = LBOUND(OutData%InpMembers,1), UBOUND(OutData%InpMembers,1)
 ! first call Morison_Packmemberinputtype to get correctly sized buffers for unpacking
  CALL Morison_Packmemberinputtype( Re_InpMembers_Buf, Db_InpMembers_Buf, Int_InpMembers_Buf, OutData%InpMembers(i1), ErrStat, ErrMsg, .TRUE. ) ! InpMembers 
  IF(ALLOCATED(Re_InpMembers_Buf)) THEN
    Re_InpMembers_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_InpMembers_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_InpMembers_Buf)
  ENDIF
  IF(ALLOCATED(Db_InpMembers_Buf)) THEN
    Db_InpMembers_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_InpMembers_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_InpMembers_Buf)
  ENDIF
  IF(ALLOCATED(Int_InpMembers_Buf)) THEN
    Int_InpMembers_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_InpMembers_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_InpMembers_Buf)
  ENDIF
  CALL Morison_UnPackmemberinputtype( Re_InpMembers_Buf, Db_InpMembers_Buf, Int_InpMembers_Buf, OutData%InpMembers(i1), ErrStat, ErrMsg ) ! InpMembers 
ENDDO
  OutData%NFillGroups = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
DO i1 = LBOUND(OutData%FilledGroups,1), UBOUND(OutData%FilledGroups,1)
 ! first call Morison_Packfilledgrouptype to get correctly sized buffers for unpacking
  CALL Morison_Packfilledgrouptype( Re_FilledGroups_Buf, Db_FilledGroups_Buf, Int_FilledGroups_Buf, OutData%FilledGroups(i1), ErrStat, ErrMsg, .TRUE. ) ! FilledGroups 
  IF(ALLOCATED(Re_FilledGroups_Buf)) THEN
    Re_FilledGroups_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_FilledGroups_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_FilledGroups_Buf)
  ENDIF
  IF(ALLOCATED(Db_FilledGroups_Buf)) THEN
    Db_FilledGroups_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_FilledGroups_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_FilledGroups_Buf)
  ENDIF
  IF(ALLOCATED(Int_FilledGroups_Buf)) THEN
    Int_FilledGroups_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_FilledGroups_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_FilledGroups_Buf)
  ENDIF
  CALL Morison_UnPackfilledgrouptype( Re_FilledGroups_Buf, Db_FilledGroups_Buf, Int_FilledGroups_Buf, OutData%FilledGroups(i1), ErrStat, ErrMsg ) ! FilledGroups 
ENDDO
  OutData%NMGDepths = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
DO i1 = LBOUND(OutData%MGDepths,1), UBOUND(OutData%MGDepths,1)
 ! first call Morison_Packmgdepthstype to get correctly sized buffers for unpacking
  CALL Morison_Packmgdepthstype( Re_MGDepths_Buf, Db_MGDepths_Buf, Int_MGDepths_Buf, OutData%MGDepths(i1), ErrStat, ErrMsg, .TRUE. ) ! MGDepths 
  IF(ALLOCATED(Re_MGDepths_Buf)) THEN
    Re_MGDepths_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_MGDepths_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_MGDepths_Buf)
  ENDIF
  IF(ALLOCATED(Db_MGDepths_Buf)) THEN
    Db_MGDepths_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_MGDepths_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_MGDepths_Buf)
  ENDIF
  IF(ALLOCATED(Int_MGDepths_Buf)) THEN
    Int_MGDepths_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_MGDepths_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_MGDepths_Buf)
  ENDIF
  CALL Morison_UnPackmgdepthstype( Re_MGDepths_Buf, Db_MGDepths_Buf, Int_MGDepths_Buf, OutData%MGDepths(i1), ErrStat, ErrMsg ) ! MGDepths 
ENDDO
  OutData%MGTop = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%MGBottom = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%NMOutputs = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
DO i1 = LBOUND(OutData%MOutLst,1), UBOUND(OutData%MOutLst,1)
 ! first call Morison_Packmoutput to get correctly sized buffers for unpacking
  CALL Morison_Packmoutput( Re_MOutLst_Buf, Db_MOutLst_Buf, Int_MOutLst_Buf, OutData%MOutLst(i1), ErrStat, ErrMsg, .TRUE. ) ! MOutLst 
  IF(ALLOCATED(Re_MOutLst_Buf)) THEN
    Re_MOutLst_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_MOutLst_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_MOutLst_Buf)
  ENDIF
  IF(ALLOCATED(Db_MOutLst_Buf)) THEN
    Db_MOutLst_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_MOutLst_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_MOutLst_Buf)
  ENDIF
  IF(ALLOCATED(Int_MOutLst_Buf)) THEN
    Int_MOutLst_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_MOutLst_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_MOutLst_Buf)
  ENDIF
  CALL Morison_UnPackmoutput( Re_MOutLst_Buf, Db_MOutLst_Buf, Int_MOutLst_Buf, OutData%MOutLst(i1), ErrStat, ErrMsg ) ! MOutLst 
ENDDO
  OutData%NJOutputs = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
DO i1 = LBOUND(OutData%JOutLst,1), UBOUND(OutData%JOutLst,1)
 ! first call Morison_Packjoutput to get correctly sized buffers for unpacking
  CALL Morison_Packjoutput( Re_JOutLst_Buf, Db_JOutLst_Buf, Int_JOutLst_Buf, OutData%JOutLst(i1), ErrStat, ErrMsg, .TRUE. ) ! JOutLst 
  IF(ALLOCATED(Re_JOutLst_Buf)) THEN
    Re_JOutLst_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_JOutLst_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_JOutLst_Buf)
  ENDIF
  IF(ALLOCATED(Db_JOutLst_Buf)) THEN
    Db_JOutLst_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_JOutLst_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_JOutLst_Buf)
  ENDIF
  IF(ALLOCATED(Int_JOutLst_Buf)) THEN
    Int_JOutLst_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_JOutLst_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_JOutLst_Buf)
  ENDIF
  CALL Morison_UnPackjoutput( Re_JOutLst_Buf, Db_JOutLst_Buf, Int_JOutLst_Buf, OutData%JOutLst(i1), ErrStat, ErrMsg ) ! JOutLst 
ENDDO
  IF ( ALLOCATED(OutData%ValidOutList) ) THEN
  ENDIF
  OutData%NumOuts = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%OutSwtch = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%UnOutFile = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%UnSum = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%NStepWave = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  IF ( ALLOCATED(OutData%WaveAcc0) ) THEN
  ALLOCATE(mask3(SIZE(OutData%WaveAcc0,1),SIZE(OutData%WaveAcc0,2),SIZE(OutData%WaveAcc0,3))); mask3 = .TRUE.
    OutData%WaveAcc0 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%WaveAcc0))-1 ),mask3,OutData%WaveAcc0)
  DEALLOCATE(mask3)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%WaveAcc0)
  ENDIF
  IF ( ALLOCATED(OutData%WaveTime) ) THEN
  ALLOCATE(mask1(SIZE(OutData%WaveTime,1))); mask1 = .TRUE.
    OutData%WaveTime = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%WaveTime))-1 ),mask1,OutData%WaveTime)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%WaveTime)
  ENDIF
  IF ( ALLOCATED(OutData%WaveDynP0) ) THEN
  ALLOCATE(mask2(SIZE(OutData%WaveDynP0,1),SIZE(OutData%WaveDynP0,2))); mask2 = .TRUE.
    OutData%WaveDynP0 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%WaveDynP0))-1 ),mask2,OutData%WaveDynP0)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%WaveDynP0)
  ENDIF
  IF ( ALLOCATED(OutData%WaveVel0) ) THEN
  ALLOCATE(mask3(SIZE(OutData%WaveVel0,1),SIZE(OutData%WaveVel0,2),SIZE(OutData%WaveVel0,3))); mask3 = .TRUE.
    OutData%WaveVel0 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%WaveVel0))-1 ),mask3,OutData%WaveVel0)
  DEALLOCATE(mask3)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%WaveVel0)
  ENDIF
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE Morison_UnPackInitInput

 SUBROUTINE Morison_CopyInitOutput( SrcInitOutputData, DstInitOutputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(Morison_initoutputtype), INTENT(INOUT) :: SrcInitOutputData
   TYPE(Morison_initoutputtype), INTENT(INOUT) :: DstInitOutputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
     CALL MeshCopy( SrcInitOutputData%DistribMesh, DstInitOutputData%DistribMesh, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'Morison_CopyInitOutput:DistribMesh')
         IF (ErrStat>=AbortErrLev) RETURN
     CALL MeshCopy( SrcInitOutputData%LumpedMesh, DstInitOutputData%LumpedMesh, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'Morison_CopyInitOutput:LumpedMesh')
         IF (ErrStat>=AbortErrLev) RETURN
IF (ALLOCATED(SrcInitOutputData%WriteOutputHdr)) THEN
   i1_l = LBOUND(SrcInitOutputData%WriteOutputHdr,1)
   i1_u = UBOUND(SrcInitOutputData%WriteOutputHdr,1)
   IF (.NOT. ALLOCATED(DstInitOutputData%WriteOutputHdr)) THEN 
      ALLOCATE(DstInitOutputData%WriteOutputHdr(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitOutputData%WriteOutputHdr.', ErrStat, ErrMsg,'Morison_CopyInitOutput')
         RETURN
      END IF
   END IF
   DstInitOutputData%WriteOutputHdr = SrcInitOutputData%WriteOutputHdr
ENDIF
IF (ALLOCATED(SrcInitOutputData%WriteOutputUnt)) THEN
   i1_l = LBOUND(SrcInitOutputData%WriteOutputUnt,1)
   i1_u = UBOUND(SrcInitOutputData%WriteOutputUnt,1)
   IF (.NOT. ALLOCATED(DstInitOutputData%WriteOutputUnt)) THEN 
      ALLOCATE(DstInitOutputData%WriteOutputUnt(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitOutputData%WriteOutputUnt.', ErrStat, ErrMsg,'Morison_CopyInitOutput')
         RETURN
      END IF
   END IF
   DstInitOutputData%WriteOutputUnt = SrcInitOutputData%WriteOutputUnt
ENDIF
 END SUBROUTINE Morison_CopyInitOutput

 SUBROUTINE Morison_DestroyInitOutput( InitOutputData, ErrStat, ErrMsg )
  TYPE(Morison_initoutputtype), INTENT(INOUT) :: InitOutputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  CALL MeshDestroy( InitOutputData%DistribMesh, ErrStat, ErrMsg )
  CALL MeshDestroy( InitOutputData%LumpedMesh, ErrStat, ErrMsg )
IF (ALLOCATED(InitOutputData%WriteOutputHdr)) THEN
   DEALLOCATE(InitOutputData%WriteOutputHdr)
ENDIF
IF (ALLOCATED(InitOutputData%WriteOutputUnt)) THEN
   DEALLOCATE(InitOutputData%WriteOutputUnt)
ENDIF
 END SUBROUTINE Morison_DestroyInitOutput

 SUBROUTINE Morison_PackInitOutput( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(Morison_initoutputtype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_DistribMesh_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_DistribMesh_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_DistribMesh_Buf(:)
  REAL(ReKi),     ALLOCATABLE :: Re_LumpedMesh_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_LumpedMesh_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_LumpedMesh_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
 ! Allocate mesh buffers, if any (we'll also get sizes from these) 
  CALL MeshPack( InData%DistribMesh, Re_DistribMesh_Buf, Db_DistribMesh_Buf, Int_DistribMesh_Buf, ErrStat, ErrMsg, .TRUE. ) ! DistribMesh 
  IF(ALLOCATED(Re_DistribMesh_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_DistribMesh_Buf  ) ! DistribMesh
  IF(ALLOCATED(Db_DistribMesh_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_DistribMesh_Buf  ) ! DistribMesh
  IF(ALLOCATED(Int_DistribMesh_Buf))Int_BufSz = Int_BufSz + SIZE( Int_DistribMesh_Buf ) ! DistribMesh
  IF(ALLOCATED(Re_DistribMesh_Buf))  DEALLOCATE(Re_DistribMesh_Buf)
  IF(ALLOCATED(Db_DistribMesh_Buf))  DEALLOCATE(Db_DistribMesh_Buf)
  IF(ALLOCATED(Int_DistribMesh_Buf)) DEALLOCATE(Int_DistribMesh_Buf)
  CALL MeshPack( InData%LumpedMesh, Re_LumpedMesh_Buf, Db_LumpedMesh_Buf, Int_LumpedMesh_Buf, ErrStat, ErrMsg, .TRUE. ) ! LumpedMesh 
  IF(ALLOCATED(Re_LumpedMesh_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_LumpedMesh_Buf  ) ! LumpedMesh
  IF(ALLOCATED(Db_LumpedMesh_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_LumpedMesh_Buf  ) ! LumpedMesh
  IF(ALLOCATED(Int_LumpedMesh_Buf))Int_BufSz = Int_BufSz + SIZE( Int_LumpedMesh_Buf ) ! LumpedMesh
  IF(ALLOCATED(Re_LumpedMesh_Buf))  DEALLOCATE(Re_LumpedMesh_Buf)
  IF(ALLOCATED(Db_LumpedMesh_Buf))  DEALLOCATE(Db_LumpedMesh_Buf)
  IF(ALLOCATED(Int_LumpedMesh_Buf)) DEALLOCATE(Int_LumpedMesh_Buf)
!  missing buffer for WriteOutputHdr
!  missing buffer for WriteOutputUnt
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  CALL MeshPack( InData%DistribMesh, Re_DistribMesh_Buf, Db_DistribMesh_Buf, Int_DistribMesh_Buf, ErrStat, ErrMsg, OnlySize ) ! DistribMesh 
  IF(ALLOCATED(Re_DistribMesh_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_DistribMesh_Buf)-1 ) = Re_DistribMesh_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_DistribMesh_Buf)
  ENDIF
  IF(ALLOCATED(Db_DistribMesh_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_DistribMesh_Buf)-1 ) = Db_DistribMesh_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_DistribMesh_Buf)
  ENDIF
  IF(ALLOCATED(Int_DistribMesh_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_DistribMesh_Buf)-1 ) = Int_DistribMesh_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_DistribMesh_Buf)
  ENDIF
  IF( ALLOCATED(Re_DistribMesh_Buf) )  DEALLOCATE(Re_DistribMesh_Buf)
  IF( ALLOCATED(Db_DistribMesh_Buf) )  DEALLOCATE(Db_DistribMesh_Buf)
  IF( ALLOCATED(Int_DistribMesh_Buf) ) DEALLOCATE(Int_DistribMesh_Buf)
  CALL MeshPack( InData%LumpedMesh, Re_LumpedMesh_Buf, Db_LumpedMesh_Buf, Int_LumpedMesh_Buf, ErrStat, ErrMsg, OnlySize ) ! LumpedMesh 
  IF(ALLOCATED(Re_LumpedMesh_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_LumpedMesh_Buf)-1 ) = Re_LumpedMesh_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_LumpedMesh_Buf)
  ENDIF
  IF(ALLOCATED(Db_LumpedMesh_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_LumpedMesh_Buf)-1 ) = Db_LumpedMesh_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_LumpedMesh_Buf)
  ENDIF
  IF(ALLOCATED(Int_LumpedMesh_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_LumpedMesh_Buf)-1 ) = Int_LumpedMesh_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_LumpedMesh_Buf)
  ENDIF
  IF( ALLOCATED(Re_LumpedMesh_Buf) )  DEALLOCATE(Re_LumpedMesh_Buf)
  IF( ALLOCATED(Db_LumpedMesh_Buf) )  DEALLOCATE(Db_LumpedMesh_Buf)
  IF( ALLOCATED(Int_LumpedMesh_Buf) ) DEALLOCATE(Int_LumpedMesh_Buf)
 END SUBROUTINE Morison_PackInitOutput

 SUBROUTINE Morison_UnPackInitOutput( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(Morison_initoutputtype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_DistribMesh_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_DistribMesh_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_DistribMesh_Buf(:)
  REAL(ReKi),    ALLOCATABLE :: Re_LumpedMesh_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_LumpedMesh_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_LumpedMesh_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
 ! first call MeshPack to get correctly sized buffers for unpacking
  CALL MeshPack( OutData%DistribMesh, Re_DistribMesh_Buf, Db_DistribMesh_Buf, Int_DistribMesh_Buf, ErrStat, ErrMsg , .TRUE. ) ! DistribMesh 
  IF(ALLOCATED(Re_DistribMesh_Buf)) THEN
    Re_DistribMesh_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_DistribMesh_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_DistribMesh_Buf)
  ENDIF
  IF(ALLOCATED(Db_DistribMesh_Buf)) THEN
    Db_DistribMesh_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_DistribMesh_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_DistribMesh_Buf)
  ENDIF
  IF(ALLOCATED(Int_DistribMesh_Buf)) THEN
    Int_DistribMesh_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_DistribMesh_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_DistribMesh_Buf)
  ENDIF
  CALL MeshUnPack( OutData%DistribMesh, Re_DistribMesh_Buf, Db_DistribMesh_Buf, Int_DistribMesh_Buf, ErrStat, ErrMsg ) ! DistribMesh 
  IF( ALLOCATED(Re_DistribMesh_Buf) )  DEALLOCATE(Re_DistribMesh_Buf)
  IF( ALLOCATED(Db_DistribMesh_Buf) )  DEALLOCATE(Db_DistribMesh_Buf)
  IF( ALLOCATED(Int_DistribMesh_Buf) ) DEALLOCATE(Int_DistribMesh_Buf)
  CALL MeshPack( OutData%LumpedMesh, Re_LumpedMesh_Buf, Db_LumpedMesh_Buf, Int_LumpedMesh_Buf, ErrStat, ErrMsg , .TRUE. ) ! LumpedMesh 
  IF(ALLOCATED(Re_LumpedMesh_Buf)) THEN
    Re_LumpedMesh_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_LumpedMesh_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_LumpedMesh_Buf)
  ENDIF
  IF(ALLOCATED(Db_LumpedMesh_Buf)) THEN
    Db_LumpedMesh_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_LumpedMesh_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_LumpedMesh_Buf)
  ENDIF
  IF(ALLOCATED(Int_LumpedMesh_Buf)) THEN
    Int_LumpedMesh_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_LumpedMesh_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_LumpedMesh_Buf)
  ENDIF
  CALL MeshUnPack( OutData%LumpedMesh, Re_LumpedMesh_Buf, Db_LumpedMesh_Buf, Int_LumpedMesh_Buf, ErrStat, ErrMsg ) ! LumpedMesh 
  IF( ALLOCATED(Re_LumpedMesh_Buf) )  DEALLOCATE(Re_LumpedMesh_Buf)
  IF( ALLOCATED(Db_LumpedMesh_Buf) )  DEALLOCATE(Db_LumpedMesh_Buf)
  IF( ALLOCATED(Int_LumpedMesh_Buf) ) DEALLOCATE(Int_LumpedMesh_Buf)
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE Morison_UnPackInitOutput

 SUBROUTINE Morison_CopyContState( SrcContStateData, DstContStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(Morison_continuousstatetype), INTENT(INOUT) :: SrcContStateData
   TYPE(Morison_continuousstatetype), INTENT(INOUT) :: DstContStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
   DstContStateData%DummyContState = SrcContStateData%DummyContState
 END SUBROUTINE Morison_CopyContState

 SUBROUTINE Morison_DestroyContState( ContStateData, ErrStat, ErrMsg )
  TYPE(Morison_continuousstatetype), INTENT(INOUT) :: ContStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
 END SUBROUTINE Morison_DestroyContState

 SUBROUTINE Morison_PackContState( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(Morison_continuousstatetype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Re_BufSz   = Re_BufSz   + 1  ! DummyContState
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%DummyContState )
  Re_Xferred   = Re_Xferred   + 1
 END SUBROUTINE Morison_PackContState

 SUBROUTINE Morison_UnPackContState( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(Morison_continuousstatetype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  OutData%DummyContState = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE Morison_UnPackContState

 SUBROUTINE Morison_CopyDiscState( SrcDiscStateData, DstDiscStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(Morison_discretestatetype), INTENT(INOUT) :: SrcDiscStateData
   TYPE(Morison_discretestatetype), INTENT(INOUT) :: DstDiscStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
   DstDiscStateData%DummyDiscState = SrcDiscStateData%DummyDiscState
 END SUBROUTINE Morison_CopyDiscState

 SUBROUTINE Morison_DestroyDiscState( DiscStateData, ErrStat, ErrMsg )
  TYPE(Morison_discretestatetype), INTENT(INOUT) :: DiscStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
 END SUBROUTINE Morison_DestroyDiscState

 SUBROUTINE Morison_PackDiscState( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(Morison_discretestatetype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Re_BufSz   = Re_BufSz   + 1  ! DummyDiscState
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%DummyDiscState )
  Re_Xferred   = Re_Xferred   + 1
 END SUBROUTINE Morison_PackDiscState

 SUBROUTINE Morison_UnPackDiscState( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(Morison_discretestatetype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  OutData%DummyDiscState = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE Morison_UnPackDiscState

 SUBROUTINE Morison_CopyConstrState( SrcConstrStateData, DstConstrStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(Morison_constraintstatetype), INTENT(INOUT) :: SrcConstrStateData
   TYPE(Morison_constraintstatetype), INTENT(INOUT) :: DstConstrStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
   DstConstrStateData%DummyConstrState = SrcConstrStateData%DummyConstrState
 END SUBROUTINE Morison_CopyConstrState

 SUBROUTINE Morison_DestroyConstrState( ConstrStateData, ErrStat, ErrMsg )
  TYPE(Morison_constraintstatetype), INTENT(INOUT) :: ConstrStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
 END SUBROUTINE Morison_DestroyConstrState

 SUBROUTINE Morison_PackConstrState( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(Morison_constraintstatetype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Re_BufSz   = Re_BufSz   + 1  ! DummyConstrState
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%DummyConstrState )
  Re_Xferred   = Re_Xferred   + 1
 END SUBROUTINE Morison_PackConstrState

 SUBROUTINE Morison_UnPackConstrState( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(Morison_constraintstatetype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  OutData%DummyConstrState = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE Morison_UnPackConstrState

 SUBROUTINE Morison_CopyOtherState( SrcOtherStateData, DstOtherStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(Morison_otherstatetype), INTENT(INOUT) :: SrcOtherStateData
   TYPE(Morison_otherstatetype), INTENT(INOUT) :: DstOtherStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcOtherStateData%D_F_D)) THEN
   i1_l = LBOUND(SrcOtherStateData%D_F_D,1)
   i1_u = UBOUND(SrcOtherStateData%D_F_D,1)
   i2_l = LBOUND(SrcOtherStateData%D_F_D,2)
   i2_u = UBOUND(SrcOtherStateData%D_F_D,2)
   IF (.NOT. ALLOCATED(DstOtherStateData%D_F_D)) THEN 
      ALLOCATE(DstOtherStateData%D_F_D(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOtherStateData%D_F_D.', ErrStat, ErrMsg,'Morison_CopyOtherState')
         RETURN
      END IF
   END IF
   DstOtherStateData%D_F_D = SrcOtherStateData%D_F_D
ENDIF
IF (ALLOCATED(SrcOtherStateData%D_F_I)) THEN
   i1_l = LBOUND(SrcOtherStateData%D_F_I,1)
   i1_u = UBOUND(SrcOtherStateData%D_F_I,1)
   i2_l = LBOUND(SrcOtherStateData%D_F_I,2)
   i2_u = UBOUND(SrcOtherStateData%D_F_I,2)
   IF (.NOT. ALLOCATED(DstOtherStateData%D_F_I)) THEN 
      ALLOCATE(DstOtherStateData%D_F_I(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOtherStateData%D_F_I.', ErrStat, ErrMsg,'Morison_CopyOtherState')
         RETURN
      END IF
   END IF
   DstOtherStateData%D_F_I = SrcOtherStateData%D_F_I
ENDIF
IF (ALLOCATED(SrcOtherStateData%D_F_DP)) THEN
   i1_l = LBOUND(SrcOtherStateData%D_F_DP,1)
   i1_u = UBOUND(SrcOtherStateData%D_F_DP,1)
   i2_l = LBOUND(SrcOtherStateData%D_F_DP,2)
   i2_u = UBOUND(SrcOtherStateData%D_F_DP,2)
   IF (.NOT. ALLOCATED(DstOtherStateData%D_F_DP)) THEN 
      ALLOCATE(DstOtherStateData%D_F_DP(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOtherStateData%D_F_DP.', ErrStat, ErrMsg,'Morison_CopyOtherState')
         RETURN
      END IF
   END IF
   DstOtherStateData%D_F_DP = SrcOtherStateData%D_F_DP
ENDIF
IF (ALLOCATED(SrcOtherStateData%D_F_AM)) THEN
   i1_l = LBOUND(SrcOtherStateData%D_F_AM,1)
   i1_u = UBOUND(SrcOtherStateData%D_F_AM,1)
   i2_l = LBOUND(SrcOtherStateData%D_F_AM,2)
   i2_u = UBOUND(SrcOtherStateData%D_F_AM,2)
   IF (.NOT. ALLOCATED(DstOtherStateData%D_F_AM)) THEN 
      ALLOCATE(DstOtherStateData%D_F_AM(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOtherStateData%D_F_AM.', ErrStat, ErrMsg,'Morison_CopyOtherState')
         RETURN
      END IF
   END IF
   DstOtherStateData%D_F_AM = SrcOtherStateData%D_F_AM
ENDIF
IF (ALLOCATED(SrcOtherStateData%D_F_AM_M)) THEN
   i1_l = LBOUND(SrcOtherStateData%D_F_AM_M,1)
   i1_u = UBOUND(SrcOtherStateData%D_F_AM_M,1)
   i2_l = LBOUND(SrcOtherStateData%D_F_AM_M,2)
   i2_u = UBOUND(SrcOtherStateData%D_F_AM_M,2)
   IF (.NOT. ALLOCATED(DstOtherStateData%D_F_AM_M)) THEN 
      ALLOCATE(DstOtherStateData%D_F_AM_M(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOtherStateData%D_F_AM_M.', ErrStat, ErrMsg,'Morison_CopyOtherState')
         RETURN
      END IF
   END IF
   DstOtherStateData%D_F_AM_M = SrcOtherStateData%D_F_AM_M
ENDIF
IF (ALLOCATED(SrcOtherStateData%D_F_AM_MG)) THEN
   i1_l = LBOUND(SrcOtherStateData%D_F_AM_MG,1)
   i1_u = UBOUND(SrcOtherStateData%D_F_AM_MG,1)
   i2_l = LBOUND(SrcOtherStateData%D_F_AM_MG,2)
   i2_u = UBOUND(SrcOtherStateData%D_F_AM_MG,2)
   IF (.NOT. ALLOCATED(DstOtherStateData%D_F_AM_MG)) THEN 
      ALLOCATE(DstOtherStateData%D_F_AM_MG(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOtherStateData%D_F_AM_MG.', ErrStat, ErrMsg,'Morison_CopyOtherState')
         RETURN
      END IF
   END IF
   DstOtherStateData%D_F_AM_MG = SrcOtherStateData%D_F_AM_MG
ENDIF
IF (ALLOCATED(SrcOtherStateData%D_F_AM_F)) THEN
   i1_l = LBOUND(SrcOtherStateData%D_F_AM_F,1)
   i1_u = UBOUND(SrcOtherStateData%D_F_AM_F,1)
   i2_l = LBOUND(SrcOtherStateData%D_F_AM_F,2)
   i2_u = UBOUND(SrcOtherStateData%D_F_AM_F,2)
   IF (.NOT. ALLOCATED(DstOtherStateData%D_F_AM_F)) THEN 
      ALLOCATE(DstOtherStateData%D_F_AM_F(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOtherStateData%D_F_AM_F.', ErrStat, ErrMsg,'Morison_CopyOtherState')
         RETURN
      END IF
   END IF
   DstOtherStateData%D_F_AM_F = SrcOtherStateData%D_F_AM_F
ENDIF
IF (ALLOCATED(SrcOtherStateData%D_FV)) THEN
   i1_l = LBOUND(SrcOtherStateData%D_FV,1)
   i1_u = UBOUND(SrcOtherStateData%D_FV,1)
   i2_l = LBOUND(SrcOtherStateData%D_FV,2)
   i2_u = UBOUND(SrcOtherStateData%D_FV,2)
   IF (.NOT. ALLOCATED(DstOtherStateData%D_FV)) THEN 
      ALLOCATE(DstOtherStateData%D_FV(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOtherStateData%D_FV.', ErrStat, ErrMsg,'Morison_CopyOtherState')
         RETURN
      END IF
   END IF
   DstOtherStateData%D_FV = SrcOtherStateData%D_FV
ENDIF
IF (ALLOCATED(SrcOtherStateData%D_FA)) THEN
   i1_l = LBOUND(SrcOtherStateData%D_FA,1)
   i1_u = UBOUND(SrcOtherStateData%D_FA,1)
   i2_l = LBOUND(SrcOtherStateData%D_FA,2)
   i2_u = UBOUND(SrcOtherStateData%D_FA,2)
   IF (.NOT. ALLOCATED(DstOtherStateData%D_FA)) THEN 
      ALLOCATE(DstOtherStateData%D_FA(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOtherStateData%D_FA.', ErrStat, ErrMsg,'Morison_CopyOtherState')
         RETURN
      END IF
   END IF
   DstOtherStateData%D_FA = SrcOtherStateData%D_FA
ENDIF
IF (ALLOCATED(SrcOtherStateData%D_FDynP)) THEN
   i1_l = LBOUND(SrcOtherStateData%D_FDynP,1)
   i1_u = UBOUND(SrcOtherStateData%D_FDynP,1)
   IF (.NOT. ALLOCATED(DstOtherStateData%D_FDynP)) THEN 
      ALLOCATE(DstOtherStateData%D_FDynP(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOtherStateData%D_FDynP.', ErrStat, ErrMsg,'Morison_CopyOtherState')
         RETURN
      END IF
   END IF
   DstOtherStateData%D_FDynP = SrcOtherStateData%D_FDynP
ENDIF
IF (ALLOCATED(SrcOtherStateData%L_F_D)) THEN
   i1_l = LBOUND(SrcOtherStateData%L_F_D,1)
   i1_u = UBOUND(SrcOtherStateData%L_F_D,1)
   i2_l = LBOUND(SrcOtherStateData%L_F_D,2)
   i2_u = UBOUND(SrcOtherStateData%L_F_D,2)
   IF (.NOT. ALLOCATED(DstOtherStateData%L_F_D)) THEN 
      ALLOCATE(DstOtherStateData%L_F_D(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOtherStateData%L_F_D.', ErrStat, ErrMsg,'Morison_CopyOtherState')
         RETURN
      END IF
   END IF
   DstOtherStateData%L_F_D = SrcOtherStateData%L_F_D
ENDIF
IF (ALLOCATED(SrcOtherStateData%L_F_I)) THEN
   i1_l = LBOUND(SrcOtherStateData%L_F_I,1)
   i1_u = UBOUND(SrcOtherStateData%L_F_I,1)
   i2_l = LBOUND(SrcOtherStateData%L_F_I,2)
   i2_u = UBOUND(SrcOtherStateData%L_F_I,2)
   IF (.NOT. ALLOCATED(DstOtherStateData%L_F_I)) THEN 
      ALLOCATE(DstOtherStateData%L_F_I(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOtherStateData%L_F_I.', ErrStat, ErrMsg,'Morison_CopyOtherState')
         RETURN
      END IF
   END IF
   DstOtherStateData%L_F_I = SrcOtherStateData%L_F_I
ENDIF
IF (ALLOCATED(SrcOtherStateData%L_F_DP)) THEN
   i1_l = LBOUND(SrcOtherStateData%L_F_DP,1)
   i1_u = UBOUND(SrcOtherStateData%L_F_DP,1)
   i2_l = LBOUND(SrcOtherStateData%L_F_DP,2)
   i2_u = UBOUND(SrcOtherStateData%L_F_DP,2)
   IF (.NOT. ALLOCATED(DstOtherStateData%L_F_DP)) THEN 
      ALLOCATE(DstOtherStateData%L_F_DP(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOtherStateData%L_F_DP.', ErrStat, ErrMsg,'Morison_CopyOtherState')
         RETURN
      END IF
   END IF
   DstOtherStateData%L_F_DP = SrcOtherStateData%L_F_DP
ENDIF
IF (ALLOCATED(SrcOtherStateData%L_F_AM)) THEN
   i1_l = LBOUND(SrcOtherStateData%L_F_AM,1)
   i1_u = UBOUND(SrcOtherStateData%L_F_AM,1)
   i2_l = LBOUND(SrcOtherStateData%L_F_AM,2)
   i2_u = UBOUND(SrcOtherStateData%L_F_AM,2)
   IF (.NOT. ALLOCATED(DstOtherStateData%L_F_AM)) THEN 
      ALLOCATE(DstOtherStateData%L_F_AM(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOtherStateData%L_F_AM.', ErrStat, ErrMsg,'Morison_CopyOtherState')
         RETURN
      END IF
   END IF
   DstOtherStateData%L_F_AM = SrcOtherStateData%L_F_AM
ENDIF
IF (ALLOCATED(SrcOtherStateData%L_FV)) THEN
   i1_l = LBOUND(SrcOtherStateData%L_FV,1)
   i1_u = UBOUND(SrcOtherStateData%L_FV,1)
   i2_l = LBOUND(SrcOtherStateData%L_FV,2)
   i2_u = UBOUND(SrcOtherStateData%L_FV,2)
   IF (.NOT. ALLOCATED(DstOtherStateData%L_FV)) THEN 
      ALLOCATE(DstOtherStateData%L_FV(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOtherStateData%L_FV.', ErrStat, ErrMsg,'Morison_CopyOtherState')
         RETURN
      END IF
   END IF
   DstOtherStateData%L_FV = SrcOtherStateData%L_FV
ENDIF
IF (ALLOCATED(SrcOtherStateData%L_FA)) THEN
   i1_l = LBOUND(SrcOtherStateData%L_FA,1)
   i1_u = UBOUND(SrcOtherStateData%L_FA,1)
   i2_l = LBOUND(SrcOtherStateData%L_FA,2)
   i2_u = UBOUND(SrcOtherStateData%L_FA,2)
   IF (.NOT. ALLOCATED(DstOtherStateData%L_FA)) THEN 
      ALLOCATE(DstOtherStateData%L_FA(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOtherStateData%L_FA.', ErrStat, ErrMsg,'Morison_CopyOtherState')
         RETURN
      END IF
   END IF
   DstOtherStateData%L_FA = SrcOtherStateData%L_FA
ENDIF
IF (ALLOCATED(SrcOtherStateData%L_FDynP)) THEN
   i1_l = LBOUND(SrcOtherStateData%L_FDynP,1)
   i1_u = UBOUND(SrcOtherStateData%L_FDynP,1)
   IF (.NOT. ALLOCATED(DstOtherStateData%L_FDynP)) THEN 
      ALLOCATE(DstOtherStateData%L_FDynP(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOtherStateData%L_FDynP.', ErrStat, ErrMsg,'Morison_CopyOtherState')
         RETURN
      END IF
   END IF
   DstOtherStateData%L_FDynP = SrcOtherStateData%L_FDynP
ENDIF
   DstOtherStateData%LastIndWave = SrcOtherStateData%LastIndWave
 END SUBROUTINE Morison_CopyOtherState

 SUBROUTINE Morison_DestroyOtherState( OtherStateData, ErrStat, ErrMsg )
  TYPE(Morison_otherstatetype), INTENT(INOUT) :: OtherStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(OtherStateData%D_F_D)) THEN
   DEALLOCATE(OtherStateData%D_F_D)
ENDIF
IF (ALLOCATED(OtherStateData%D_F_I)) THEN
   DEALLOCATE(OtherStateData%D_F_I)
ENDIF
IF (ALLOCATED(OtherStateData%D_F_DP)) THEN
   DEALLOCATE(OtherStateData%D_F_DP)
ENDIF
IF (ALLOCATED(OtherStateData%D_F_AM)) THEN
   DEALLOCATE(OtherStateData%D_F_AM)
ENDIF
IF (ALLOCATED(OtherStateData%D_F_AM_M)) THEN
   DEALLOCATE(OtherStateData%D_F_AM_M)
ENDIF
IF (ALLOCATED(OtherStateData%D_F_AM_MG)) THEN
   DEALLOCATE(OtherStateData%D_F_AM_MG)
ENDIF
IF (ALLOCATED(OtherStateData%D_F_AM_F)) THEN
   DEALLOCATE(OtherStateData%D_F_AM_F)
ENDIF
IF (ALLOCATED(OtherStateData%D_FV)) THEN
   DEALLOCATE(OtherStateData%D_FV)
ENDIF
IF (ALLOCATED(OtherStateData%D_FA)) THEN
   DEALLOCATE(OtherStateData%D_FA)
ENDIF
IF (ALLOCATED(OtherStateData%D_FDynP)) THEN
   DEALLOCATE(OtherStateData%D_FDynP)
ENDIF
IF (ALLOCATED(OtherStateData%L_F_D)) THEN
   DEALLOCATE(OtherStateData%L_F_D)
ENDIF
IF (ALLOCATED(OtherStateData%L_F_I)) THEN
   DEALLOCATE(OtherStateData%L_F_I)
ENDIF
IF (ALLOCATED(OtherStateData%L_F_DP)) THEN
   DEALLOCATE(OtherStateData%L_F_DP)
ENDIF
IF (ALLOCATED(OtherStateData%L_F_AM)) THEN
   DEALLOCATE(OtherStateData%L_F_AM)
ENDIF
IF (ALLOCATED(OtherStateData%L_FV)) THEN
   DEALLOCATE(OtherStateData%L_FV)
ENDIF
IF (ALLOCATED(OtherStateData%L_FA)) THEN
   DEALLOCATE(OtherStateData%L_FA)
ENDIF
IF (ALLOCATED(OtherStateData%L_FDynP)) THEN
   DEALLOCATE(OtherStateData%L_FDynP)
ENDIF
 END SUBROUTINE Morison_DestroyOtherState

 SUBROUTINE Morison_PackOtherState( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(Morison_otherstatetype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  IF ( ALLOCATED(InData%D_F_D) )   Re_BufSz    = Re_BufSz    + SIZE( InData%D_F_D )  ! D_F_D 
  IF ( ALLOCATED(InData%D_F_I) )   Re_BufSz    = Re_BufSz    + SIZE( InData%D_F_I )  ! D_F_I 
  IF ( ALLOCATED(InData%D_F_DP) )   Re_BufSz    = Re_BufSz    + SIZE( InData%D_F_DP )  ! D_F_DP 
  IF ( ALLOCATED(InData%D_F_AM) )   Re_BufSz    = Re_BufSz    + SIZE( InData%D_F_AM )  ! D_F_AM 
  IF ( ALLOCATED(InData%D_F_AM_M) )   Re_BufSz    = Re_BufSz    + SIZE( InData%D_F_AM_M )  ! D_F_AM_M 
  IF ( ALLOCATED(InData%D_F_AM_MG) )   Re_BufSz    = Re_BufSz    + SIZE( InData%D_F_AM_MG )  ! D_F_AM_MG 
  IF ( ALLOCATED(InData%D_F_AM_F) )   Re_BufSz    = Re_BufSz    + SIZE( InData%D_F_AM_F )  ! D_F_AM_F 
  IF ( ALLOCATED(InData%D_FV) )   Re_BufSz    = Re_BufSz    + SIZE( InData%D_FV )  ! D_FV 
  IF ( ALLOCATED(InData%D_FA) )   Re_BufSz    = Re_BufSz    + SIZE( InData%D_FA )  ! D_FA 
  IF ( ALLOCATED(InData%D_FDynP) )   Re_BufSz    = Re_BufSz    + SIZE( InData%D_FDynP )  ! D_FDynP 
  IF ( ALLOCATED(InData%L_F_D) )   Re_BufSz    = Re_BufSz    + SIZE( InData%L_F_D )  ! L_F_D 
  IF ( ALLOCATED(InData%L_F_I) )   Re_BufSz    = Re_BufSz    + SIZE( InData%L_F_I )  ! L_F_I 
  IF ( ALLOCATED(InData%L_F_DP) )   Re_BufSz    = Re_BufSz    + SIZE( InData%L_F_DP )  ! L_F_DP 
  IF ( ALLOCATED(InData%L_F_AM) )   Re_BufSz    = Re_BufSz    + SIZE( InData%L_F_AM )  ! L_F_AM 
  IF ( ALLOCATED(InData%L_FV) )   Re_BufSz    = Re_BufSz    + SIZE( InData%L_FV )  ! L_FV 
  IF ( ALLOCATED(InData%L_FA) )   Re_BufSz    = Re_BufSz    + SIZE( InData%L_FA )  ! L_FA 
  IF ( ALLOCATED(InData%L_FDynP) )   Re_BufSz    = Re_BufSz    + SIZE( InData%L_FDynP )  ! L_FDynP 
  Int_BufSz  = Int_BufSz  + 1  ! LastIndWave
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( ALLOCATED(InData%D_F_D) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%D_F_D))-1 ) =  PACK(InData%D_F_D ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%D_F_D)
  ENDIF
  IF ( ALLOCATED(InData%D_F_I) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%D_F_I))-1 ) =  PACK(InData%D_F_I ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%D_F_I)
  ENDIF
  IF ( ALLOCATED(InData%D_F_DP) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%D_F_DP))-1 ) =  PACK(InData%D_F_DP ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%D_F_DP)
  ENDIF
  IF ( ALLOCATED(InData%D_F_AM) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%D_F_AM))-1 ) =  PACK(InData%D_F_AM ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%D_F_AM)
  ENDIF
  IF ( ALLOCATED(InData%D_F_AM_M) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%D_F_AM_M))-1 ) =  PACK(InData%D_F_AM_M ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%D_F_AM_M)
  ENDIF
  IF ( ALLOCATED(InData%D_F_AM_MG) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%D_F_AM_MG))-1 ) =  PACK(InData%D_F_AM_MG ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%D_F_AM_MG)
  ENDIF
  IF ( ALLOCATED(InData%D_F_AM_F) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%D_F_AM_F))-1 ) =  PACK(InData%D_F_AM_F ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%D_F_AM_F)
  ENDIF
  IF ( ALLOCATED(InData%D_FV) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%D_FV))-1 ) =  PACK(InData%D_FV ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%D_FV)
  ENDIF
  IF ( ALLOCATED(InData%D_FA) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%D_FA))-1 ) =  PACK(InData%D_FA ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%D_FA)
  ENDIF
  IF ( ALLOCATED(InData%D_FDynP) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%D_FDynP))-1 ) =  PACK(InData%D_FDynP ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%D_FDynP)
  ENDIF
  IF ( ALLOCATED(InData%L_F_D) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%L_F_D))-1 ) =  PACK(InData%L_F_D ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%L_F_D)
  ENDIF
  IF ( ALLOCATED(InData%L_F_I) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%L_F_I))-1 ) =  PACK(InData%L_F_I ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%L_F_I)
  ENDIF
  IF ( ALLOCATED(InData%L_F_DP) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%L_F_DP))-1 ) =  PACK(InData%L_F_DP ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%L_F_DP)
  ENDIF
  IF ( ALLOCATED(InData%L_F_AM) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%L_F_AM))-1 ) =  PACK(InData%L_F_AM ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%L_F_AM)
  ENDIF
  IF ( ALLOCATED(InData%L_FV) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%L_FV))-1 ) =  PACK(InData%L_FV ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%L_FV)
  ENDIF
  IF ( ALLOCATED(InData%L_FA) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%L_FA))-1 ) =  PACK(InData%L_FA ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%L_FA)
  ENDIF
  IF ( ALLOCATED(InData%L_FDynP) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%L_FDynP))-1 ) =  PACK(InData%L_FDynP ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%L_FDynP)
  ENDIF
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%LastIndWave )
  Int_Xferred   = Int_Xferred   + 1
 END SUBROUTINE Morison_PackOtherState

 SUBROUTINE Morison_UnPackOtherState( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(Morison_otherstatetype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  IF ( ALLOCATED(OutData%D_F_D) ) THEN
  ALLOCATE(mask2(SIZE(OutData%D_F_D,1),SIZE(OutData%D_F_D,2))); mask2 = .TRUE.
    OutData%D_F_D = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%D_F_D))-1 ),mask2,OutData%D_F_D)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%D_F_D)
  ENDIF
  IF ( ALLOCATED(OutData%D_F_I) ) THEN
  ALLOCATE(mask2(SIZE(OutData%D_F_I,1),SIZE(OutData%D_F_I,2))); mask2 = .TRUE.
    OutData%D_F_I = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%D_F_I))-1 ),mask2,OutData%D_F_I)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%D_F_I)
  ENDIF
  IF ( ALLOCATED(OutData%D_F_DP) ) THEN
  ALLOCATE(mask2(SIZE(OutData%D_F_DP,1),SIZE(OutData%D_F_DP,2))); mask2 = .TRUE.
    OutData%D_F_DP = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%D_F_DP))-1 ),mask2,OutData%D_F_DP)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%D_F_DP)
  ENDIF
  IF ( ALLOCATED(OutData%D_F_AM) ) THEN
  ALLOCATE(mask2(SIZE(OutData%D_F_AM,1),SIZE(OutData%D_F_AM,2))); mask2 = .TRUE.
    OutData%D_F_AM = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%D_F_AM))-1 ),mask2,OutData%D_F_AM)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%D_F_AM)
  ENDIF
  IF ( ALLOCATED(OutData%D_F_AM_M) ) THEN
  ALLOCATE(mask2(SIZE(OutData%D_F_AM_M,1),SIZE(OutData%D_F_AM_M,2))); mask2 = .TRUE.
    OutData%D_F_AM_M = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%D_F_AM_M))-1 ),mask2,OutData%D_F_AM_M)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%D_F_AM_M)
  ENDIF
  IF ( ALLOCATED(OutData%D_F_AM_MG) ) THEN
  ALLOCATE(mask2(SIZE(OutData%D_F_AM_MG,1),SIZE(OutData%D_F_AM_MG,2))); mask2 = .TRUE.
    OutData%D_F_AM_MG = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%D_F_AM_MG))-1 ),mask2,OutData%D_F_AM_MG)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%D_F_AM_MG)
  ENDIF
  IF ( ALLOCATED(OutData%D_F_AM_F) ) THEN
  ALLOCATE(mask2(SIZE(OutData%D_F_AM_F,1),SIZE(OutData%D_F_AM_F,2))); mask2 = .TRUE.
    OutData%D_F_AM_F = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%D_F_AM_F))-1 ),mask2,OutData%D_F_AM_F)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%D_F_AM_F)
  ENDIF
  IF ( ALLOCATED(OutData%D_FV) ) THEN
  ALLOCATE(mask2(SIZE(OutData%D_FV,1),SIZE(OutData%D_FV,2))); mask2 = .TRUE.
    OutData%D_FV = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%D_FV))-1 ),mask2,OutData%D_FV)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%D_FV)
  ENDIF
  IF ( ALLOCATED(OutData%D_FA) ) THEN
  ALLOCATE(mask2(SIZE(OutData%D_FA,1),SIZE(OutData%D_FA,2))); mask2 = .TRUE.
    OutData%D_FA = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%D_FA))-1 ),mask2,OutData%D_FA)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%D_FA)
  ENDIF
  IF ( ALLOCATED(OutData%D_FDynP) ) THEN
  ALLOCATE(mask1(SIZE(OutData%D_FDynP,1))); mask1 = .TRUE.
    OutData%D_FDynP = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%D_FDynP))-1 ),mask1,OutData%D_FDynP)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%D_FDynP)
  ENDIF
  IF ( ALLOCATED(OutData%L_F_D) ) THEN
  ALLOCATE(mask2(SIZE(OutData%L_F_D,1),SIZE(OutData%L_F_D,2))); mask2 = .TRUE.
    OutData%L_F_D = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%L_F_D))-1 ),mask2,OutData%L_F_D)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%L_F_D)
  ENDIF
  IF ( ALLOCATED(OutData%L_F_I) ) THEN
  ALLOCATE(mask2(SIZE(OutData%L_F_I,1),SIZE(OutData%L_F_I,2))); mask2 = .TRUE.
    OutData%L_F_I = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%L_F_I))-1 ),mask2,OutData%L_F_I)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%L_F_I)
  ENDIF
  IF ( ALLOCATED(OutData%L_F_DP) ) THEN
  ALLOCATE(mask2(SIZE(OutData%L_F_DP,1),SIZE(OutData%L_F_DP,2))); mask2 = .TRUE.
    OutData%L_F_DP = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%L_F_DP))-1 ),mask2,OutData%L_F_DP)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%L_F_DP)
  ENDIF
  IF ( ALLOCATED(OutData%L_F_AM) ) THEN
  ALLOCATE(mask2(SIZE(OutData%L_F_AM,1),SIZE(OutData%L_F_AM,2))); mask2 = .TRUE.
    OutData%L_F_AM = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%L_F_AM))-1 ),mask2,OutData%L_F_AM)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%L_F_AM)
  ENDIF
  IF ( ALLOCATED(OutData%L_FV) ) THEN
  ALLOCATE(mask2(SIZE(OutData%L_FV,1),SIZE(OutData%L_FV,2))); mask2 = .TRUE.
    OutData%L_FV = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%L_FV))-1 ),mask2,OutData%L_FV)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%L_FV)
  ENDIF
  IF ( ALLOCATED(OutData%L_FA) ) THEN
  ALLOCATE(mask2(SIZE(OutData%L_FA,1),SIZE(OutData%L_FA,2))); mask2 = .TRUE.
    OutData%L_FA = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%L_FA))-1 ),mask2,OutData%L_FA)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%L_FA)
  ENDIF
  IF ( ALLOCATED(OutData%L_FDynP) ) THEN
  ALLOCATE(mask1(SIZE(OutData%L_FDynP,1))); mask1 = .TRUE.
    OutData%L_FDynP = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%L_FDynP))-1 ),mask1,OutData%L_FDynP)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%L_FDynP)
  ENDIF
  OutData%LastIndWave = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE Morison_UnPackOtherState

 SUBROUTINE Morison_CopyParam( SrcParamData, DstParamData, CtrlCode, ErrStat, ErrMsg )
   TYPE(Morison_parametertype), INTENT(INOUT) :: SrcParamData
   TYPE(Morison_parametertype), INTENT(INOUT) :: DstParamData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
   DstParamData%DT = SrcParamData%DT
   DstParamData%WtrDens = SrcParamData%WtrDens
   DstParamData%NNodes = SrcParamData%NNodes
IF (ALLOCATED(SrcParamData%Nodes)) THEN
   i1_l = LBOUND(SrcParamData%Nodes,1)
   i1_u = UBOUND(SrcParamData%Nodes,1)
   IF (.NOT. ALLOCATED(DstParamData%Nodes)) THEN 
      ALLOCATE(DstParamData%Nodes(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%Nodes.', ErrStat, ErrMsg,'Morison_CopyParam')
         RETURN
      END IF
   END IF
   DO i1 = LBOUND(SrcParamData%Nodes,1), UBOUND(SrcParamData%Nodes,1)
      CALL Morison_Copynodetype( SrcParamData%Nodes(i1), DstParamData%Nodes(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'Morison_CopyParam:Nodes(i1)')
         IF (ErrStat>=AbortErrLev) RETURN
   ENDDO
ENDIF
IF (ALLOCATED(SrcParamData%D_F_I)) THEN
   i1_l = LBOUND(SrcParamData%D_F_I,1)
   i1_u = UBOUND(SrcParamData%D_F_I,1)
   i2_l = LBOUND(SrcParamData%D_F_I,2)
   i2_u = UBOUND(SrcParamData%D_F_I,2)
   i3_l = LBOUND(SrcParamData%D_F_I,3)
   i3_u = UBOUND(SrcParamData%D_F_I,3)
   IF (.NOT. ALLOCATED(DstParamData%D_F_I)) THEN 
      ALLOCATE(DstParamData%D_F_I(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%D_F_I.', ErrStat, ErrMsg,'Morison_CopyParam')
         RETURN
      END IF
   END IF
   DstParamData%D_F_I = SrcParamData%D_F_I
ENDIF
IF (ALLOCATED(SrcParamData%D_F_B)) THEN
   i1_l = LBOUND(SrcParamData%D_F_B,1)
   i1_u = UBOUND(SrcParamData%D_F_B,1)
   i2_l = LBOUND(SrcParamData%D_F_B,2)
   i2_u = UBOUND(SrcParamData%D_F_B,2)
   IF (.NOT. ALLOCATED(DstParamData%D_F_B)) THEN 
      ALLOCATE(DstParamData%D_F_B(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%D_F_B.', ErrStat, ErrMsg,'Morison_CopyParam')
         RETURN
      END IF
   END IF
   DstParamData%D_F_B = SrcParamData%D_F_B
ENDIF
IF (ALLOCATED(SrcParamData%D_F_DP)) THEN
   i1_l = LBOUND(SrcParamData%D_F_DP,1)
   i1_u = UBOUND(SrcParamData%D_F_DP,1)
   i2_l = LBOUND(SrcParamData%D_F_DP,2)
   i2_u = UBOUND(SrcParamData%D_F_DP,2)
   i3_l = LBOUND(SrcParamData%D_F_DP,3)
   i3_u = UBOUND(SrcParamData%D_F_DP,3)
   IF (.NOT. ALLOCATED(DstParamData%D_F_DP)) THEN 
      ALLOCATE(DstParamData%D_F_DP(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%D_F_DP.', ErrStat, ErrMsg,'Morison_CopyParam')
         RETURN
      END IF
   END IF
   DstParamData%D_F_DP = SrcParamData%D_F_DP
ENDIF
IF (ALLOCATED(SrcParamData%D_F_MG)) THEN
   i1_l = LBOUND(SrcParamData%D_F_MG,1)
   i1_u = UBOUND(SrcParamData%D_F_MG,1)
   i2_l = LBOUND(SrcParamData%D_F_MG,2)
   i2_u = UBOUND(SrcParamData%D_F_MG,2)
   IF (.NOT. ALLOCATED(DstParamData%D_F_MG)) THEN 
      ALLOCATE(DstParamData%D_F_MG(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%D_F_MG.', ErrStat, ErrMsg,'Morison_CopyParam')
         RETURN
      END IF
   END IF
   DstParamData%D_F_MG = SrcParamData%D_F_MG
ENDIF
IF (ALLOCATED(SrcParamData%D_F_BF)) THEN
   i1_l = LBOUND(SrcParamData%D_F_BF,1)
   i1_u = UBOUND(SrcParamData%D_F_BF,1)
   i2_l = LBOUND(SrcParamData%D_F_BF,2)
   i2_u = UBOUND(SrcParamData%D_F_BF,2)
   IF (.NOT. ALLOCATED(DstParamData%D_F_BF)) THEN 
      ALLOCATE(DstParamData%D_F_BF(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%D_F_BF.', ErrStat, ErrMsg,'Morison_CopyParam')
         RETURN
      END IF
   END IF
   DstParamData%D_F_BF = SrcParamData%D_F_BF
ENDIF
IF (ALLOCATED(SrcParamData%D_AM_M)) THEN
   i1_l = LBOUND(SrcParamData%D_AM_M,1)
   i1_u = UBOUND(SrcParamData%D_AM_M,1)
   i2_l = LBOUND(SrcParamData%D_AM_M,2)
   i2_u = UBOUND(SrcParamData%D_AM_M,2)
   i3_l = LBOUND(SrcParamData%D_AM_M,3)
   i3_u = UBOUND(SrcParamData%D_AM_M,3)
   IF (.NOT. ALLOCATED(DstParamData%D_AM_M)) THEN 
      ALLOCATE(DstParamData%D_AM_M(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%D_AM_M.', ErrStat, ErrMsg,'Morison_CopyParam')
         RETURN
      END IF
   END IF
   DstParamData%D_AM_M = SrcParamData%D_AM_M
ENDIF
IF (ALLOCATED(SrcParamData%D_AM_MG)) THEN
   i1_l = LBOUND(SrcParamData%D_AM_MG,1)
   i1_u = UBOUND(SrcParamData%D_AM_MG,1)
   i2_l = LBOUND(SrcParamData%D_AM_MG,2)
   i2_u = UBOUND(SrcParamData%D_AM_MG,2)
   i3_l = LBOUND(SrcParamData%D_AM_MG,3)
   i3_u = UBOUND(SrcParamData%D_AM_MG,3)
   IF (.NOT. ALLOCATED(DstParamData%D_AM_MG)) THEN 
      ALLOCATE(DstParamData%D_AM_MG(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%D_AM_MG.', ErrStat, ErrMsg,'Morison_CopyParam')
         RETURN
      END IF
   END IF
   DstParamData%D_AM_MG = SrcParamData%D_AM_MG
ENDIF
IF (ALLOCATED(SrcParamData%D_AM_F)) THEN
   i1_l = LBOUND(SrcParamData%D_AM_F,1)
   i1_u = UBOUND(SrcParamData%D_AM_F,1)
   i2_l = LBOUND(SrcParamData%D_AM_F,2)
   i2_u = UBOUND(SrcParamData%D_AM_F,2)
   i3_l = LBOUND(SrcParamData%D_AM_F,3)
   i3_u = UBOUND(SrcParamData%D_AM_F,3)
   IF (.NOT. ALLOCATED(DstParamData%D_AM_F)) THEN 
      ALLOCATE(DstParamData%D_AM_F(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%D_AM_F.', ErrStat, ErrMsg,'Morison_CopyParam')
         RETURN
      END IF
   END IF
   DstParamData%D_AM_F = SrcParamData%D_AM_F
ENDIF
IF (ALLOCATED(SrcParamData%D_dragConst)) THEN
   i1_l = LBOUND(SrcParamData%D_dragConst,1)
   i1_u = UBOUND(SrcParamData%D_dragConst,1)
   IF (.NOT. ALLOCATED(DstParamData%D_dragConst)) THEN 
      ALLOCATE(DstParamData%D_dragConst(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%D_dragConst.', ErrStat, ErrMsg,'Morison_CopyParam')
         RETURN
      END IF
   END IF
   DstParamData%D_dragConst = SrcParamData%D_dragConst
ENDIF
IF (ALLOCATED(SrcParamData%L_An)) THEN
   i1_l = LBOUND(SrcParamData%L_An,1)
   i1_u = UBOUND(SrcParamData%L_An,1)
   i2_l = LBOUND(SrcParamData%L_An,2)
   i2_u = UBOUND(SrcParamData%L_An,2)
   IF (.NOT. ALLOCATED(DstParamData%L_An)) THEN 
      ALLOCATE(DstParamData%L_An(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%L_An.', ErrStat, ErrMsg,'Morison_CopyParam')
         RETURN
      END IF
   END IF
   DstParamData%L_An = SrcParamData%L_An
ENDIF
IF (ALLOCATED(SrcParamData%L_F_B)) THEN
   i1_l = LBOUND(SrcParamData%L_F_B,1)
   i1_u = UBOUND(SrcParamData%L_F_B,1)
   i2_l = LBOUND(SrcParamData%L_F_B,2)
   i2_u = UBOUND(SrcParamData%L_F_B,2)
   IF (.NOT. ALLOCATED(DstParamData%L_F_B)) THEN 
      ALLOCATE(DstParamData%L_F_B(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%L_F_B.', ErrStat, ErrMsg,'Morison_CopyParam')
         RETURN
      END IF
   END IF
   DstParamData%L_F_B = SrcParamData%L_F_B
ENDIF
IF (ALLOCATED(SrcParamData%L_F_I)) THEN
   i1_l = LBOUND(SrcParamData%L_F_I,1)
   i1_u = UBOUND(SrcParamData%L_F_I,1)
   i2_l = LBOUND(SrcParamData%L_F_I,2)
   i2_u = UBOUND(SrcParamData%L_F_I,2)
   i3_l = LBOUND(SrcParamData%L_F_I,3)
   i3_u = UBOUND(SrcParamData%L_F_I,3)
   IF (.NOT. ALLOCATED(DstParamData%L_F_I)) THEN 
      ALLOCATE(DstParamData%L_F_I(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%L_F_I.', ErrStat, ErrMsg,'Morison_CopyParam')
         RETURN
      END IF
   END IF
   DstParamData%L_F_I = SrcParamData%L_F_I
ENDIF
IF (ALLOCATED(SrcParamData%L_F_DP)) THEN
   i1_l = LBOUND(SrcParamData%L_F_DP,1)
   i1_u = UBOUND(SrcParamData%L_F_DP,1)
   i2_l = LBOUND(SrcParamData%L_F_DP,2)
   i2_u = UBOUND(SrcParamData%L_F_DP,2)
   i3_l = LBOUND(SrcParamData%L_F_DP,3)
   i3_u = UBOUND(SrcParamData%L_F_DP,3)
   IF (.NOT. ALLOCATED(DstParamData%L_F_DP)) THEN 
      ALLOCATE(DstParamData%L_F_DP(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%L_F_DP.', ErrStat, ErrMsg,'Morison_CopyParam')
         RETURN
      END IF
   END IF
   DstParamData%L_F_DP = SrcParamData%L_F_DP
ENDIF
IF (ALLOCATED(SrcParamData%L_F_BF)) THEN
   i1_l = LBOUND(SrcParamData%L_F_BF,1)
   i1_u = UBOUND(SrcParamData%L_F_BF,1)
   i2_l = LBOUND(SrcParamData%L_F_BF,2)
   i2_u = UBOUND(SrcParamData%L_F_BF,2)
   IF (.NOT. ALLOCATED(DstParamData%L_F_BF)) THEN 
      ALLOCATE(DstParamData%L_F_BF(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%L_F_BF.', ErrStat, ErrMsg,'Morison_CopyParam')
         RETURN
      END IF
   END IF
   DstParamData%L_F_BF = SrcParamData%L_F_BF
ENDIF
IF (ALLOCATED(SrcParamData%L_AM_M)) THEN
   i1_l = LBOUND(SrcParamData%L_AM_M,1)
   i1_u = UBOUND(SrcParamData%L_AM_M,1)
   i2_l = LBOUND(SrcParamData%L_AM_M,2)
   i2_u = UBOUND(SrcParamData%L_AM_M,2)
   i3_l = LBOUND(SrcParamData%L_AM_M,3)
   i3_u = UBOUND(SrcParamData%L_AM_M,3)
   IF (.NOT. ALLOCATED(DstParamData%L_AM_M)) THEN 
      ALLOCATE(DstParamData%L_AM_M(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%L_AM_M.', ErrStat, ErrMsg,'Morison_CopyParam')
         RETURN
      END IF
   END IF
   DstParamData%L_AM_M = SrcParamData%L_AM_M
ENDIF
IF (ALLOCATED(SrcParamData%L_dragConst)) THEN
   i1_l = LBOUND(SrcParamData%L_dragConst,1)
   i1_u = UBOUND(SrcParamData%L_dragConst,1)
   IF (.NOT. ALLOCATED(DstParamData%L_dragConst)) THEN 
      ALLOCATE(DstParamData%L_dragConst(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%L_dragConst.', ErrStat, ErrMsg,'Morison_CopyParam')
         RETURN
      END IF
   END IF
   DstParamData%L_dragConst = SrcParamData%L_dragConst
ENDIF
   DstParamData%NDistribMarkers = SrcParamData%NDistribMarkers
IF (ALLOCATED(SrcParamData%distribToNodeIndx)) THEN
   i1_l = LBOUND(SrcParamData%distribToNodeIndx,1)
   i1_u = UBOUND(SrcParamData%distribToNodeIndx,1)
   IF (.NOT. ALLOCATED(DstParamData%distribToNodeIndx)) THEN 
      ALLOCATE(DstParamData%distribToNodeIndx(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%distribToNodeIndx.', ErrStat, ErrMsg,'Morison_CopyParam')
         RETURN
      END IF
   END IF
   DstParamData%distribToNodeIndx = SrcParamData%distribToNodeIndx
ENDIF
   DstParamData%NLumpedMarkers = SrcParamData%NLumpedMarkers
IF (ALLOCATED(SrcParamData%lumpedToNodeIndx)) THEN
   i1_l = LBOUND(SrcParamData%lumpedToNodeIndx,1)
   i1_u = UBOUND(SrcParamData%lumpedToNodeIndx,1)
   IF (.NOT. ALLOCATED(DstParamData%lumpedToNodeIndx)) THEN 
      ALLOCATE(DstParamData%lumpedToNodeIndx(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%lumpedToNodeIndx.', ErrStat, ErrMsg,'Morison_CopyParam')
         RETURN
      END IF
   END IF
   DstParamData%lumpedToNodeIndx = SrcParamData%lumpedToNodeIndx
ENDIF
IF (ALLOCATED(SrcParamData%WaveVel0)) THEN
   i1_l = LBOUND(SrcParamData%WaveVel0,1)
   i1_u = UBOUND(SrcParamData%WaveVel0,1)
   i2_l = LBOUND(SrcParamData%WaveVel0,2)
   i2_u = UBOUND(SrcParamData%WaveVel0,2)
   i3_l = LBOUND(SrcParamData%WaveVel0,3)
   i3_u = UBOUND(SrcParamData%WaveVel0,3)
   IF (.NOT. ALLOCATED(DstParamData%WaveVel0)) THEN 
      ALLOCATE(DstParamData%WaveVel0(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%WaveVel0.', ErrStat, ErrMsg,'Morison_CopyParam')
         RETURN
      END IF
   END IF
   DstParamData%WaveVel0 = SrcParamData%WaveVel0
ENDIF
IF (ALLOCATED(SrcParamData%WaveAcc0)) THEN
   i1_l = LBOUND(SrcParamData%WaveAcc0,1)
   i1_u = UBOUND(SrcParamData%WaveAcc0,1)
   i2_l = LBOUND(SrcParamData%WaveAcc0,2)
   i2_u = UBOUND(SrcParamData%WaveAcc0,2)
   i3_l = LBOUND(SrcParamData%WaveAcc0,3)
   i3_u = UBOUND(SrcParamData%WaveAcc0,3)
   IF (.NOT. ALLOCATED(DstParamData%WaveAcc0)) THEN 
      ALLOCATE(DstParamData%WaveAcc0(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%WaveAcc0.', ErrStat, ErrMsg,'Morison_CopyParam')
         RETURN
      END IF
   END IF
   DstParamData%WaveAcc0 = SrcParamData%WaveAcc0
ENDIF
IF (ALLOCATED(SrcParamData%WaveDynP0)) THEN
   i1_l = LBOUND(SrcParamData%WaveDynP0,1)
   i1_u = UBOUND(SrcParamData%WaveDynP0,1)
   i2_l = LBOUND(SrcParamData%WaveDynP0,2)
   i2_u = UBOUND(SrcParamData%WaveDynP0,2)
   IF (.NOT. ALLOCATED(DstParamData%WaveDynP0)) THEN 
      ALLOCATE(DstParamData%WaveDynP0(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%WaveDynP0.', ErrStat, ErrMsg,'Morison_CopyParam')
         RETURN
      END IF
   END IF
   DstParamData%WaveDynP0 = SrcParamData%WaveDynP0
ENDIF
IF (ALLOCATED(SrcParamData%WaveTime)) THEN
   i1_l = LBOUND(SrcParamData%WaveTime,1)
   i1_u = UBOUND(SrcParamData%WaveTime,1)
   IF (.NOT. ALLOCATED(DstParamData%WaveTime)) THEN 
      ALLOCATE(DstParamData%WaveTime(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%WaveTime.', ErrStat, ErrMsg,'Morison_CopyParam')
         RETURN
      END IF
   END IF
   DstParamData%WaveTime = SrcParamData%WaveTime
ENDIF
   DstParamData%NStepWave = SrcParamData%NStepWave
   DstParamData%NMOutputs = SrcParamData%NMOutputs
IF (ALLOCATED(SrcParamData%MOutLst)) THEN
   i1_l = LBOUND(SrcParamData%MOutLst,1)
   i1_u = UBOUND(SrcParamData%MOutLst,1)
   IF (.NOT. ALLOCATED(DstParamData%MOutLst)) THEN 
      ALLOCATE(DstParamData%MOutLst(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%MOutLst.', ErrStat, ErrMsg,'Morison_CopyParam')
         RETURN
      END IF
   END IF
   DO i1 = LBOUND(SrcParamData%MOutLst,1), UBOUND(SrcParamData%MOutLst,1)
      CALL Morison_Copymoutput( SrcParamData%MOutLst(i1), DstParamData%MOutLst(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'Morison_CopyParam:MOutLst(i1)')
         IF (ErrStat>=AbortErrLev) RETURN
   ENDDO
ENDIF
   DstParamData%NJOutputs = SrcParamData%NJOutputs
IF (ALLOCATED(SrcParamData%JOutLst)) THEN
   i1_l = LBOUND(SrcParamData%JOutLst,1)
   i1_u = UBOUND(SrcParamData%JOutLst,1)
   IF (.NOT. ALLOCATED(DstParamData%JOutLst)) THEN 
      ALLOCATE(DstParamData%JOutLst(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%JOutLst.', ErrStat, ErrMsg,'Morison_CopyParam')
         RETURN
      END IF
   END IF
   DO i1 = LBOUND(SrcParamData%JOutLst,1), UBOUND(SrcParamData%JOutLst,1)
      CALL Morison_Copyjoutput( SrcParamData%JOutLst(i1), DstParamData%JOutLst(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'Morison_CopyParam:JOutLst(i1)')
         IF (ErrStat>=AbortErrLev) RETURN
   ENDDO
ENDIF
IF (ALLOCATED(SrcParamData%OutParam)) THEN
   i1_l = LBOUND(SrcParamData%OutParam,1)
   i1_u = UBOUND(SrcParamData%OutParam,1)
   IF (.NOT. ALLOCATED(DstParamData%OutParam)) THEN 
      ALLOCATE(DstParamData%OutParam(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%OutParam.', ErrStat, ErrMsg,'Morison_CopyParam')
         RETURN
      END IF
   END IF
   DO i1 = LBOUND(SrcParamData%OutParam,1), UBOUND(SrcParamData%OutParam,1)
      CALL NWTC_Library_Copyoutparmtype( SrcParamData%OutParam(i1), DstParamData%OutParam(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'Morison_CopyParam:OutParam(i1)')
         IF (ErrStat>=AbortErrLev) RETURN
   ENDDO
ENDIF
   DstParamData%NumOuts = SrcParamData%NumOuts
   DstParamData%NumOutAll = SrcParamData%NumOutAll
   DstParamData%OutSwtch = SrcParamData%OutSwtch
   DstParamData%UnOutFile = SrcParamData%UnOutFile
   DstParamData%OutFmt = SrcParamData%OutFmt
   DstParamData%OutSFmt = SrcParamData%OutSFmt
   DstParamData%Delim = SrcParamData%Delim
 END SUBROUTINE Morison_CopyParam

 SUBROUTINE Morison_DestroyParam( ParamData, ErrStat, ErrMsg )
  TYPE(Morison_parametertype), INTENT(INOUT) :: ParamData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(ParamData%Nodes)) THEN
DO i1 = LBOUND(ParamData%Nodes,1), UBOUND(ParamData%Nodes,1)
  CALL Morison_Destroynodetype( ParamData%Nodes(i1), ErrStat, ErrMsg )
ENDDO
   DEALLOCATE(ParamData%Nodes)
ENDIF
IF (ALLOCATED(ParamData%D_F_I)) THEN
   DEALLOCATE(ParamData%D_F_I)
ENDIF
IF (ALLOCATED(ParamData%D_F_B)) THEN
   DEALLOCATE(ParamData%D_F_B)
ENDIF
IF (ALLOCATED(ParamData%D_F_DP)) THEN
   DEALLOCATE(ParamData%D_F_DP)
ENDIF
IF (ALLOCATED(ParamData%D_F_MG)) THEN
   DEALLOCATE(ParamData%D_F_MG)
ENDIF
IF (ALLOCATED(ParamData%D_F_BF)) THEN
   DEALLOCATE(ParamData%D_F_BF)
ENDIF
IF (ALLOCATED(ParamData%D_AM_M)) THEN
   DEALLOCATE(ParamData%D_AM_M)
ENDIF
IF (ALLOCATED(ParamData%D_AM_MG)) THEN
   DEALLOCATE(ParamData%D_AM_MG)
ENDIF
IF (ALLOCATED(ParamData%D_AM_F)) THEN
   DEALLOCATE(ParamData%D_AM_F)
ENDIF
IF (ALLOCATED(ParamData%D_dragConst)) THEN
   DEALLOCATE(ParamData%D_dragConst)
ENDIF
IF (ALLOCATED(ParamData%L_An)) THEN
   DEALLOCATE(ParamData%L_An)
ENDIF
IF (ALLOCATED(ParamData%L_F_B)) THEN
   DEALLOCATE(ParamData%L_F_B)
ENDIF
IF (ALLOCATED(ParamData%L_F_I)) THEN
   DEALLOCATE(ParamData%L_F_I)
ENDIF
IF (ALLOCATED(ParamData%L_F_DP)) THEN
   DEALLOCATE(ParamData%L_F_DP)
ENDIF
IF (ALLOCATED(ParamData%L_F_BF)) THEN
   DEALLOCATE(ParamData%L_F_BF)
ENDIF
IF (ALLOCATED(ParamData%L_AM_M)) THEN
   DEALLOCATE(ParamData%L_AM_M)
ENDIF
IF (ALLOCATED(ParamData%L_dragConst)) THEN
   DEALLOCATE(ParamData%L_dragConst)
ENDIF
IF (ALLOCATED(ParamData%distribToNodeIndx)) THEN
   DEALLOCATE(ParamData%distribToNodeIndx)
ENDIF
IF (ALLOCATED(ParamData%lumpedToNodeIndx)) THEN
   DEALLOCATE(ParamData%lumpedToNodeIndx)
ENDIF
IF (ALLOCATED(ParamData%WaveVel0)) THEN
   DEALLOCATE(ParamData%WaveVel0)
ENDIF
IF (ALLOCATED(ParamData%WaveAcc0)) THEN
   DEALLOCATE(ParamData%WaveAcc0)
ENDIF
IF (ALLOCATED(ParamData%WaveDynP0)) THEN
   DEALLOCATE(ParamData%WaveDynP0)
ENDIF
IF (ALLOCATED(ParamData%WaveTime)) THEN
   DEALLOCATE(ParamData%WaveTime)
ENDIF
IF (ALLOCATED(ParamData%MOutLst)) THEN
DO i1 = LBOUND(ParamData%MOutLst,1), UBOUND(ParamData%MOutLst,1)
  CALL Morison_Destroymoutput( ParamData%MOutLst(i1), ErrStat, ErrMsg )
ENDDO
   DEALLOCATE(ParamData%MOutLst)
ENDIF
IF (ALLOCATED(ParamData%JOutLst)) THEN
DO i1 = LBOUND(ParamData%JOutLst,1), UBOUND(ParamData%JOutLst,1)
  CALL Morison_Destroyjoutput( ParamData%JOutLst(i1), ErrStat, ErrMsg )
ENDDO
   DEALLOCATE(ParamData%JOutLst)
ENDIF
IF (ALLOCATED(ParamData%OutParam)) THEN
DO i1 = LBOUND(ParamData%OutParam,1), UBOUND(ParamData%OutParam,1)
  CALL NWTC_Library_Destroyoutparmtype( ParamData%OutParam(i1), ErrStat, ErrMsg )
ENDDO
   DEALLOCATE(ParamData%OutParam)
ENDIF
 END SUBROUTINE Morison_DestroyParam

 SUBROUTINE Morison_PackParam( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(Morison_parametertype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_Nodes_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_Nodes_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_Nodes_Buf(:)
  REAL(ReKi),     ALLOCATABLE :: Re_MOutLst_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_MOutLst_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_MOutLst_Buf(:)
  REAL(ReKi),     ALLOCATABLE :: Re_JOutLst_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_JOutLst_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_JOutLst_Buf(:)
  REAL(ReKi),     ALLOCATABLE :: Re_OutParam_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_OutParam_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_OutParam_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Db_BufSz   = Db_BufSz   + 1  ! DT
  Re_BufSz   = Re_BufSz   + 1  ! WtrDens
  Int_BufSz  = Int_BufSz  + 1  ! NNodes
DO i1 = LBOUND(InData%Nodes,1), UBOUND(InData%Nodes,1)
  CALL Morison_Packnodetype( Re_Nodes_Buf, Db_Nodes_Buf, Int_Nodes_Buf, InData%Nodes(i1), ErrStat, ErrMsg, .TRUE. ) ! Nodes 
  IF(ALLOCATED(Re_Nodes_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_Nodes_Buf  ) ! Nodes
  IF(ALLOCATED(Db_Nodes_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_Nodes_Buf  ) ! Nodes
  IF(ALLOCATED(Int_Nodes_Buf))Int_BufSz = Int_BufSz + SIZE( Int_Nodes_Buf ) ! Nodes
  IF(ALLOCATED(Re_Nodes_Buf))  DEALLOCATE(Re_Nodes_Buf)
  IF(ALLOCATED(Db_Nodes_Buf))  DEALLOCATE(Db_Nodes_Buf)
  IF(ALLOCATED(Int_Nodes_Buf)) DEALLOCATE(Int_Nodes_Buf)
ENDDO
  IF ( ALLOCATED(InData%D_F_I) )   Re_BufSz    = Re_BufSz    + SIZE( InData%D_F_I )  ! D_F_I 
  IF ( ALLOCATED(InData%D_F_B) )   Re_BufSz    = Re_BufSz    + SIZE( InData%D_F_B )  ! D_F_B 
  IF ( ALLOCATED(InData%D_F_DP) )   Re_BufSz    = Re_BufSz    + SIZE( InData%D_F_DP )  ! D_F_DP 
  IF ( ALLOCATED(InData%D_F_MG) )   Re_BufSz    = Re_BufSz    + SIZE( InData%D_F_MG )  ! D_F_MG 
  IF ( ALLOCATED(InData%D_F_BF) )   Re_BufSz    = Re_BufSz    + SIZE( InData%D_F_BF )  ! D_F_BF 
  IF ( ALLOCATED(InData%D_AM_M) )   Re_BufSz    = Re_BufSz    + SIZE( InData%D_AM_M )  ! D_AM_M 
  IF ( ALLOCATED(InData%D_AM_MG) )   Re_BufSz    = Re_BufSz    + SIZE( InData%D_AM_MG )  ! D_AM_MG 
  IF ( ALLOCATED(InData%D_AM_F) )   Re_BufSz    = Re_BufSz    + SIZE( InData%D_AM_F )  ! D_AM_F 
  IF ( ALLOCATED(InData%D_dragConst) )   Re_BufSz    = Re_BufSz    + SIZE( InData%D_dragConst )  ! D_dragConst 
  IF ( ALLOCATED(InData%L_An) )   Re_BufSz    = Re_BufSz    + SIZE( InData%L_An )  ! L_An 
  IF ( ALLOCATED(InData%L_F_B) )   Re_BufSz    = Re_BufSz    + SIZE( InData%L_F_B )  ! L_F_B 
  IF ( ALLOCATED(InData%L_F_I) )   Re_BufSz    = Re_BufSz    + SIZE( InData%L_F_I )  ! L_F_I 
  IF ( ALLOCATED(InData%L_F_DP) )   Re_BufSz    = Re_BufSz    + SIZE( InData%L_F_DP )  ! L_F_DP 
  IF ( ALLOCATED(InData%L_F_BF) )   Re_BufSz    = Re_BufSz    + SIZE( InData%L_F_BF )  ! L_F_BF 
  IF ( ALLOCATED(InData%L_AM_M) )   Re_BufSz    = Re_BufSz    + SIZE( InData%L_AM_M )  ! L_AM_M 
  IF ( ALLOCATED(InData%L_dragConst) )   Re_BufSz    = Re_BufSz    + SIZE( InData%L_dragConst )  ! L_dragConst 
  Int_BufSz  = Int_BufSz  + 1  ! NDistribMarkers
  IF ( ALLOCATED(InData%distribToNodeIndx) )   Int_BufSz   = Int_BufSz   + SIZE( InData%distribToNodeIndx )  ! distribToNodeIndx 
  Int_BufSz  = Int_BufSz  + 1  ! NLumpedMarkers
  IF ( ALLOCATED(InData%lumpedToNodeIndx) )   Int_BufSz   = Int_BufSz   + SIZE( InData%lumpedToNodeIndx )  ! lumpedToNodeIndx 
  IF ( ALLOCATED(InData%WaveVel0) )   Re_BufSz    = Re_BufSz    + SIZE( InData%WaveVel0 )  ! WaveVel0 
  IF ( ALLOCATED(InData%WaveAcc0) )   Re_BufSz    = Re_BufSz    + SIZE( InData%WaveAcc0 )  ! WaveAcc0 
  IF ( ALLOCATED(InData%WaveDynP0) )   Re_BufSz    = Re_BufSz    + SIZE( InData%WaveDynP0 )  ! WaveDynP0 
  IF ( ALLOCATED(InData%WaveTime) )   Re_BufSz    = Re_BufSz    + SIZE( InData%WaveTime )  ! WaveTime 
  Int_BufSz  = Int_BufSz  + 1  ! NStepWave
  Int_BufSz  = Int_BufSz  + 1  ! NMOutputs
DO i1 = LBOUND(InData%MOutLst,1), UBOUND(InData%MOutLst,1)
  CALL Morison_Packmoutput( Re_MOutLst_Buf, Db_MOutLst_Buf, Int_MOutLst_Buf, InData%MOutLst(i1), ErrStat, ErrMsg, .TRUE. ) ! MOutLst 
  IF(ALLOCATED(Re_MOutLst_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_MOutLst_Buf  ) ! MOutLst
  IF(ALLOCATED(Db_MOutLst_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_MOutLst_Buf  ) ! MOutLst
  IF(ALLOCATED(Int_MOutLst_Buf))Int_BufSz = Int_BufSz + SIZE( Int_MOutLst_Buf ) ! MOutLst
  IF(ALLOCATED(Re_MOutLst_Buf))  DEALLOCATE(Re_MOutLst_Buf)
  IF(ALLOCATED(Db_MOutLst_Buf))  DEALLOCATE(Db_MOutLst_Buf)
  IF(ALLOCATED(Int_MOutLst_Buf)) DEALLOCATE(Int_MOutLst_Buf)
ENDDO
  Int_BufSz  = Int_BufSz  + 1  ! NJOutputs
DO i1 = LBOUND(InData%JOutLst,1), UBOUND(InData%JOutLst,1)
  CALL Morison_Packjoutput( Re_JOutLst_Buf, Db_JOutLst_Buf, Int_JOutLst_Buf, InData%JOutLst(i1), ErrStat, ErrMsg, .TRUE. ) ! JOutLst 
  IF(ALLOCATED(Re_JOutLst_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_JOutLst_Buf  ) ! JOutLst
  IF(ALLOCATED(Db_JOutLst_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_JOutLst_Buf  ) ! JOutLst
  IF(ALLOCATED(Int_JOutLst_Buf))Int_BufSz = Int_BufSz + SIZE( Int_JOutLst_Buf ) ! JOutLst
  IF(ALLOCATED(Re_JOutLst_Buf))  DEALLOCATE(Re_JOutLst_Buf)
  IF(ALLOCATED(Db_JOutLst_Buf))  DEALLOCATE(Db_JOutLst_Buf)
  IF(ALLOCATED(Int_JOutLst_Buf)) DEALLOCATE(Int_JOutLst_Buf)
ENDDO
DO i1 = LBOUND(InData%OutParam,1), UBOUND(InData%OutParam,1)
  CALL NWTC_Library_Packoutparmtype( Re_OutParam_Buf, Db_OutParam_Buf, Int_OutParam_Buf, InData%OutParam(i1), ErrStat, ErrMsg, .TRUE. ) ! OutParam 
  IF(ALLOCATED(Re_OutParam_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_OutParam_Buf  ) ! OutParam
  IF(ALLOCATED(Db_OutParam_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_OutParam_Buf  ) ! OutParam
  IF(ALLOCATED(Int_OutParam_Buf))Int_BufSz = Int_BufSz + SIZE( Int_OutParam_Buf ) ! OutParam
  IF(ALLOCATED(Re_OutParam_Buf))  DEALLOCATE(Re_OutParam_Buf)
  IF(ALLOCATED(Db_OutParam_Buf))  DEALLOCATE(Db_OutParam_Buf)
  IF(ALLOCATED(Int_OutParam_Buf)) DEALLOCATE(Int_OutParam_Buf)
ENDDO
  Int_BufSz  = Int_BufSz  + 1  ! NumOuts
  Int_BufSz  = Int_BufSz  + 1  ! NumOutAll
  Int_BufSz  = Int_BufSz  + 1  ! OutSwtch
  Int_BufSz  = Int_BufSz  + 1  ! UnOutFile
!  missing buffer for OutFmt
!  missing buffer for OutSFmt
!  missing buffer for Delim
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(1)-1 ) =  (InData%DT )
  Db_Xferred   = Db_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%WtrDens )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NNodes )
  Int_Xferred   = Int_Xferred   + 1
DO i1 = LBOUND(InData%Nodes,1), UBOUND(InData%Nodes,1)
  CALL Morison_Packnodetype( Re_Nodes_Buf, Db_Nodes_Buf, Int_Nodes_Buf, InData%Nodes(i1), ErrStat, ErrMsg, OnlySize ) ! Nodes 
  IF(ALLOCATED(Re_Nodes_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Nodes_Buf)-1 ) = Re_Nodes_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_Nodes_Buf)
  ENDIF
  IF(ALLOCATED(Db_Nodes_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Nodes_Buf)-1 ) = Db_Nodes_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_Nodes_Buf)
  ENDIF
  IF(ALLOCATED(Int_Nodes_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Nodes_Buf)-1 ) = Int_Nodes_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_Nodes_Buf)
  ENDIF
  IF( ALLOCATED(Re_Nodes_Buf) )  DEALLOCATE(Re_Nodes_Buf)
  IF( ALLOCATED(Db_Nodes_Buf) )  DEALLOCATE(Db_Nodes_Buf)
  IF( ALLOCATED(Int_Nodes_Buf) ) DEALLOCATE(Int_Nodes_Buf)
ENDDO
  IF ( ALLOCATED(InData%D_F_I) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%D_F_I))-1 ) =  PACK(InData%D_F_I ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%D_F_I)
  ENDIF
  IF ( ALLOCATED(InData%D_F_B) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%D_F_B))-1 ) =  PACK(InData%D_F_B ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%D_F_B)
  ENDIF
  IF ( ALLOCATED(InData%D_F_DP) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%D_F_DP))-1 ) =  PACK(InData%D_F_DP ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%D_F_DP)
  ENDIF
  IF ( ALLOCATED(InData%D_F_MG) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%D_F_MG))-1 ) =  PACK(InData%D_F_MG ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%D_F_MG)
  ENDIF
  IF ( ALLOCATED(InData%D_F_BF) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%D_F_BF))-1 ) =  PACK(InData%D_F_BF ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%D_F_BF)
  ENDIF
  IF ( ALLOCATED(InData%D_AM_M) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%D_AM_M))-1 ) =  PACK(InData%D_AM_M ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%D_AM_M)
  ENDIF
  IF ( ALLOCATED(InData%D_AM_MG) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%D_AM_MG))-1 ) =  PACK(InData%D_AM_MG ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%D_AM_MG)
  ENDIF
  IF ( ALLOCATED(InData%D_AM_F) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%D_AM_F))-1 ) =  PACK(InData%D_AM_F ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%D_AM_F)
  ENDIF
  IF ( ALLOCATED(InData%D_dragConst) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%D_dragConst))-1 ) =  PACK(InData%D_dragConst ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%D_dragConst)
  ENDIF
  IF ( ALLOCATED(InData%L_An) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%L_An))-1 ) =  PACK(InData%L_An ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%L_An)
  ENDIF
  IF ( ALLOCATED(InData%L_F_B) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%L_F_B))-1 ) =  PACK(InData%L_F_B ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%L_F_B)
  ENDIF
  IF ( ALLOCATED(InData%L_F_I) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%L_F_I))-1 ) =  PACK(InData%L_F_I ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%L_F_I)
  ENDIF
  IF ( ALLOCATED(InData%L_F_DP) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%L_F_DP))-1 ) =  PACK(InData%L_F_DP ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%L_F_DP)
  ENDIF
  IF ( ALLOCATED(InData%L_F_BF) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%L_F_BF))-1 ) =  PACK(InData%L_F_BF ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%L_F_BF)
  ENDIF
  IF ( ALLOCATED(InData%L_AM_M) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%L_AM_M))-1 ) =  PACK(InData%L_AM_M ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%L_AM_M)
  ENDIF
  IF ( ALLOCATED(InData%L_dragConst) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%L_dragConst))-1 ) =  PACK(InData%L_dragConst ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%L_dragConst)
  ENDIF
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NDistribMarkers )
  Int_Xferred   = Int_Xferred   + 1
  IF ( ALLOCATED(InData%distribToNodeIndx) ) THEN
    IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%distribToNodeIndx))-1 ) = PACK(InData%distribToNodeIndx ,.TRUE.)
    Int_Xferred   = Int_Xferred   + SIZE(InData%distribToNodeIndx)
  ENDIF
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NLumpedMarkers )
  Int_Xferred   = Int_Xferred   + 1
  IF ( ALLOCATED(InData%lumpedToNodeIndx) ) THEN
    IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%lumpedToNodeIndx))-1 ) = PACK(InData%lumpedToNodeIndx ,.TRUE.)
    Int_Xferred   = Int_Xferred   + SIZE(InData%lumpedToNodeIndx)
  ENDIF
  IF ( ALLOCATED(InData%WaveVel0) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%WaveVel0))-1 ) =  PACK(InData%WaveVel0 ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%WaveVel0)
  ENDIF
  IF ( ALLOCATED(InData%WaveAcc0) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%WaveAcc0))-1 ) =  PACK(InData%WaveAcc0 ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%WaveAcc0)
  ENDIF
  IF ( ALLOCATED(InData%WaveDynP0) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%WaveDynP0))-1 ) =  PACK(InData%WaveDynP0 ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%WaveDynP0)
  ENDIF
  IF ( ALLOCATED(InData%WaveTime) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%WaveTime))-1 ) =  PACK(InData%WaveTime ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%WaveTime)
  ENDIF
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NStepWave )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NMOutputs )
  Int_Xferred   = Int_Xferred   + 1
DO i1 = LBOUND(InData%MOutLst,1), UBOUND(InData%MOutLst,1)
  CALL Morison_Packmoutput( Re_MOutLst_Buf, Db_MOutLst_Buf, Int_MOutLst_Buf, InData%MOutLst(i1), ErrStat, ErrMsg, OnlySize ) ! MOutLst 
  IF(ALLOCATED(Re_MOutLst_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_MOutLst_Buf)-1 ) = Re_MOutLst_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_MOutLst_Buf)
  ENDIF
  IF(ALLOCATED(Db_MOutLst_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_MOutLst_Buf)-1 ) = Db_MOutLst_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_MOutLst_Buf)
  ENDIF
  IF(ALLOCATED(Int_MOutLst_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_MOutLst_Buf)-1 ) = Int_MOutLst_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_MOutLst_Buf)
  ENDIF
  IF( ALLOCATED(Re_MOutLst_Buf) )  DEALLOCATE(Re_MOutLst_Buf)
  IF( ALLOCATED(Db_MOutLst_Buf) )  DEALLOCATE(Db_MOutLst_Buf)
  IF( ALLOCATED(Int_MOutLst_Buf) ) DEALLOCATE(Int_MOutLst_Buf)
ENDDO
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NJOutputs )
  Int_Xferred   = Int_Xferred   + 1
DO i1 = LBOUND(InData%JOutLst,1), UBOUND(InData%JOutLst,1)
  CALL Morison_Packjoutput( Re_JOutLst_Buf, Db_JOutLst_Buf, Int_JOutLst_Buf, InData%JOutLst(i1), ErrStat, ErrMsg, OnlySize ) ! JOutLst 
  IF(ALLOCATED(Re_JOutLst_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_JOutLst_Buf)-1 ) = Re_JOutLst_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_JOutLst_Buf)
  ENDIF
  IF(ALLOCATED(Db_JOutLst_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_JOutLst_Buf)-1 ) = Db_JOutLst_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_JOutLst_Buf)
  ENDIF
  IF(ALLOCATED(Int_JOutLst_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_JOutLst_Buf)-1 ) = Int_JOutLst_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_JOutLst_Buf)
  ENDIF
  IF( ALLOCATED(Re_JOutLst_Buf) )  DEALLOCATE(Re_JOutLst_Buf)
  IF( ALLOCATED(Db_JOutLst_Buf) )  DEALLOCATE(Db_JOutLst_Buf)
  IF( ALLOCATED(Int_JOutLst_Buf) ) DEALLOCATE(Int_JOutLst_Buf)
ENDDO
DO i1 = LBOUND(InData%OutParam,1), UBOUND(InData%OutParam,1)
  CALL NWTC_Library_Packoutparmtype( Re_OutParam_Buf, Db_OutParam_Buf, Int_OutParam_Buf, InData%OutParam(i1), ErrStat, ErrMsg, OnlySize ) ! OutParam 
  IF(ALLOCATED(Re_OutParam_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_OutParam_Buf)-1 ) = Re_OutParam_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_OutParam_Buf)
  ENDIF
  IF(ALLOCATED(Db_OutParam_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_OutParam_Buf)-1 ) = Db_OutParam_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_OutParam_Buf)
  ENDIF
  IF(ALLOCATED(Int_OutParam_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_OutParam_Buf)-1 ) = Int_OutParam_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_OutParam_Buf)
  ENDIF
  IF( ALLOCATED(Re_OutParam_Buf) )  DEALLOCATE(Re_OutParam_Buf)
  IF( ALLOCATED(Db_OutParam_Buf) )  DEALLOCATE(Db_OutParam_Buf)
  IF( ALLOCATED(Int_OutParam_Buf) ) DEALLOCATE(Int_OutParam_Buf)
ENDDO
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NumOuts )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NumOutAll )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%OutSwtch )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%UnOutFile )
  Int_Xferred   = Int_Xferred   + 1
 END SUBROUTINE Morison_PackParam

 SUBROUTINE Morison_UnPackParam( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(Morison_parametertype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_Nodes_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_Nodes_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_Nodes_Buf(:)
  REAL(ReKi),    ALLOCATABLE :: Re_MOutLst_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_MOutLst_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_MOutLst_Buf(:)
  REAL(ReKi),    ALLOCATABLE :: Re_JOutLst_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_JOutLst_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_JOutLst_Buf(:)
  REAL(ReKi),    ALLOCATABLE :: Re_OutParam_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_OutParam_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_OutParam_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  OutData%DT = DbKiBuf ( Db_Xferred )
  Db_Xferred   = Db_Xferred   + 1
  OutData%WtrDens = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%NNodes = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
DO i1 = LBOUND(OutData%Nodes,1), UBOUND(OutData%Nodes,1)
 ! first call Morison_Packnodetype to get correctly sized buffers for unpacking
  CALL Morison_Packnodetype( Re_Nodes_Buf, Db_Nodes_Buf, Int_Nodes_Buf, OutData%Nodes(i1), ErrStat, ErrMsg, .TRUE. ) ! Nodes 
  IF(ALLOCATED(Re_Nodes_Buf)) THEN
    Re_Nodes_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Nodes_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_Nodes_Buf)
  ENDIF
  IF(ALLOCATED(Db_Nodes_Buf)) THEN
    Db_Nodes_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Nodes_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_Nodes_Buf)
  ENDIF
  IF(ALLOCATED(Int_Nodes_Buf)) THEN
    Int_Nodes_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Nodes_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_Nodes_Buf)
  ENDIF
  CALL Morison_UnPacknodetype( Re_Nodes_Buf, Db_Nodes_Buf, Int_Nodes_Buf, OutData%Nodes(i1), ErrStat, ErrMsg ) ! Nodes 
ENDDO
  IF ( ALLOCATED(OutData%D_F_I) ) THEN
  ALLOCATE(mask3(SIZE(OutData%D_F_I,1),SIZE(OutData%D_F_I,2),SIZE(OutData%D_F_I,3))); mask3 = .TRUE.
    OutData%D_F_I = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%D_F_I))-1 ),mask3,OutData%D_F_I)
  DEALLOCATE(mask3)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%D_F_I)
  ENDIF
  IF ( ALLOCATED(OutData%D_F_B) ) THEN
  ALLOCATE(mask2(SIZE(OutData%D_F_B,1),SIZE(OutData%D_F_B,2))); mask2 = .TRUE.
    OutData%D_F_B = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%D_F_B))-1 ),mask2,OutData%D_F_B)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%D_F_B)
  ENDIF
  IF ( ALLOCATED(OutData%D_F_DP) ) THEN
  ALLOCATE(mask3(SIZE(OutData%D_F_DP,1),SIZE(OutData%D_F_DP,2),SIZE(OutData%D_F_DP,3))); mask3 = .TRUE.
    OutData%D_F_DP = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%D_F_DP))-1 ),mask3,OutData%D_F_DP)
  DEALLOCATE(mask3)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%D_F_DP)
  ENDIF
  IF ( ALLOCATED(OutData%D_F_MG) ) THEN
  ALLOCATE(mask2(SIZE(OutData%D_F_MG,1),SIZE(OutData%D_F_MG,2))); mask2 = .TRUE.
    OutData%D_F_MG = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%D_F_MG))-1 ),mask2,OutData%D_F_MG)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%D_F_MG)
  ENDIF
  IF ( ALLOCATED(OutData%D_F_BF) ) THEN
  ALLOCATE(mask2(SIZE(OutData%D_F_BF,1),SIZE(OutData%D_F_BF,2))); mask2 = .TRUE.
    OutData%D_F_BF = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%D_F_BF))-1 ),mask2,OutData%D_F_BF)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%D_F_BF)
  ENDIF
  IF ( ALLOCATED(OutData%D_AM_M) ) THEN
  ALLOCATE(mask3(SIZE(OutData%D_AM_M,1),SIZE(OutData%D_AM_M,2),SIZE(OutData%D_AM_M,3))); mask3 = .TRUE.
    OutData%D_AM_M = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%D_AM_M))-1 ),mask3,OutData%D_AM_M)
  DEALLOCATE(mask3)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%D_AM_M)
  ENDIF
  IF ( ALLOCATED(OutData%D_AM_MG) ) THEN
  ALLOCATE(mask3(SIZE(OutData%D_AM_MG,1),SIZE(OutData%D_AM_MG,2),SIZE(OutData%D_AM_MG,3))); mask3 = .TRUE.
    OutData%D_AM_MG = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%D_AM_MG))-1 ),mask3,OutData%D_AM_MG)
  DEALLOCATE(mask3)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%D_AM_MG)
  ENDIF
  IF ( ALLOCATED(OutData%D_AM_F) ) THEN
  ALLOCATE(mask3(SIZE(OutData%D_AM_F,1),SIZE(OutData%D_AM_F,2),SIZE(OutData%D_AM_F,3))); mask3 = .TRUE.
    OutData%D_AM_F = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%D_AM_F))-1 ),mask3,OutData%D_AM_F)
  DEALLOCATE(mask3)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%D_AM_F)
  ENDIF
  IF ( ALLOCATED(OutData%D_dragConst) ) THEN
  ALLOCATE(mask1(SIZE(OutData%D_dragConst,1))); mask1 = .TRUE.
    OutData%D_dragConst = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%D_dragConst))-1 ),mask1,OutData%D_dragConst)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%D_dragConst)
  ENDIF
  IF ( ALLOCATED(OutData%L_An) ) THEN
  ALLOCATE(mask2(SIZE(OutData%L_An,1),SIZE(OutData%L_An,2))); mask2 = .TRUE.
    OutData%L_An = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%L_An))-1 ),mask2,OutData%L_An)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%L_An)
  ENDIF
  IF ( ALLOCATED(OutData%L_F_B) ) THEN
  ALLOCATE(mask2(SIZE(OutData%L_F_B,1),SIZE(OutData%L_F_B,2))); mask2 = .TRUE.
    OutData%L_F_B = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%L_F_B))-1 ),mask2,OutData%L_F_B)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%L_F_B)
  ENDIF
  IF ( ALLOCATED(OutData%L_F_I) ) THEN
  ALLOCATE(mask3(SIZE(OutData%L_F_I,1),SIZE(OutData%L_F_I,2),SIZE(OutData%L_F_I,3))); mask3 = .TRUE.
    OutData%L_F_I = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%L_F_I))-1 ),mask3,OutData%L_F_I)
  DEALLOCATE(mask3)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%L_F_I)
  ENDIF
  IF ( ALLOCATED(OutData%L_F_DP) ) THEN
  ALLOCATE(mask3(SIZE(OutData%L_F_DP,1),SIZE(OutData%L_F_DP,2),SIZE(OutData%L_F_DP,3))); mask3 = .TRUE.
    OutData%L_F_DP = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%L_F_DP))-1 ),mask3,OutData%L_F_DP)
  DEALLOCATE(mask3)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%L_F_DP)
  ENDIF
  IF ( ALLOCATED(OutData%L_F_BF) ) THEN
  ALLOCATE(mask2(SIZE(OutData%L_F_BF,1),SIZE(OutData%L_F_BF,2))); mask2 = .TRUE.
    OutData%L_F_BF = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%L_F_BF))-1 ),mask2,OutData%L_F_BF)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%L_F_BF)
  ENDIF
  IF ( ALLOCATED(OutData%L_AM_M) ) THEN
  ALLOCATE(mask3(SIZE(OutData%L_AM_M,1),SIZE(OutData%L_AM_M,2),SIZE(OutData%L_AM_M,3))); mask3 = .TRUE.
    OutData%L_AM_M = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%L_AM_M))-1 ),mask3,OutData%L_AM_M)
  DEALLOCATE(mask3)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%L_AM_M)
  ENDIF
  IF ( ALLOCATED(OutData%L_dragConst) ) THEN
  ALLOCATE(mask1(SIZE(OutData%L_dragConst,1))); mask1 = .TRUE.
    OutData%L_dragConst = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%L_dragConst))-1 ),mask1,OutData%L_dragConst)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%L_dragConst)
  ENDIF
  OutData%NDistribMarkers = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  IF ( ALLOCATED(OutData%distribToNodeIndx) ) THEN
  ALLOCATE(mask1(SIZE(OutData%distribToNodeIndx,1))); mask1 = .TRUE.
    OutData%distribToNodeIndx = UNPACK(IntKiBuf( Int_Xferred:Re_Xferred+(SIZE(OutData%distribToNodeIndx))-1 ),mask1,OutData%distribToNodeIndx)
  DEALLOCATE(mask1)
    Int_Xferred   = Int_Xferred   + SIZE(OutData%distribToNodeIndx)
  ENDIF
  OutData%NLumpedMarkers = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  IF ( ALLOCATED(OutData%lumpedToNodeIndx) ) THEN
  ALLOCATE(mask1(SIZE(OutData%lumpedToNodeIndx,1))); mask1 = .TRUE.
    OutData%lumpedToNodeIndx = UNPACK(IntKiBuf( Int_Xferred:Re_Xferred+(SIZE(OutData%lumpedToNodeIndx))-1 ),mask1,OutData%lumpedToNodeIndx)
  DEALLOCATE(mask1)
    Int_Xferred   = Int_Xferred   + SIZE(OutData%lumpedToNodeIndx)
  ENDIF
  IF ( ALLOCATED(OutData%WaveVel0) ) THEN
  ALLOCATE(mask3(SIZE(OutData%WaveVel0,1),SIZE(OutData%WaveVel0,2),SIZE(OutData%WaveVel0,3))); mask3 = .TRUE.
    OutData%WaveVel0 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%WaveVel0))-1 ),mask3,OutData%WaveVel0)
  DEALLOCATE(mask3)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%WaveVel0)
  ENDIF
  IF ( ALLOCATED(OutData%WaveAcc0) ) THEN
  ALLOCATE(mask3(SIZE(OutData%WaveAcc0,1),SIZE(OutData%WaveAcc0,2),SIZE(OutData%WaveAcc0,3))); mask3 = .TRUE.
    OutData%WaveAcc0 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%WaveAcc0))-1 ),mask3,OutData%WaveAcc0)
  DEALLOCATE(mask3)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%WaveAcc0)
  ENDIF
  IF ( ALLOCATED(OutData%WaveDynP0) ) THEN
  ALLOCATE(mask2(SIZE(OutData%WaveDynP0,1),SIZE(OutData%WaveDynP0,2))); mask2 = .TRUE.
    OutData%WaveDynP0 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%WaveDynP0))-1 ),mask2,OutData%WaveDynP0)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%WaveDynP0)
  ENDIF
  IF ( ALLOCATED(OutData%WaveTime) ) THEN
  ALLOCATE(mask1(SIZE(OutData%WaveTime,1))); mask1 = .TRUE.
    OutData%WaveTime = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%WaveTime))-1 ),mask1,OutData%WaveTime)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%WaveTime)
  ENDIF
  OutData%NStepWave = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%NMOutputs = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
DO i1 = LBOUND(OutData%MOutLst,1), UBOUND(OutData%MOutLst,1)
 ! first call Morison_Packmoutput to get correctly sized buffers for unpacking
  CALL Morison_Packmoutput( Re_MOutLst_Buf, Db_MOutLst_Buf, Int_MOutLst_Buf, OutData%MOutLst(i1), ErrStat, ErrMsg, .TRUE. ) ! MOutLst 
  IF(ALLOCATED(Re_MOutLst_Buf)) THEN
    Re_MOutLst_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_MOutLst_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_MOutLst_Buf)
  ENDIF
  IF(ALLOCATED(Db_MOutLst_Buf)) THEN
    Db_MOutLst_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_MOutLst_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_MOutLst_Buf)
  ENDIF
  IF(ALLOCATED(Int_MOutLst_Buf)) THEN
    Int_MOutLst_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_MOutLst_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_MOutLst_Buf)
  ENDIF
  CALL Morison_UnPackmoutput( Re_MOutLst_Buf, Db_MOutLst_Buf, Int_MOutLst_Buf, OutData%MOutLst(i1), ErrStat, ErrMsg ) ! MOutLst 
ENDDO
  OutData%NJOutputs = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
DO i1 = LBOUND(OutData%JOutLst,1), UBOUND(OutData%JOutLst,1)
 ! first call Morison_Packjoutput to get correctly sized buffers for unpacking
  CALL Morison_Packjoutput( Re_JOutLst_Buf, Db_JOutLst_Buf, Int_JOutLst_Buf, OutData%JOutLst(i1), ErrStat, ErrMsg, .TRUE. ) ! JOutLst 
  IF(ALLOCATED(Re_JOutLst_Buf)) THEN
    Re_JOutLst_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_JOutLst_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_JOutLst_Buf)
  ENDIF
  IF(ALLOCATED(Db_JOutLst_Buf)) THEN
    Db_JOutLst_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_JOutLst_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_JOutLst_Buf)
  ENDIF
  IF(ALLOCATED(Int_JOutLst_Buf)) THEN
    Int_JOutLst_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_JOutLst_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_JOutLst_Buf)
  ENDIF
  CALL Morison_UnPackjoutput( Re_JOutLst_Buf, Db_JOutLst_Buf, Int_JOutLst_Buf, OutData%JOutLst(i1), ErrStat, ErrMsg ) ! JOutLst 
ENDDO
DO i1 = LBOUND(OutData%OutParam,1), UBOUND(OutData%OutParam,1)
 ! first call NWTC_Library_Packoutparmtype to get correctly sized buffers for unpacking
  CALL NWTC_Library_Packoutparmtype( Re_OutParam_Buf, Db_OutParam_Buf, Int_OutParam_Buf, OutData%OutParam(i1), ErrStat, ErrMsg, .TRUE. ) ! OutParam 
  IF(ALLOCATED(Re_OutParam_Buf)) THEN
    Re_OutParam_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_OutParam_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_OutParam_Buf)
  ENDIF
  IF(ALLOCATED(Db_OutParam_Buf)) THEN
    Db_OutParam_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_OutParam_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_OutParam_Buf)
  ENDIF
  IF(ALLOCATED(Int_OutParam_Buf)) THEN
    Int_OutParam_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_OutParam_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_OutParam_Buf)
  ENDIF
  CALL NWTC_Library_UnPackoutparmtype( Re_OutParam_Buf, Db_OutParam_Buf, Int_OutParam_Buf, OutData%OutParam(i1), ErrStat, ErrMsg ) ! OutParam 
ENDDO
  OutData%NumOuts = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%NumOutAll = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%OutSwtch = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%UnOutFile = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE Morison_UnPackParam

 SUBROUTINE Morison_CopyInput( SrcInputData, DstInputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(Morison_inputtype), INTENT(INOUT) :: SrcInputData
   TYPE(Morison_inputtype), INTENT(INOUT) :: DstInputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
     CALL MeshCopy( SrcInputData%DistribMesh, DstInputData%DistribMesh, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'Morison_CopyInput:DistribMesh')
         IF (ErrStat>=AbortErrLev) RETURN
     CALL MeshCopy( SrcInputData%LumpedMesh, DstInputData%LumpedMesh, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'Morison_CopyInput:LumpedMesh')
         IF (ErrStat>=AbortErrLev) RETURN
 END SUBROUTINE Morison_CopyInput

 SUBROUTINE Morison_DestroyInput( InputData, ErrStat, ErrMsg )
  TYPE(Morison_inputtype), INTENT(INOUT) :: InputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  CALL MeshDestroy( InputData%DistribMesh, ErrStat, ErrMsg )
  CALL MeshDestroy( InputData%LumpedMesh, ErrStat, ErrMsg )
 END SUBROUTINE Morison_DestroyInput

 SUBROUTINE Morison_PackInput( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(Morison_inputtype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_DistribMesh_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_DistribMesh_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_DistribMesh_Buf(:)
  REAL(ReKi),     ALLOCATABLE :: Re_LumpedMesh_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_LumpedMesh_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_LumpedMesh_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
 ! Allocate mesh buffers, if any (we'll also get sizes from these) 
  CALL MeshPack( InData%DistribMesh, Re_DistribMesh_Buf, Db_DistribMesh_Buf, Int_DistribMesh_Buf, ErrStat, ErrMsg, .TRUE. ) ! DistribMesh 
  IF(ALLOCATED(Re_DistribMesh_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_DistribMesh_Buf  ) ! DistribMesh
  IF(ALLOCATED(Db_DistribMesh_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_DistribMesh_Buf  ) ! DistribMesh
  IF(ALLOCATED(Int_DistribMesh_Buf))Int_BufSz = Int_BufSz + SIZE( Int_DistribMesh_Buf ) ! DistribMesh
  IF(ALLOCATED(Re_DistribMesh_Buf))  DEALLOCATE(Re_DistribMesh_Buf)
  IF(ALLOCATED(Db_DistribMesh_Buf))  DEALLOCATE(Db_DistribMesh_Buf)
  IF(ALLOCATED(Int_DistribMesh_Buf)) DEALLOCATE(Int_DistribMesh_Buf)
  CALL MeshPack( InData%LumpedMesh, Re_LumpedMesh_Buf, Db_LumpedMesh_Buf, Int_LumpedMesh_Buf, ErrStat, ErrMsg, .TRUE. ) ! LumpedMesh 
  IF(ALLOCATED(Re_LumpedMesh_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_LumpedMesh_Buf  ) ! LumpedMesh
  IF(ALLOCATED(Db_LumpedMesh_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_LumpedMesh_Buf  ) ! LumpedMesh
  IF(ALLOCATED(Int_LumpedMesh_Buf))Int_BufSz = Int_BufSz + SIZE( Int_LumpedMesh_Buf ) ! LumpedMesh
  IF(ALLOCATED(Re_LumpedMesh_Buf))  DEALLOCATE(Re_LumpedMesh_Buf)
  IF(ALLOCATED(Db_LumpedMesh_Buf))  DEALLOCATE(Db_LumpedMesh_Buf)
  IF(ALLOCATED(Int_LumpedMesh_Buf)) DEALLOCATE(Int_LumpedMesh_Buf)
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  CALL MeshPack( InData%DistribMesh, Re_DistribMesh_Buf, Db_DistribMesh_Buf, Int_DistribMesh_Buf, ErrStat, ErrMsg, OnlySize ) ! DistribMesh 
  IF(ALLOCATED(Re_DistribMesh_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_DistribMesh_Buf)-1 ) = Re_DistribMesh_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_DistribMesh_Buf)
  ENDIF
  IF(ALLOCATED(Db_DistribMesh_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_DistribMesh_Buf)-1 ) = Db_DistribMesh_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_DistribMesh_Buf)
  ENDIF
  IF(ALLOCATED(Int_DistribMesh_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_DistribMesh_Buf)-1 ) = Int_DistribMesh_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_DistribMesh_Buf)
  ENDIF
  IF( ALLOCATED(Re_DistribMesh_Buf) )  DEALLOCATE(Re_DistribMesh_Buf)
  IF( ALLOCATED(Db_DistribMesh_Buf) )  DEALLOCATE(Db_DistribMesh_Buf)
  IF( ALLOCATED(Int_DistribMesh_Buf) ) DEALLOCATE(Int_DistribMesh_Buf)
  CALL MeshPack( InData%LumpedMesh, Re_LumpedMesh_Buf, Db_LumpedMesh_Buf, Int_LumpedMesh_Buf, ErrStat, ErrMsg, OnlySize ) ! LumpedMesh 
  IF(ALLOCATED(Re_LumpedMesh_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_LumpedMesh_Buf)-1 ) = Re_LumpedMesh_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_LumpedMesh_Buf)
  ENDIF
  IF(ALLOCATED(Db_LumpedMesh_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_LumpedMesh_Buf)-1 ) = Db_LumpedMesh_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_LumpedMesh_Buf)
  ENDIF
  IF(ALLOCATED(Int_LumpedMesh_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_LumpedMesh_Buf)-1 ) = Int_LumpedMesh_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_LumpedMesh_Buf)
  ENDIF
  IF( ALLOCATED(Re_LumpedMesh_Buf) )  DEALLOCATE(Re_LumpedMesh_Buf)
  IF( ALLOCATED(Db_LumpedMesh_Buf) )  DEALLOCATE(Db_LumpedMesh_Buf)
  IF( ALLOCATED(Int_LumpedMesh_Buf) ) DEALLOCATE(Int_LumpedMesh_Buf)
 END SUBROUTINE Morison_PackInput

 SUBROUTINE Morison_UnPackInput( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(Morison_inputtype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_DistribMesh_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_DistribMesh_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_DistribMesh_Buf(:)
  REAL(ReKi),    ALLOCATABLE :: Re_LumpedMesh_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_LumpedMesh_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_LumpedMesh_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
 ! first call MeshPack to get correctly sized buffers for unpacking
  CALL MeshPack( OutData%DistribMesh, Re_DistribMesh_Buf, Db_DistribMesh_Buf, Int_DistribMesh_Buf, ErrStat, ErrMsg , .TRUE. ) ! DistribMesh 
  IF(ALLOCATED(Re_DistribMesh_Buf)) THEN
    Re_DistribMesh_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_DistribMesh_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_DistribMesh_Buf)
  ENDIF
  IF(ALLOCATED(Db_DistribMesh_Buf)) THEN
    Db_DistribMesh_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_DistribMesh_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_DistribMesh_Buf)
  ENDIF
  IF(ALLOCATED(Int_DistribMesh_Buf)) THEN
    Int_DistribMesh_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_DistribMesh_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_DistribMesh_Buf)
  ENDIF
  CALL MeshUnPack( OutData%DistribMesh, Re_DistribMesh_Buf, Db_DistribMesh_Buf, Int_DistribMesh_Buf, ErrStat, ErrMsg ) ! DistribMesh 
  IF( ALLOCATED(Re_DistribMesh_Buf) )  DEALLOCATE(Re_DistribMesh_Buf)
  IF( ALLOCATED(Db_DistribMesh_Buf) )  DEALLOCATE(Db_DistribMesh_Buf)
  IF( ALLOCATED(Int_DistribMesh_Buf) ) DEALLOCATE(Int_DistribMesh_Buf)
  CALL MeshPack( OutData%LumpedMesh, Re_LumpedMesh_Buf, Db_LumpedMesh_Buf, Int_LumpedMesh_Buf, ErrStat, ErrMsg , .TRUE. ) ! LumpedMesh 
  IF(ALLOCATED(Re_LumpedMesh_Buf)) THEN
    Re_LumpedMesh_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_LumpedMesh_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_LumpedMesh_Buf)
  ENDIF
  IF(ALLOCATED(Db_LumpedMesh_Buf)) THEN
    Db_LumpedMesh_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_LumpedMesh_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_LumpedMesh_Buf)
  ENDIF
  IF(ALLOCATED(Int_LumpedMesh_Buf)) THEN
    Int_LumpedMesh_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_LumpedMesh_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_LumpedMesh_Buf)
  ENDIF
  CALL MeshUnPack( OutData%LumpedMesh, Re_LumpedMesh_Buf, Db_LumpedMesh_Buf, Int_LumpedMesh_Buf, ErrStat, ErrMsg ) ! LumpedMesh 
  IF( ALLOCATED(Re_LumpedMesh_Buf) )  DEALLOCATE(Re_LumpedMesh_Buf)
  IF( ALLOCATED(Db_LumpedMesh_Buf) )  DEALLOCATE(Db_LumpedMesh_Buf)
  IF( ALLOCATED(Int_LumpedMesh_Buf) ) DEALLOCATE(Int_LumpedMesh_Buf)
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE Morison_UnPackInput

 SUBROUTINE Morison_CopyOutput( SrcOutputData, DstOutputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(Morison_outputtype), INTENT(INOUT) :: SrcOutputData
   TYPE(Morison_outputtype), INTENT(INOUT) :: DstOutputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
     CALL MeshCopy( SrcOutputData%DistribMesh, DstOutputData%DistribMesh, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'Morison_CopyOutput:DistribMesh')
         IF (ErrStat>=AbortErrLev) RETURN
     CALL MeshCopy( SrcOutputData%LumpedMesh, DstOutputData%LumpedMesh, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'Morison_CopyOutput:LumpedMesh')
         IF (ErrStat>=AbortErrLev) RETURN
IF (ALLOCATED(SrcOutputData%WriteOutput)) THEN
   i1_l = LBOUND(SrcOutputData%WriteOutput,1)
   i1_u = UBOUND(SrcOutputData%WriteOutput,1)
   IF (.NOT. ALLOCATED(DstOutputData%WriteOutput)) THEN 
      ALLOCATE(DstOutputData%WriteOutput(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOutputData%WriteOutput.', ErrStat, ErrMsg,'Morison_CopyOutput')
         RETURN
      END IF
   END IF
   DstOutputData%WriteOutput = SrcOutputData%WriteOutput
ENDIF
 END SUBROUTINE Morison_CopyOutput

 SUBROUTINE Morison_DestroyOutput( OutputData, ErrStat, ErrMsg )
  TYPE(Morison_outputtype), INTENT(INOUT) :: OutputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  CALL MeshDestroy( OutputData%DistribMesh, ErrStat, ErrMsg )
  CALL MeshDestroy( OutputData%LumpedMesh, ErrStat, ErrMsg )
IF (ALLOCATED(OutputData%WriteOutput)) THEN
   DEALLOCATE(OutputData%WriteOutput)
ENDIF
 END SUBROUTINE Morison_DestroyOutput

 SUBROUTINE Morison_PackOutput( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(Morison_outputtype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_DistribMesh_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_DistribMesh_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_DistribMesh_Buf(:)
  REAL(ReKi),     ALLOCATABLE :: Re_LumpedMesh_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_LumpedMesh_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_LumpedMesh_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
 ! Allocate mesh buffers, if any (we'll also get sizes from these) 
  CALL MeshPack( InData%DistribMesh, Re_DistribMesh_Buf, Db_DistribMesh_Buf, Int_DistribMesh_Buf, ErrStat, ErrMsg, .TRUE. ) ! DistribMesh 
  IF(ALLOCATED(Re_DistribMesh_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_DistribMesh_Buf  ) ! DistribMesh
  IF(ALLOCATED(Db_DistribMesh_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_DistribMesh_Buf  ) ! DistribMesh
  IF(ALLOCATED(Int_DistribMesh_Buf))Int_BufSz = Int_BufSz + SIZE( Int_DistribMesh_Buf ) ! DistribMesh
  IF(ALLOCATED(Re_DistribMesh_Buf))  DEALLOCATE(Re_DistribMesh_Buf)
  IF(ALLOCATED(Db_DistribMesh_Buf))  DEALLOCATE(Db_DistribMesh_Buf)
  IF(ALLOCATED(Int_DistribMesh_Buf)) DEALLOCATE(Int_DistribMesh_Buf)
  CALL MeshPack( InData%LumpedMesh, Re_LumpedMesh_Buf, Db_LumpedMesh_Buf, Int_LumpedMesh_Buf, ErrStat, ErrMsg, .TRUE. ) ! LumpedMesh 
  IF(ALLOCATED(Re_LumpedMesh_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_LumpedMesh_Buf  ) ! LumpedMesh
  IF(ALLOCATED(Db_LumpedMesh_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_LumpedMesh_Buf  ) ! LumpedMesh
  IF(ALLOCATED(Int_LumpedMesh_Buf))Int_BufSz = Int_BufSz + SIZE( Int_LumpedMesh_Buf ) ! LumpedMesh
  IF(ALLOCATED(Re_LumpedMesh_Buf))  DEALLOCATE(Re_LumpedMesh_Buf)
  IF(ALLOCATED(Db_LumpedMesh_Buf))  DEALLOCATE(Db_LumpedMesh_Buf)
  IF(ALLOCATED(Int_LumpedMesh_Buf)) DEALLOCATE(Int_LumpedMesh_Buf)
  IF ( ALLOCATED(InData%WriteOutput) )   Re_BufSz    = Re_BufSz    + SIZE( InData%WriteOutput )  ! WriteOutput 
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  CALL MeshPack( InData%DistribMesh, Re_DistribMesh_Buf, Db_DistribMesh_Buf, Int_DistribMesh_Buf, ErrStat, ErrMsg, OnlySize ) ! DistribMesh 
  IF(ALLOCATED(Re_DistribMesh_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_DistribMesh_Buf)-1 ) = Re_DistribMesh_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_DistribMesh_Buf)
  ENDIF
  IF(ALLOCATED(Db_DistribMesh_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_DistribMesh_Buf)-1 ) = Db_DistribMesh_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_DistribMesh_Buf)
  ENDIF
  IF(ALLOCATED(Int_DistribMesh_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_DistribMesh_Buf)-1 ) = Int_DistribMesh_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_DistribMesh_Buf)
  ENDIF
  IF( ALLOCATED(Re_DistribMesh_Buf) )  DEALLOCATE(Re_DistribMesh_Buf)
  IF( ALLOCATED(Db_DistribMesh_Buf) )  DEALLOCATE(Db_DistribMesh_Buf)
  IF( ALLOCATED(Int_DistribMesh_Buf) ) DEALLOCATE(Int_DistribMesh_Buf)
  CALL MeshPack( InData%LumpedMesh, Re_LumpedMesh_Buf, Db_LumpedMesh_Buf, Int_LumpedMesh_Buf, ErrStat, ErrMsg, OnlySize ) ! LumpedMesh 
  IF(ALLOCATED(Re_LumpedMesh_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_LumpedMesh_Buf)-1 ) = Re_LumpedMesh_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_LumpedMesh_Buf)
  ENDIF
  IF(ALLOCATED(Db_LumpedMesh_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_LumpedMesh_Buf)-1 ) = Db_LumpedMesh_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_LumpedMesh_Buf)
  ENDIF
  IF(ALLOCATED(Int_LumpedMesh_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_LumpedMesh_Buf)-1 ) = Int_LumpedMesh_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_LumpedMesh_Buf)
  ENDIF
  IF( ALLOCATED(Re_LumpedMesh_Buf) )  DEALLOCATE(Re_LumpedMesh_Buf)
  IF( ALLOCATED(Db_LumpedMesh_Buf) )  DEALLOCATE(Db_LumpedMesh_Buf)
  IF( ALLOCATED(Int_LumpedMesh_Buf) ) DEALLOCATE(Int_LumpedMesh_Buf)
  IF ( ALLOCATED(InData%WriteOutput) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%WriteOutput))-1 ) =  PACK(InData%WriteOutput ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%WriteOutput)
  ENDIF
 END SUBROUTINE Morison_PackOutput

 SUBROUTINE Morison_UnPackOutput( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(Morison_outputtype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_DistribMesh_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_DistribMesh_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_DistribMesh_Buf(:)
  REAL(ReKi),    ALLOCATABLE :: Re_LumpedMesh_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_LumpedMesh_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_LumpedMesh_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
 ! first call MeshPack to get correctly sized buffers for unpacking
  CALL MeshPack( OutData%DistribMesh, Re_DistribMesh_Buf, Db_DistribMesh_Buf, Int_DistribMesh_Buf, ErrStat, ErrMsg , .TRUE. ) ! DistribMesh 
  IF(ALLOCATED(Re_DistribMesh_Buf)) THEN
    Re_DistribMesh_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_DistribMesh_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_DistribMesh_Buf)
  ENDIF
  IF(ALLOCATED(Db_DistribMesh_Buf)) THEN
    Db_DistribMesh_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_DistribMesh_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_DistribMesh_Buf)
  ENDIF
  IF(ALLOCATED(Int_DistribMesh_Buf)) THEN
    Int_DistribMesh_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_DistribMesh_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_DistribMesh_Buf)
  ENDIF
  CALL MeshUnPack( OutData%DistribMesh, Re_DistribMesh_Buf, Db_DistribMesh_Buf, Int_DistribMesh_Buf, ErrStat, ErrMsg ) ! DistribMesh 
  IF( ALLOCATED(Re_DistribMesh_Buf) )  DEALLOCATE(Re_DistribMesh_Buf)
  IF( ALLOCATED(Db_DistribMesh_Buf) )  DEALLOCATE(Db_DistribMesh_Buf)
  IF( ALLOCATED(Int_DistribMesh_Buf) ) DEALLOCATE(Int_DistribMesh_Buf)
  CALL MeshPack( OutData%LumpedMesh, Re_LumpedMesh_Buf, Db_LumpedMesh_Buf, Int_LumpedMesh_Buf, ErrStat, ErrMsg , .TRUE. ) ! LumpedMesh 
  IF(ALLOCATED(Re_LumpedMesh_Buf)) THEN
    Re_LumpedMesh_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_LumpedMesh_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_LumpedMesh_Buf)
  ENDIF
  IF(ALLOCATED(Db_LumpedMesh_Buf)) THEN
    Db_LumpedMesh_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_LumpedMesh_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_LumpedMesh_Buf)
  ENDIF
  IF(ALLOCATED(Int_LumpedMesh_Buf)) THEN
    Int_LumpedMesh_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_LumpedMesh_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_LumpedMesh_Buf)
  ENDIF
  CALL MeshUnPack( OutData%LumpedMesh, Re_LumpedMesh_Buf, Db_LumpedMesh_Buf, Int_LumpedMesh_Buf, ErrStat, ErrMsg ) ! LumpedMesh 
  IF( ALLOCATED(Re_LumpedMesh_Buf) )  DEALLOCATE(Re_LumpedMesh_Buf)
  IF( ALLOCATED(Db_LumpedMesh_Buf) )  DEALLOCATE(Db_LumpedMesh_Buf)
  IF( ALLOCATED(Int_LumpedMesh_Buf) ) DEALLOCATE(Int_LumpedMesh_Buf)
  IF ( ALLOCATED(OutData%WriteOutput) ) THEN
  ALLOCATE(mask1(SIZE(OutData%WriteOutput,1))); mask1 = .TRUE.
    OutData%WriteOutput = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%WriteOutput))-1 ),mask1,OutData%WriteOutput)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%WriteOutput)
  ENDIF
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE Morison_UnPackOutput


 SUBROUTINE Morison_Input_ExtrapInterp(u, tin, u_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) input u_out at time t_out, from previous/future time
! values of u (which has values associated with times in t).  Order of the interpolation is given by the size of u
!
!  expressions below based on either
!
!  f(t) = a
!  f(t) = a + b * t, or
!  f(t) = a + b * t + c * t**2
!
!  where a, b and c are determined as the solution to
!  f(t1) = u1, f(t2) = u2, f(t3) = u3  (as appropriate)
!
!..................................................................................................................................

 TYPE(Morison_inputtype), INTENT(INOUT)  :: u(:)      ! Inputs at t1 > t2 > t3
 REAL(DbKi),         INTENT(IN   )  :: tin(:)      ! Times associated with the inputs
 TYPE(Morison_inputtype), INTENT(INOUT)  :: u_out     ! Inputs at tin_out
 REAL(DbKi),         INTENT(IN   )  :: tin_out     ! time to be extrap/interp'd to
 INTEGER(IntKi),     INTENT(  OUT)  :: ErrStat   ! Error status of the operation
 CHARACTER(*),       INTENT(  OUT)  :: ErrMsg    ! Error message if ErrStat /= ErrID_None
   ! local variables
 REAL(DbKi) :: t(SIZE(tin))    ! Times associated with the inputs
 REAL(DbKi) :: t_out           ! Time to which to be extrap/interpd
 INTEGER(IntKi)                 :: order    ! order of polynomial fit (max 2)
 REAL(DbKi)                                 :: b0       ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: c0       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:)        :: b1       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:)        :: c1       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:)      :: b2       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:)      :: c2       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:)    :: b3       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:)    :: c3       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:,:)  :: b4       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:,:)  :: c4       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:,:,:):: b5       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:,:,:):: c5       ! temporary for extrapolation/interpolation
 INTEGER(IntKi)                             :: ErrStat2 ! local errors
 CHARACTER(1024)                            :: ErrMsg2  ! local errors
 INTEGER                                    :: i01    ! dim1 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i11    ! dim1 level 1 counter variable for arrays of ddts
 INTEGER                                    :: i21    ! dim1 level 2 counter variable for arrays of ddts
 INTEGER                                    :: i31    ! dim1 level 3 counter variable for arrays of ddts
 INTEGER                                    :: i41    ! dim1 level 4 counter variable for arrays of ddts
 INTEGER                                    :: i51    ! dim1 level 5 counter variable for arrays of ddts
 INTEGER                                    :: i61    ! dim1 level 6 counter variable for arrays of ddts
 INTEGER                                    :: i71    ! dim1 level 7 counter variable for arrays of ddts
 INTEGER                                    :: i81    ! dim1 level 8 counter variable for arrays of ddts
 INTEGER                                    :: i91    ! dim1 level 9 counter variable for arrays of ddts
 INTEGER                                    :: i02    ! dim2 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i12    ! dim2 level 1 counter variable for arrays of ddts
 INTEGER                                    :: i22    ! dim2 level 2 counter variable for arrays of ddts
 INTEGER                                    :: i32    ! dim2 level 3 counter variable for arrays of ddts
 INTEGER                                    :: i42    ! dim2 level 4 counter variable for arrays of ddts
 INTEGER                                    :: i52    ! dim2 level 5 counter variable for arrays of ddts
 INTEGER                                    :: i62    ! dim2 level 6 counter variable for arrays of ddts
 INTEGER                                    :: i72    ! dim2 level 7 counter variable for arrays of ddts
 INTEGER                                    :: i82    ! dim2 level 8 counter variable for arrays of ddts
 INTEGER                                    :: i92    ! dim2 level 9 counter variable for arrays of ddts
 INTEGER                                    :: i03    ! dim3 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i13    ! dim3 level 1 counter variable for arrays of ddts
 INTEGER                                    :: i23    ! dim3 level 2 counter variable for arrays of ddts
 INTEGER                                    :: i33    ! dim3 level 3 counter variable for arrays of ddts
 INTEGER                                    :: i43    ! dim3 level 4 counter variable for arrays of ddts
 INTEGER                                    :: i53    ! dim3 level 5 counter variable for arrays of ddts
 INTEGER                                    :: i63    ! dim3 level 6 counter variable for arrays of ddts
 INTEGER                                    :: i73    ! dim3 level 7 counter variable for arrays of ddts
 INTEGER                                    :: i83    ! dim3 level 8 counter variable for arrays of ddts
 INTEGER                                    :: i93    ! dim3 level 9 counter variable for arrays of ddts
 INTEGER                                    :: i04    ! dim4 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i14    ! dim4 level 1 counter variable for arrays of ddts
 INTEGER                                    :: i24    ! dim4 level 2 counter variable for arrays of ddts
 INTEGER                                    :: i34    ! dim4 level 3 counter variable for arrays of ddts
 INTEGER                                    :: i44    ! dim4 level 4 counter variable for arrays of ddts
 INTEGER                                    :: i54    ! dim4 level 5 counter variable for arrays of ddts
 INTEGER                                    :: i64    ! dim4 level 6 counter variable for arrays of ddts
 INTEGER                                    :: i74    ! dim4 level 7 counter variable for arrays of ddts
 INTEGER                                    :: i84    ! dim4 level 8 counter variable for arrays of ddts
 INTEGER                                    :: i94    ! dim4 level 9 counter variable for arrays of ddts
 INTEGER                                    :: i05    ! dim5 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i15    ! dim5 level 1 counter variable for arrays of ddts
 INTEGER                                    :: i25    ! dim5 level 2 counter variable for arrays of ddts
 INTEGER                                    :: i35    ! dim5 level 3 counter variable for arrays of ddts
 INTEGER                                    :: i45    ! dim5 level 4 counter variable for arrays of ddts
 INTEGER                                    :: i55    ! dim5 level 5 counter variable for arrays of ddts
 INTEGER                                    :: i65    ! dim5 level 6 counter variable for arrays of ddts
 INTEGER                                    :: i75    ! dim5 level 7 counter variable for arrays of ddts
 INTEGER                                    :: i85    ! dim5 level 8 counter variable for arrays of ddts
 INTEGER                                    :: i95    ! dim5 level 9 counter variable for arrays of ddts
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
    ! we'll subtract a constant from the times to resolve some 
    ! numerical issues when t gets large (and to simplify the equations)
 t = tin - tin(1)
 t_out = tin_out - tin(1)

 if ( size(t) .ne. size(u)) then
    ErrStat = ErrID_Fatal
    ErrMsg = ' Error in Morison_Input_ExtrapInterp: size(t) must equal size(u) '
    RETURN
 endif
 if (size(u) .gt. 3) then
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in Morison_Input_ExtrapInterp: size(u) must be less than 4 '
    RETURN
 endif
 order = SIZE(u) - 1
 IF ( order .eq. 0 ) THEN
  CALL MeshCopy(u(1)%DistribMesh, u_out%DistribMesh, MESH_UPDATECOPY, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'Morison_Input_ExtrapInterp:%DistribMesh')
         IF (ErrStat>=AbortErrLev) RETURN
  CALL MeshCopy(u(1)%LumpedMesh, u_out%LumpedMesh, MESH_UPDATECOPY, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'Morison_Input_ExtrapInterp:%LumpedMesh')
         IF (ErrStat>=AbortErrLev) RETURN
 ELSE IF ( order .eq. 1 ) THEN
  IF ( EqualRealNos( t(1), t(2) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in Morison_Input_ExtrapInterp: t(1) must not equal t(2) to avoid a division-by-zero error.'
    RETURN
  END IF
  CALL MeshExtrapInterp1(u(1)%DistribMesh, u(2)%DistribMesh, tin, u_out%DistribMesh, tin_out, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'Morison_Input_ExtrapInterp:%DistribMesh')
         IF (ErrStat>=AbortErrLev) RETURN
  CALL MeshExtrapInterp1(u(1)%LumpedMesh, u(2)%LumpedMesh, tin, u_out%LumpedMesh, tin_out, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'Morison_Input_ExtrapInterp:%LumpedMesh')
         IF (ErrStat>=AbortErrLev) RETURN
 ELSE IF ( order .eq. 2 ) THEN
  IF ( EqualRealNos( t(1), t(2) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in Morison_Input_ExtrapInterp: t(1) must not equal t(2) to avoid a division-by-zero error.'
    RETURN
  END IF
  IF ( EqualRealNos( t(2), t(3) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in Morison_Input_ExtrapInterp: t(2) must not equal t(3) to avoid a division-by-zero error.'
    RETURN
  END IF
  IF ( EqualRealNos( t(1), t(3) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in Morison_Input_ExtrapInterp: t(1) must not equal t(3) to avoid a division-by-zero error.'
    RETURN
  END IF
  CALL MeshExtrapInterp2(u(1)%DistribMesh, u(2)%DistribMesh, u(3)%DistribMesh, tin, u_out%DistribMesh, tin_out, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'Morison_Input_ExtrapInterp:%DistribMesh')
         IF (ErrStat>=AbortErrLev) RETURN
  CALL MeshExtrapInterp2(u(1)%LumpedMesh, u(2)%LumpedMesh, u(3)%LumpedMesh, tin, u_out%LumpedMesh, tin_out, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'Morison_Input_ExtrapInterp:%LumpedMesh')
         IF (ErrStat>=AbortErrLev) RETURN
 ELSE 
   ErrStat = ErrID_Fatal
   ErrMsg = ' order must be less than 3 in Morison_Input_ExtrapInterp '
   RETURN
 ENDIF 
 END SUBROUTINE Morison_Input_ExtrapInterp


 SUBROUTINE Morison_Output_ExtrapInterp(u, tin, u_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) input u_out at time t_out, from previous/future time
! values of u (which has values associated with times in t).  Order of the interpolation is given by the size of u
!
!  expressions below based on either
!
!  f(t) = a
!  f(t) = a + b * t, or
!  f(t) = a + b * t + c * t**2
!
!  where a, b and c are determined as the solution to
!  f(t1) = u1, f(t2) = u2, f(t3) = u3  (as appropriate)
!
!..................................................................................................................................

 TYPE(Morison_outputtype), INTENT(INOUT)  :: u(:)      ! Inputs at t1 > t2 > t3
 REAL(DbKi),         INTENT(IN   )  :: tin(:)      ! Times associated with the inputs
 TYPE(Morison_outputtype), INTENT(INOUT)  :: u_out     ! Inputs at tin_out
 REAL(DbKi),         INTENT(IN   )  :: tin_out     ! time to be extrap/interp'd to
 INTEGER(IntKi),     INTENT(  OUT)  :: ErrStat   ! Error status of the operation
 CHARACTER(*),       INTENT(  OUT)  :: ErrMsg    ! Error message if ErrStat /= ErrID_None
   ! local variables
 REAL(DbKi) :: t(SIZE(tin))    ! Times associated with the inputs
 REAL(DbKi) :: t_out           ! Time to which to be extrap/interpd
 INTEGER(IntKi)                 :: order    ! order of polynomial fit (max 2)
 REAL(DbKi)                                 :: b0       ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: c0       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:)        :: b1       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:)        :: c1       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:)      :: b2       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:)      :: c2       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:)    :: b3       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:)    :: c3       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:,:)  :: b4       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:,:)  :: c4       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:,:,:):: b5       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:,:,:):: c5       ! temporary for extrapolation/interpolation
 INTEGER(IntKi)                             :: ErrStat2 ! local errors
 CHARACTER(1024)                            :: ErrMsg2  ! local errors
 INTEGER                                    :: i01    ! dim1 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i11    ! dim1 level 1 counter variable for arrays of ddts
 INTEGER                                    :: i21    ! dim1 level 2 counter variable for arrays of ddts
 INTEGER                                    :: i31    ! dim1 level 3 counter variable for arrays of ddts
 INTEGER                                    :: i41    ! dim1 level 4 counter variable for arrays of ddts
 INTEGER                                    :: i51    ! dim1 level 5 counter variable for arrays of ddts
 INTEGER                                    :: i61    ! dim1 level 6 counter variable for arrays of ddts
 INTEGER                                    :: i71    ! dim1 level 7 counter variable for arrays of ddts
 INTEGER                                    :: i81    ! dim1 level 8 counter variable for arrays of ddts
 INTEGER                                    :: i91    ! dim1 level 9 counter variable for arrays of ddts
 INTEGER                                    :: i02    ! dim2 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i12    ! dim2 level 1 counter variable for arrays of ddts
 INTEGER                                    :: i22    ! dim2 level 2 counter variable for arrays of ddts
 INTEGER                                    :: i32    ! dim2 level 3 counter variable for arrays of ddts
 INTEGER                                    :: i42    ! dim2 level 4 counter variable for arrays of ddts
 INTEGER                                    :: i52    ! dim2 level 5 counter variable for arrays of ddts
 INTEGER                                    :: i62    ! dim2 level 6 counter variable for arrays of ddts
 INTEGER                                    :: i72    ! dim2 level 7 counter variable for arrays of ddts
 INTEGER                                    :: i82    ! dim2 level 8 counter variable for arrays of ddts
 INTEGER                                    :: i92    ! dim2 level 9 counter variable for arrays of ddts
 INTEGER                                    :: i03    ! dim3 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i13    ! dim3 level 1 counter variable for arrays of ddts
 INTEGER                                    :: i23    ! dim3 level 2 counter variable for arrays of ddts
 INTEGER                                    :: i33    ! dim3 level 3 counter variable for arrays of ddts
 INTEGER                                    :: i43    ! dim3 level 4 counter variable for arrays of ddts
 INTEGER                                    :: i53    ! dim3 level 5 counter variable for arrays of ddts
 INTEGER                                    :: i63    ! dim3 level 6 counter variable for arrays of ddts
 INTEGER                                    :: i73    ! dim3 level 7 counter variable for arrays of ddts
 INTEGER                                    :: i83    ! dim3 level 8 counter variable for arrays of ddts
 INTEGER                                    :: i93    ! dim3 level 9 counter variable for arrays of ddts
 INTEGER                                    :: i04    ! dim4 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i14    ! dim4 level 1 counter variable for arrays of ddts
 INTEGER                                    :: i24    ! dim4 level 2 counter variable for arrays of ddts
 INTEGER                                    :: i34    ! dim4 level 3 counter variable for arrays of ddts
 INTEGER                                    :: i44    ! dim4 level 4 counter variable for arrays of ddts
 INTEGER                                    :: i54    ! dim4 level 5 counter variable for arrays of ddts
 INTEGER                                    :: i64    ! dim4 level 6 counter variable for arrays of ddts
 INTEGER                                    :: i74    ! dim4 level 7 counter variable for arrays of ddts
 INTEGER                                    :: i84    ! dim4 level 8 counter variable for arrays of ddts
 INTEGER                                    :: i94    ! dim4 level 9 counter variable for arrays of ddts
 INTEGER                                    :: i05    ! dim5 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i15    ! dim5 level 1 counter variable for arrays of ddts
 INTEGER                                    :: i25    ! dim5 level 2 counter variable for arrays of ddts
 INTEGER                                    :: i35    ! dim5 level 3 counter variable for arrays of ddts
 INTEGER                                    :: i45    ! dim5 level 4 counter variable for arrays of ddts
 INTEGER                                    :: i55    ! dim5 level 5 counter variable for arrays of ddts
 INTEGER                                    :: i65    ! dim5 level 6 counter variable for arrays of ddts
 INTEGER                                    :: i75    ! dim5 level 7 counter variable for arrays of ddts
 INTEGER                                    :: i85    ! dim5 level 8 counter variable for arrays of ddts
 INTEGER                                    :: i95    ! dim5 level 9 counter variable for arrays of ddts
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
    ! we'll subtract a constant from the times to resolve some 
    ! numerical issues when t gets large (and to simplify the equations)
 t = tin - tin(1)
 t_out = tin_out - tin(1)

 if ( size(t) .ne. size(u)) then
    ErrStat = ErrID_Fatal
    ErrMsg = ' Error in Morison_Output_ExtrapInterp: size(t) must equal size(u) '
    RETURN
 endif
 if (size(u) .gt. 3) then
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in Morison_Output_ExtrapInterp: size(u) must be less than 4 '
    RETURN
 endif
 order = SIZE(u) - 1
 IF ( order .eq. 0 ) THEN
  CALL MeshCopy(u(1)%DistribMesh, u_out%DistribMesh, MESH_UPDATECOPY, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'Morison_Output_ExtrapInterp:%DistribMesh')
         IF (ErrStat>=AbortErrLev) RETURN
  CALL MeshCopy(u(1)%LumpedMesh, u_out%LumpedMesh, MESH_UPDATECOPY, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'Morison_Output_ExtrapInterp:%LumpedMesh')
         IF (ErrStat>=AbortErrLev) RETURN
IF (ALLOCATED(u_out%WriteOutput) .AND. ALLOCATED(u(1)%WriteOutput)) THEN
  u_out%WriteOutput = u(1)%WriteOutput
END IF ! check if allocated
 ELSE IF ( order .eq. 1 ) THEN
  IF ( EqualRealNos( t(1), t(2) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in Morison_Output_ExtrapInterp: t(1) must not equal t(2) to avoid a division-by-zero error.'
    RETURN
  END IF
  CALL MeshExtrapInterp1(u(1)%DistribMesh, u(2)%DistribMesh, tin, u_out%DistribMesh, tin_out, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'Morison_Output_ExtrapInterp:%DistribMesh')
         IF (ErrStat>=AbortErrLev) RETURN
  CALL MeshExtrapInterp1(u(1)%LumpedMesh, u(2)%LumpedMesh, tin, u_out%LumpedMesh, tin_out, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'Morison_Output_ExtrapInterp:%LumpedMesh')
         IF (ErrStat>=AbortErrLev) RETURN
IF (ALLOCATED(u_out%WriteOutput) .AND. ALLOCATED(u(1)%WriteOutput)) THEN
  ALLOCATE(b1(SIZE(u_out%WriteOutput,1)))
  ALLOCATE(c1(SIZE(u_out%WriteOutput,1)))
  b1 = -(u(1)%WriteOutput - u(2)%WriteOutput)/t(2)
  u_out%WriteOutput = u(1)%WriteOutput + b1 * t_out
  DEALLOCATE(b1)
  DEALLOCATE(c1)
END IF ! check if allocated
 ELSE IF ( order .eq. 2 ) THEN
  IF ( EqualRealNos( t(1), t(2) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in Morison_Output_ExtrapInterp: t(1) must not equal t(2) to avoid a division-by-zero error.'
    RETURN
  END IF
  IF ( EqualRealNos( t(2), t(3) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in Morison_Output_ExtrapInterp: t(2) must not equal t(3) to avoid a division-by-zero error.'
    RETURN
  END IF
  IF ( EqualRealNos( t(1), t(3) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in Morison_Output_ExtrapInterp: t(1) must not equal t(3) to avoid a division-by-zero error.'
    RETURN
  END IF
  CALL MeshExtrapInterp2(u(1)%DistribMesh, u(2)%DistribMesh, u(3)%DistribMesh, tin, u_out%DistribMesh, tin_out, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'Morison_Output_ExtrapInterp:%DistribMesh')
         IF (ErrStat>=AbortErrLev) RETURN
  CALL MeshExtrapInterp2(u(1)%LumpedMesh, u(2)%LumpedMesh, u(3)%LumpedMesh, tin, u_out%LumpedMesh, tin_out, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'Morison_Output_ExtrapInterp:%LumpedMesh')
         IF (ErrStat>=AbortErrLev) RETURN
IF (ALLOCATED(u_out%WriteOutput) .AND. ALLOCATED(u(1)%WriteOutput)) THEN
  ALLOCATE(b1(SIZE(u_out%WriteOutput,1)))
  ALLOCATE(c1(SIZE(u_out%WriteOutput,1)))
  b1 = (t(3)**2*(u(1)%WriteOutput - u(2)%WriteOutput) + t(2)**2*(-u(1)%WriteOutput + u(3)%WriteOutput))/(t(2)*t(3)*(t(2) - t(3)))
  c1 = ( (t(2)-t(3))*u(1)%WriteOutput + t(3)*u(2)%WriteOutput - t(2)*u(3)%WriteOutput ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%WriteOutput = u(1)%WriteOutput + b1 * t_out + c1 * t_out**2
  DEALLOCATE(b1)
  DEALLOCATE(c1)
END IF ! check if allocated
 ELSE 
   ErrStat = ErrID_Fatal
   ErrMsg = ' order must be less than 3 in Morison_Output_ExtrapInterp '
   RETURN
 ENDIF 
 END SUBROUTINE Morison_Output_ExtrapInterp

END MODULE Morison_Types
!ENDOFREGISTRYGENERATEDFILE
