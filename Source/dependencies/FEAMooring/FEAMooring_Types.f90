!STARTOFREGISTRYGENERATEDFILE './FEAMooring_Types.f90'
!
! WARNING This file is generated automatically by the FAST registry
! Do not edit.  Your changes to this file will be lost.
!
!*********************************************************************************************************************************
! FEAMooring_Types
!.................................................................................................................................
! LICENSING
! Copyright (C) 2012 National Renewable Energy Laboratory
!
! This file is part of FEAMooring.
!
! FEAMooring is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as
! published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
!
! This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty
! of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
!
! You should have received a copy of the GNU General Public License along with ModuleName.
! If not, see <http://www.gnu.org/licenses/>.
!
!
! W A R N I N G : This file was automatically generated from the FAST registry.  Changes made to this file may be lost.
!
!*********************************************************************************************************************************
MODULE FEAMooring_Types
! This module contains all of the user-defined types needed in FEAMooring. It also contains copy, destroy, pack, and
! unpack routines associated with each defined data type. This code will be generated by the FAST Registry.
!---------------------------------------------------------------------------------------------------------------------------------
USE NWTC_Library
IMPLICIT NONE
  TYPE, PUBLIC :: FEAM_InputFile
    REAL(DbKi)  :: DT 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: LEAStiff 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: LMassDen 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: LDMassDen 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: LineCI 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: LineCD 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: BottmElev 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: BottmStiff 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: LRadAnch 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: LAngAnch 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: LDpthAnch 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: LRadFair 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: LAngFair 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: LDrftFair 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: LDiam 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: LUnstrLen 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: Tension 
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: GSL 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: GSR 
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: GE 
    INTEGER(IntKi)  :: NumLines 
    INTEGER(IntKi)  :: NumElems 
    LOGICAL  :: SumPrint 
    INTEGER(IntKi)  :: OutFile 
    LOGICAL  :: TabDelim 
    CHARACTER(20)  :: OutFmt 
    REAL(DbKi)  :: Tstart 
    INTEGER(IntKi)  :: NumOuts 
    CHARACTER(10) , DIMENSION(:), ALLOCATABLE  :: OutList 
  END TYPE FEAM_InputFile
  TYPE, PUBLIC :: FEAM_InitInputType
    CHARACTER(1024)  :: InputFile 
    CHARACTER(1024)  :: RootName 
    REAL(ReKi) , DIMENSION(1:6)  :: PtfmInit 
  END TYPE FEAM_InitInputType
  TYPE, PUBLIC :: FEAM_InitOutputType
    CHARACTER(10) , DIMENSION(:), ALLOCATABLE  :: WriteOutputHdr 
    CHARACTER(10) , DIMENSION(:), ALLOCATABLE  :: WriteOutputUnt 
    TYPE(ProgDesc)  :: Ver 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: LAnchxi 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: LAnchyi 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: LAnchzi 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: LFairxt 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: LFairyt 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: LFairzt 
  END TYPE FEAM_InitOutputType
  TYPE, PUBLIC :: FEAM_ContinuousStateType
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: GLU 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: GLDU 
  END TYPE FEAM_ContinuousStateType
  TYPE, PUBLIC :: FEAM_DiscreteStateType
    REAL(ReKi)  :: DummyDiscState 
  END TYPE FEAM_DiscreteStateType
  TYPE, PUBLIC :: FEAM_ConstraintStateType
    REAL(ReKi) , DIMENSION(1:3)  :: TSN 
    REAL(ReKi) , DIMENSION(1:3)  :: TZER 
  END TYPE FEAM_ConstraintStateType
  TYPE, PUBLIC :: FEAM_OtherStateType
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: GLU0 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: GLDDU 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: GLF 
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: GLK 
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: GLUZR 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: GTZER 
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: GFORC0 
    REAL(ReKi) , DIMENSION(:,:,:,:), ALLOCATABLE  :: GMASS0 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: FAST_FP 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: FAST_FPA 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: FAIR_T 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: FAST_RP 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: ANCH_T 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: FAIR_ANG 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: ANCH_ANG 
    REAL(ReKi) , DIMENSION(1:15,1:15)  :: ESTIF 
    REAL(ReKi) , DIMENSION(1:15,1:15)  :: EMASS 
    REAL(ReKi) , DIMENSION(1:15)  :: FORCE 
    REAL(ReKi) , DIMENSION(1:15)  :: RSDF 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: F_Lines 
    REAL(ReKi) , DIMENSION(1:3,1:4)  :: U 
    REAL(ReKi) , DIMENSION(1:3,1:4)  :: U0 
    REAL(ReKi) , DIMENSION(1:3,1:4)  :: DU 
    REAL(ReKi) , DIMENSION(1:3,1:4)  :: DDU 
    REAL(ReKi) , DIMENSION(1:15)  :: FORC0 
    REAL(ReKi) , DIMENSION(1:15,1:15)  :: EMAS0 
    INTEGER(IntKi)  :: INCR 
    LOGICAL  :: BottomTouch 
    LOGICAL  :: Iteration1 
    LOGICAL  :: Iteration2 
    REAL(ReKi) , DIMENSION(1:3)  :: R 
    REAL(ReKi) , DIMENSION(1:3)  :: RP 
    REAL(ReKi) , DIMENSION(1:3)  :: FP 
    REAL(ReKi) , DIMENSION(1:3)  :: SLIN 
    REAL(ReKi) , DIMENSION(1:6,1:6)  :: STIFR 
    REAL(ReKi) , DIMENSION(1:6)  :: RHSR 
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: Line_Coordinate 
  END TYPE FEAM_OtherStateType
  TYPE, PUBLIC :: FEAM_ParameterType
    REAL(DbKi)  :: DT 
    REAL(ReKi) , DIMENSION(1:3)  :: GRAV 
    REAL(ReKi)  :: EPS 
    REAL(ReKi)  :: Gravity 
    REAL(ReKi)  :: WtrDens 
    INTEGER(IntKi)  :: MITER 
    INTEGER(IntKi)  :: NHBD 
    INTEGER(IntKi)  :: NDIM 
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: NEQ 
    INTEGER(IntKi)  :: NBAND 
    LOGICAL  :: DYN 
    INTEGER(IntKi)  :: NumLines 
    INTEGER(IntKi)  :: NumElems 
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: GSL 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: GP 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: LineCI 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: LineCD 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: SectionA 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: Elength 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: BottmElev 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: BottmStiff 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: LMassDen 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: LDMassDen 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: LEAStiff 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: Bvp 
    REAL(ReKi) , DIMENSION(1:6,1:4)  :: SHAP 
    REAL(ReKi) , DIMENSION(1:6,1:4)  :: SHAPS 
    REAL(ReKi) , DIMENSION(1:6)  :: GAUSSW 
    INTEGER(IntKi)  :: NGAUSS 
    REAL(ReKi) , DIMENSION(1:10,1:4)  :: SHAPT 
    REAL(ReKi) , DIMENSION(1:10,1:4)  :: SHAPTS 
    REAL(ReKi)  :: NTRAP 
    REAL(ReKi) , DIMENSION(1:4,1:4)  :: SBEND 
    REAL(ReKi) , DIMENSION(1:3,1:4,1:4)  :: STEN 
    REAL(ReKi) , DIMENSION(1:4,1:4)  :: RMASS 
    REAL(ReKi) , DIMENSION(1:4,1:4,1:4,1:4)  :: RADDM 
    REAL(ReKi) , DIMENSION(1:3,1:3)  :: PMPN 
    REAL(ReKi) , DIMENSION(1:4)  :: AM 
    REAL(ReKi) , DIMENSION(1:3)  :: PM 
    INTEGER(IntKi) , DIMENSION(1:3,1:4)  :: IDOF 
    INTEGER(IntKi) , DIMENSION(1:3)  :: JDOF 
    REAL(ReKi) , DIMENSION(1:3,1:3,1:4)  :: PPA 
    REAL(ReKi)  :: PtfmRefzt 
    INTEGER(IntKi)  :: NumOuts 
    CHARACTER(1024)  :: RootName 
    TYPE(OutParmType) , DIMENSION(:), ALLOCATABLE  :: OutParam 
    CHARACTER(1)  :: Delim 
  END TYPE FEAM_ParameterType
  TYPE, PUBLIC :: FEAM_InputType
    TYPE(MeshType)  :: HydroForceLineMesh 
    TYPE(MeshType)  :: PtFairleadDisplacement 
  END TYPE FEAM_InputType
  TYPE, PUBLIC :: FEAM_OutputType
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: WriteOutput 
    TYPE(MeshType)  :: PtFairleadLoad 
    TYPE(MeshType)  :: LineMeshPosition 
  END TYPE FEAM_OutputType
CONTAINS
 SUBROUTINE FEAM_Copyinputfile( SrcinputfileData, DstinputfileData, CtrlCode, ErrStat, ErrMsg )
  TYPE(feam_inputfile), INTENT(INOUT) :: SrcinputfileData
  TYPE(feam_inputfile), INTENT(INOUT) :: DstinputfileData
  INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  DstinputfileData%DT = SrcinputfileData%DT
IF ( ALLOCATED( SrcinputfileData%LEAStiff ) ) THEN
  i1 = SIZE(SrcinputfileData%LEAStiff,1)
  IF (.NOT.ALLOCATED(DstinputfileData%LEAStiff)) ALLOCATE(DstinputfileData%LEAStiff(i1))
  DstinputfileData%LEAStiff = SrcinputfileData%LEAStiff
ENDIF
IF ( ALLOCATED( SrcinputfileData%LMassDen ) ) THEN
  i1 = SIZE(SrcinputfileData%LMassDen,1)
  IF (.NOT.ALLOCATED(DstinputfileData%LMassDen)) ALLOCATE(DstinputfileData%LMassDen(i1))
  DstinputfileData%LMassDen = SrcinputfileData%LMassDen
ENDIF
IF ( ALLOCATED( SrcinputfileData%LDMassDen ) ) THEN
  i1 = SIZE(SrcinputfileData%LDMassDen,1)
  IF (.NOT.ALLOCATED(DstinputfileData%LDMassDen)) ALLOCATE(DstinputfileData%LDMassDen(i1))
  DstinputfileData%LDMassDen = SrcinputfileData%LDMassDen
ENDIF
IF ( ALLOCATED( SrcinputfileData%LineCI ) ) THEN
  i1 = SIZE(SrcinputfileData%LineCI,1)
  IF (.NOT.ALLOCATED(DstinputfileData%LineCI)) ALLOCATE(DstinputfileData%LineCI(i1))
  DstinputfileData%LineCI = SrcinputfileData%LineCI
ENDIF
IF ( ALLOCATED( SrcinputfileData%LineCD ) ) THEN
  i1 = SIZE(SrcinputfileData%LineCD,1)
  IF (.NOT.ALLOCATED(DstinputfileData%LineCD)) ALLOCATE(DstinputfileData%LineCD(i1))
  DstinputfileData%LineCD = SrcinputfileData%LineCD
ENDIF
IF ( ALLOCATED( SrcinputfileData%BottmElev ) ) THEN
  i1 = SIZE(SrcinputfileData%BottmElev,1)
  IF (.NOT.ALLOCATED(DstinputfileData%BottmElev)) ALLOCATE(DstinputfileData%BottmElev(i1))
  DstinputfileData%BottmElev = SrcinputfileData%BottmElev
ENDIF
IF ( ALLOCATED( SrcinputfileData%BottmStiff ) ) THEN
  i1 = SIZE(SrcinputfileData%BottmStiff,1)
  IF (.NOT.ALLOCATED(DstinputfileData%BottmStiff)) ALLOCATE(DstinputfileData%BottmStiff(i1))
  DstinputfileData%BottmStiff = SrcinputfileData%BottmStiff
ENDIF
IF ( ALLOCATED( SrcinputfileData%LRadAnch ) ) THEN
  i1 = SIZE(SrcinputfileData%LRadAnch,1)
  IF (.NOT.ALLOCATED(DstinputfileData%LRadAnch)) ALLOCATE(DstinputfileData%LRadAnch(i1))
  DstinputfileData%LRadAnch = SrcinputfileData%LRadAnch
ENDIF
IF ( ALLOCATED( SrcinputfileData%LAngAnch ) ) THEN
  i1 = SIZE(SrcinputfileData%LAngAnch,1)
  IF (.NOT.ALLOCATED(DstinputfileData%LAngAnch)) ALLOCATE(DstinputfileData%LAngAnch(i1))
  DstinputfileData%LAngAnch = SrcinputfileData%LAngAnch
ENDIF
IF ( ALLOCATED( SrcinputfileData%LDpthAnch ) ) THEN
  i1 = SIZE(SrcinputfileData%LDpthAnch,1)
  IF (.NOT.ALLOCATED(DstinputfileData%LDpthAnch)) ALLOCATE(DstinputfileData%LDpthAnch(i1))
  DstinputfileData%LDpthAnch = SrcinputfileData%LDpthAnch
ENDIF
IF ( ALLOCATED( SrcinputfileData%LRadFair ) ) THEN
  i1 = SIZE(SrcinputfileData%LRadFair,1)
  IF (.NOT.ALLOCATED(DstinputfileData%LRadFair)) ALLOCATE(DstinputfileData%LRadFair(i1))
  DstinputfileData%LRadFair = SrcinputfileData%LRadFair
ENDIF
IF ( ALLOCATED( SrcinputfileData%LAngFair ) ) THEN
  i1 = SIZE(SrcinputfileData%LAngFair,1)
  IF (.NOT.ALLOCATED(DstinputfileData%LAngFair)) ALLOCATE(DstinputfileData%LAngFair(i1))
  DstinputfileData%LAngFair = SrcinputfileData%LAngFair
ENDIF
IF ( ALLOCATED( SrcinputfileData%LDrftFair ) ) THEN
  i1 = SIZE(SrcinputfileData%LDrftFair,1)
  IF (.NOT.ALLOCATED(DstinputfileData%LDrftFair)) ALLOCATE(DstinputfileData%LDrftFair(i1))
  DstinputfileData%LDrftFair = SrcinputfileData%LDrftFair
ENDIF
IF ( ALLOCATED( SrcinputfileData%LDiam ) ) THEN
  i1 = SIZE(SrcinputfileData%LDiam,1)
  IF (.NOT.ALLOCATED(DstinputfileData%LDiam)) ALLOCATE(DstinputfileData%LDiam(i1))
  DstinputfileData%LDiam = SrcinputfileData%LDiam
ENDIF
IF ( ALLOCATED( SrcinputfileData%LUnstrLen ) ) THEN
  i1 = SIZE(SrcinputfileData%LUnstrLen,1)
  IF (.NOT.ALLOCATED(DstinputfileData%LUnstrLen)) ALLOCATE(DstinputfileData%LUnstrLen(i1))
  DstinputfileData%LUnstrLen = SrcinputfileData%LUnstrLen
ENDIF
IF ( ALLOCATED( SrcinputfileData%Tension ) ) THEN
  i1 = SIZE(SrcinputfileData%Tension,1)
  IF (.NOT.ALLOCATED(DstinputfileData%Tension)) ALLOCATE(DstinputfileData%Tension(i1))
  DstinputfileData%Tension = SrcinputfileData%Tension
ENDIF
IF ( ALLOCATED( SrcinputfileData%GSL ) ) THEN
  i1 = SIZE(SrcinputfileData%GSL,1)
  i2 = SIZE(SrcinputfileData%GSL,2)
  i3 = SIZE(SrcinputfileData%GSL,3)
  IF (.NOT.ALLOCATED(DstinputfileData%GSL)) ALLOCATE(DstinputfileData%GSL(i1,i2,i3))
  DstinputfileData%GSL = SrcinputfileData%GSL
ENDIF
IF ( ALLOCATED( SrcinputfileData%GSR ) ) THEN
  i1 = SIZE(SrcinputfileData%GSR,1)
  i2 = SIZE(SrcinputfileData%GSR,2)
  IF (.NOT.ALLOCATED(DstinputfileData%GSR)) ALLOCATE(DstinputfileData%GSR(i1,i2))
  DstinputfileData%GSR = SrcinputfileData%GSR
ENDIF
IF ( ALLOCATED( SrcinputfileData%GE ) ) THEN
  i1 = SIZE(SrcinputfileData%GE,1)
  i2 = SIZE(SrcinputfileData%GE,2)
  i3 = SIZE(SrcinputfileData%GE,3)
  IF (.NOT.ALLOCATED(DstinputfileData%GE)) ALLOCATE(DstinputfileData%GE(i1,i2,i3))
  DstinputfileData%GE = SrcinputfileData%GE
ENDIF
  DstinputfileData%NumLines = SrcinputfileData%NumLines
  DstinputfileData%NumElems = SrcinputfileData%NumElems
  DstinputfileData%SumPrint = SrcinputfileData%SumPrint
  DstinputfileData%OutFile = SrcinputfileData%OutFile
  DstinputfileData%TabDelim = SrcinputfileData%TabDelim
  DstinputfileData%OutFmt = SrcinputfileData%OutFmt
  DstinputfileData%Tstart = SrcinputfileData%Tstart
  DstinputfileData%NumOuts = SrcinputfileData%NumOuts
IF ( ALLOCATED( SrcinputfileData%OutList ) ) THEN
  i1 = SIZE(SrcinputfileData%OutList,1)
  IF (.NOT.ALLOCATED(DstinputfileData%OutList)) ALLOCATE(DstinputfileData%OutList(i1))
  DstinputfileData%OutList = SrcinputfileData%OutList
ENDIF
 END SUBROUTINE FEAM_Copyinputfile

 SUBROUTINE FEAM_Destroyinputfile( inputfileData, ErrStat, ErrMsg )
  TYPE(feam_inputfile), INTENT(INOUT) :: inputfileData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  IF ( ALLOCATED(inputfileData%LEAStiff) ) DEALLOCATE(inputfileData%LEAStiff)
  IF ( ALLOCATED(inputfileData%LMassDen) ) DEALLOCATE(inputfileData%LMassDen)
  IF ( ALLOCATED(inputfileData%LDMassDen) ) DEALLOCATE(inputfileData%LDMassDen)
  IF ( ALLOCATED(inputfileData%LineCI) ) DEALLOCATE(inputfileData%LineCI)
  IF ( ALLOCATED(inputfileData%LineCD) ) DEALLOCATE(inputfileData%LineCD)
  IF ( ALLOCATED(inputfileData%BottmElev) ) DEALLOCATE(inputfileData%BottmElev)
  IF ( ALLOCATED(inputfileData%BottmStiff) ) DEALLOCATE(inputfileData%BottmStiff)
  IF ( ALLOCATED(inputfileData%LRadAnch) ) DEALLOCATE(inputfileData%LRadAnch)
  IF ( ALLOCATED(inputfileData%LAngAnch) ) DEALLOCATE(inputfileData%LAngAnch)
  IF ( ALLOCATED(inputfileData%LDpthAnch) ) DEALLOCATE(inputfileData%LDpthAnch)
  IF ( ALLOCATED(inputfileData%LRadFair) ) DEALLOCATE(inputfileData%LRadFair)
  IF ( ALLOCATED(inputfileData%LAngFair) ) DEALLOCATE(inputfileData%LAngFair)
  IF ( ALLOCATED(inputfileData%LDrftFair) ) DEALLOCATE(inputfileData%LDrftFair)
  IF ( ALLOCATED(inputfileData%LDiam) ) DEALLOCATE(inputfileData%LDiam)
  IF ( ALLOCATED(inputfileData%LUnstrLen) ) DEALLOCATE(inputfileData%LUnstrLen)
  IF ( ALLOCATED(inputfileData%Tension) ) DEALLOCATE(inputfileData%Tension)
  IF ( ALLOCATED(inputfileData%GSL) ) DEALLOCATE(inputfileData%GSL)
  IF ( ALLOCATED(inputfileData%GSR) ) DEALLOCATE(inputfileData%GSR)
  IF ( ALLOCATED(inputfileData%GE) ) DEALLOCATE(inputfileData%GE)
  IF ( ALLOCATED(inputfileData%OutList) ) DEALLOCATE(inputfileData%OutList)
 END SUBROUTINE FEAM_Destroyinputfile

 SUBROUTINE FEAM_Packinputfile( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(feam_inputfile),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Db_BufSz   = Db_BufSz   + 1  ! DT
  Re_BufSz    = Re_BufSz    + SIZE( InData%LEAStiff )  ! LEAStiff 
  Re_BufSz    = Re_BufSz    + SIZE( InData%LMassDen )  ! LMassDen 
  Re_BufSz    = Re_BufSz    + SIZE( InData%LDMassDen )  ! LDMassDen 
  Re_BufSz    = Re_BufSz    + SIZE( InData%LineCI )  ! LineCI 
  Re_BufSz    = Re_BufSz    + SIZE( InData%LineCD )  ! LineCD 
  Re_BufSz    = Re_BufSz    + SIZE( InData%BottmElev )  ! BottmElev 
  Re_BufSz    = Re_BufSz    + SIZE( InData%BottmStiff )  ! BottmStiff 
  Re_BufSz    = Re_BufSz    + SIZE( InData%LRadAnch )  ! LRadAnch 
  Re_BufSz    = Re_BufSz    + SIZE( InData%LAngAnch )  ! LAngAnch 
  Re_BufSz    = Re_BufSz    + SIZE( InData%LDpthAnch )  ! LDpthAnch 
  Re_BufSz    = Re_BufSz    + SIZE( InData%LRadFair )  ! LRadFair 
  Re_BufSz    = Re_BufSz    + SIZE( InData%LAngFair )  ! LAngFair 
  Re_BufSz    = Re_BufSz    + SIZE( InData%LDrftFair )  ! LDrftFair 
  Re_BufSz    = Re_BufSz    + SIZE( InData%LDiam )  ! LDiam 
  Re_BufSz    = Re_BufSz    + SIZE( InData%LUnstrLen )  ! LUnstrLen 
  Re_BufSz    = Re_BufSz    + SIZE( InData%Tension )  ! Tension 
  Re_BufSz    = Re_BufSz    + SIZE( InData%GSL )  ! GSL 
  Re_BufSz    = Re_BufSz    + SIZE( InData%GSR )  ! GSR 
  Re_BufSz    = Re_BufSz    + SIZE( InData%GE )  ! GE 
  Int_BufSz  = Int_BufSz  + 1  ! NumLines
  Int_BufSz  = Int_BufSz  + 1  ! NumElems
  Int_BufSz  = Int_BufSz  + 1  ! OutFile
  Db_BufSz   = Db_BufSz   + 1  ! Tstart
  Int_BufSz  = Int_BufSz  + 1  ! NumOuts
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(1)-1 ) =  (InData%DT )
  Db_Xferred   = Db_Xferred   + 1
  IF ( ALLOCATED(InData%LEAStiff) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%LEAStiff))-1 ) =  PACK(InData%LEAStiff ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%LEAStiff)
  ENDIF
  IF ( ALLOCATED(InData%LMassDen) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%LMassDen))-1 ) =  PACK(InData%LMassDen ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%LMassDen)
  ENDIF
  IF ( ALLOCATED(InData%LDMassDen) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%LDMassDen))-1 ) =  PACK(InData%LDMassDen ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%LDMassDen)
  ENDIF
  IF ( ALLOCATED(InData%LineCI) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%LineCI))-1 ) =  PACK(InData%LineCI ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%LineCI)
  ENDIF
  IF ( ALLOCATED(InData%LineCD) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%LineCD))-1 ) =  PACK(InData%LineCD ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%LineCD)
  ENDIF
  IF ( ALLOCATED(InData%BottmElev) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%BottmElev))-1 ) =  PACK(InData%BottmElev ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%BottmElev)
  ENDIF
  IF ( ALLOCATED(InData%BottmStiff) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%BottmStiff))-1 ) =  PACK(InData%BottmStiff ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%BottmStiff)
  ENDIF
  IF ( ALLOCATED(InData%LRadAnch) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%LRadAnch))-1 ) =  PACK(InData%LRadAnch ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%LRadAnch)
  ENDIF
  IF ( ALLOCATED(InData%LAngAnch) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%LAngAnch))-1 ) =  PACK(InData%LAngAnch ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%LAngAnch)
  ENDIF
  IF ( ALLOCATED(InData%LDpthAnch) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%LDpthAnch))-1 ) =  PACK(InData%LDpthAnch ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%LDpthAnch)
  ENDIF
  IF ( ALLOCATED(InData%LRadFair) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%LRadFair))-1 ) =  PACK(InData%LRadFair ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%LRadFair)
  ENDIF
  IF ( ALLOCATED(InData%LAngFair) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%LAngFair))-1 ) =  PACK(InData%LAngFair ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%LAngFair)
  ENDIF
  IF ( ALLOCATED(InData%LDrftFair) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%LDrftFair))-1 ) =  PACK(InData%LDrftFair ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%LDrftFair)
  ENDIF
  IF ( ALLOCATED(InData%LDiam) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%LDiam))-1 ) =  PACK(InData%LDiam ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%LDiam)
  ENDIF
  IF ( ALLOCATED(InData%LUnstrLen) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%LUnstrLen))-1 ) =  PACK(InData%LUnstrLen ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%LUnstrLen)
  ENDIF
  IF ( ALLOCATED(InData%Tension) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Tension))-1 ) =  PACK(InData%Tension ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%Tension)
  ENDIF
  IF ( ALLOCATED(InData%GSL) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%GSL))-1 ) =  PACK(InData%GSL ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%GSL)
  ENDIF
  IF ( ALLOCATED(InData%GSR) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%GSR))-1 ) =  PACK(InData%GSR ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%GSR)
  ENDIF
  IF ( ALLOCATED(InData%GE) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%GE))-1 ) =  PACK(InData%GE ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%GE)
  ENDIF
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NumLines )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NumElems )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%OutFile )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(1)-1 ) =  (InData%Tstart )
  Db_Xferred   = Db_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NumOuts )
  Int_Xferred   = Int_Xferred   + 1
 END SUBROUTINE FEAM_Packinputfile

 SUBROUTINE FEAM_Unpackinputfile( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(feam_inputfile), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  OutData%DT = DbKiBuf ( Db_Xferred )
  Db_Xferred   = Db_Xferred   + 1
  IF ( ALLOCATED(OutData%LEAStiff) ) THEN
  ALLOCATE(mask1(SIZE(OutData%LEAStiff,1))); mask1 = .TRUE.
    OutData%LEAStiff = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%LEAStiff))-1 ),mask1,OutData%LEAStiff)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%LEAStiff)
  ENDIF
  IF ( ALLOCATED(OutData%LMassDen) ) THEN
  ALLOCATE(mask1(SIZE(OutData%LMassDen,1))); mask1 = .TRUE.
    OutData%LMassDen = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%LMassDen))-1 ),mask1,OutData%LMassDen)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%LMassDen)
  ENDIF
  IF ( ALLOCATED(OutData%LDMassDen) ) THEN
  ALLOCATE(mask1(SIZE(OutData%LDMassDen,1))); mask1 = .TRUE.
    OutData%LDMassDen = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%LDMassDen))-1 ),mask1,OutData%LDMassDen)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%LDMassDen)
  ENDIF
  IF ( ALLOCATED(OutData%LineCI) ) THEN
  ALLOCATE(mask1(SIZE(OutData%LineCI,1))); mask1 = .TRUE.
    OutData%LineCI = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%LineCI))-1 ),mask1,OutData%LineCI)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%LineCI)
  ENDIF
  IF ( ALLOCATED(OutData%LineCD) ) THEN
  ALLOCATE(mask1(SIZE(OutData%LineCD,1))); mask1 = .TRUE.
    OutData%LineCD = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%LineCD))-1 ),mask1,OutData%LineCD)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%LineCD)
  ENDIF
  IF ( ALLOCATED(OutData%BottmElev) ) THEN
  ALLOCATE(mask1(SIZE(OutData%BottmElev,1))); mask1 = .TRUE.
    OutData%BottmElev = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%BottmElev))-1 ),mask1,OutData%BottmElev)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%BottmElev)
  ENDIF
  IF ( ALLOCATED(OutData%BottmStiff) ) THEN
  ALLOCATE(mask1(SIZE(OutData%BottmStiff,1))); mask1 = .TRUE.
    OutData%BottmStiff = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%BottmStiff))-1 ),mask1,OutData%BottmStiff)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%BottmStiff)
  ENDIF
  IF ( ALLOCATED(OutData%LRadAnch) ) THEN
  ALLOCATE(mask1(SIZE(OutData%LRadAnch,1))); mask1 = .TRUE.
    OutData%LRadAnch = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%LRadAnch))-1 ),mask1,OutData%LRadAnch)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%LRadAnch)
  ENDIF
  IF ( ALLOCATED(OutData%LAngAnch) ) THEN
  ALLOCATE(mask1(SIZE(OutData%LAngAnch,1))); mask1 = .TRUE.
    OutData%LAngAnch = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%LAngAnch))-1 ),mask1,OutData%LAngAnch)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%LAngAnch)
  ENDIF
  IF ( ALLOCATED(OutData%LDpthAnch) ) THEN
  ALLOCATE(mask1(SIZE(OutData%LDpthAnch,1))); mask1 = .TRUE.
    OutData%LDpthAnch = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%LDpthAnch))-1 ),mask1,OutData%LDpthAnch)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%LDpthAnch)
  ENDIF
  IF ( ALLOCATED(OutData%LRadFair) ) THEN
  ALLOCATE(mask1(SIZE(OutData%LRadFair,1))); mask1 = .TRUE.
    OutData%LRadFair = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%LRadFair))-1 ),mask1,OutData%LRadFair)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%LRadFair)
  ENDIF
  IF ( ALLOCATED(OutData%LAngFair) ) THEN
  ALLOCATE(mask1(SIZE(OutData%LAngFair,1))); mask1 = .TRUE.
    OutData%LAngFair = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%LAngFair))-1 ),mask1,OutData%LAngFair)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%LAngFair)
  ENDIF
  IF ( ALLOCATED(OutData%LDrftFair) ) THEN
  ALLOCATE(mask1(SIZE(OutData%LDrftFair,1))); mask1 = .TRUE.
    OutData%LDrftFair = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%LDrftFair))-1 ),mask1,OutData%LDrftFair)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%LDrftFair)
  ENDIF
  IF ( ALLOCATED(OutData%LDiam) ) THEN
  ALLOCATE(mask1(SIZE(OutData%LDiam,1))); mask1 = .TRUE.
    OutData%LDiam = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%LDiam))-1 ),mask1,OutData%LDiam)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%LDiam)
  ENDIF
  IF ( ALLOCATED(OutData%LUnstrLen) ) THEN
  ALLOCATE(mask1(SIZE(OutData%LUnstrLen,1))); mask1 = .TRUE.
    OutData%LUnstrLen = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%LUnstrLen))-1 ),mask1,OutData%LUnstrLen)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%LUnstrLen)
  ENDIF
  IF ( ALLOCATED(OutData%Tension) ) THEN
  ALLOCATE(mask1(SIZE(OutData%Tension,1))); mask1 = .TRUE.
    OutData%Tension = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Tension))-1 ),mask1,OutData%Tension)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%Tension)
  ENDIF
  IF ( ALLOCATED(OutData%GSL) ) THEN
  ALLOCATE(mask3(SIZE(OutData%GSL,1),SIZE(OutData%GSL,2),SIZE(OutData%GSL,3))); mask3 = .TRUE.
    OutData%GSL = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%GSL))-1 ),mask3,OutData%GSL)
  DEALLOCATE(mask3)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%GSL)
  ENDIF
  IF ( ALLOCATED(OutData%GSR) ) THEN
  ALLOCATE(mask2(SIZE(OutData%GSR,1),SIZE(OutData%GSR,2))); mask2 = .TRUE.
    OutData%GSR = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%GSR))-1 ),mask2,OutData%GSR)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%GSR)
  ENDIF
  IF ( ALLOCATED(OutData%GE) ) THEN
  ALLOCATE(mask3(SIZE(OutData%GE,1),SIZE(OutData%GE,2),SIZE(OutData%GE,3))); mask3 = .TRUE.
    OutData%GE = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%GE))-1 ),mask3,OutData%GE)
  DEALLOCATE(mask3)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%GE)
  ENDIF
  OutData%NumLines = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%NumElems = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%OutFile = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%Tstart = DbKiBuf ( Db_Xferred )
  Db_Xferred   = Db_Xferred   + 1
  OutData%NumOuts = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE FEAM_Unpackinputfile

 SUBROUTINE FEAM_CopyInitInput( SrcInitInputData, DstInitInputData, CtrlCode, ErrStat, ErrMsg )
  TYPE(FEAM_initinputtype), INTENT(INOUT) :: SrcInitInputData
  TYPE(FEAM_initinputtype), INTENT(INOUT) :: DstInitInputData
  INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  DstInitInputData%InputFile = SrcInitInputData%InputFile
  DstInitInputData%RootName = SrcInitInputData%RootName
  DstInitInputData%PtfmInit = SrcInitInputData%PtfmInit
 END SUBROUTINE FEAM_CopyInitInput

 SUBROUTINE FEAM_DestroyInitInput( InitInputData, ErrStat, ErrMsg )
  TYPE(FEAM_initinputtype), INTENT(INOUT) :: InitInputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
 END SUBROUTINE FEAM_DestroyInitInput

 SUBROUTINE FEAM_PackInitInput( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(FEAM_initinputtype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Re_BufSz    = Re_BufSz    + SIZE( InData%PtfmInit )  ! PtfmInit 
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%PtfmInit))-1 ) =  PACK(InData%PtfmInit ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%PtfmInit)
 END SUBROUTINE FEAM_PackInitInput

 SUBROUTINE FEAM_UnpackInitInput( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(FEAM_initinputtype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  ALLOCATE(mask1(SIZE(OutData%PtfmInit,1))); mask1 = .TRUE.
  OutData%PtfmInit = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%PtfmInit))-1 ),mask1,OutData%PtfmInit)
  DEALLOCATE(mask1)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%PtfmInit)
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE FEAM_UnpackInitInput

 SUBROUTINE FEAM_CopyInitOutput( SrcInitOutputData, DstInitOutputData, CtrlCode, ErrStat, ErrMsg )
  TYPE(FEAM_initoutputtype), INTENT(INOUT) :: SrcInitOutputData
  TYPE(FEAM_initoutputtype), INTENT(INOUT) :: DstInitOutputData
  INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF ( ALLOCATED( SrcInitOutputData%WriteOutputHdr ) ) THEN
  i1 = SIZE(SrcInitOutputData%WriteOutputHdr,1)
  IF (.NOT.ALLOCATED(DstInitOutputData%WriteOutputHdr)) ALLOCATE(DstInitOutputData%WriteOutputHdr(i1))
  DstInitOutputData%WriteOutputHdr = SrcInitOutputData%WriteOutputHdr
ENDIF
IF ( ALLOCATED( SrcInitOutputData%WriteOutputUnt ) ) THEN
  i1 = SIZE(SrcInitOutputData%WriteOutputUnt,1)
  IF (.NOT.ALLOCATED(DstInitOutputData%WriteOutputUnt)) ALLOCATE(DstInitOutputData%WriteOutputUnt(i1))
  DstInitOutputData%WriteOutputUnt = SrcInitOutputData%WriteOutputUnt
ENDIF
  DstInitOutputData%Ver = SrcInitOutputData%Ver
IF ( ALLOCATED( SrcInitOutputData%LAnchxi ) ) THEN
  i1 = SIZE(SrcInitOutputData%LAnchxi,1)
  IF (.NOT.ALLOCATED(DstInitOutputData%LAnchxi)) ALLOCATE(DstInitOutputData%LAnchxi(i1))
  DstInitOutputData%LAnchxi = SrcInitOutputData%LAnchxi
ENDIF
IF ( ALLOCATED( SrcInitOutputData%LAnchyi ) ) THEN
  i1 = SIZE(SrcInitOutputData%LAnchyi,1)
  IF (.NOT.ALLOCATED(DstInitOutputData%LAnchyi)) ALLOCATE(DstInitOutputData%LAnchyi(i1))
  DstInitOutputData%LAnchyi = SrcInitOutputData%LAnchyi
ENDIF
IF ( ALLOCATED( SrcInitOutputData%LAnchzi ) ) THEN
  i1 = SIZE(SrcInitOutputData%LAnchzi,1)
  IF (.NOT.ALLOCATED(DstInitOutputData%LAnchzi)) ALLOCATE(DstInitOutputData%LAnchzi(i1))
  DstInitOutputData%LAnchzi = SrcInitOutputData%LAnchzi
ENDIF
IF ( ALLOCATED( SrcInitOutputData%LFairxt ) ) THEN
  i1 = SIZE(SrcInitOutputData%LFairxt,1)
  IF (.NOT.ALLOCATED(DstInitOutputData%LFairxt)) ALLOCATE(DstInitOutputData%LFairxt(i1))
  DstInitOutputData%LFairxt = SrcInitOutputData%LFairxt
ENDIF
IF ( ALLOCATED( SrcInitOutputData%LFairyt ) ) THEN
  i1 = SIZE(SrcInitOutputData%LFairyt,1)
  IF (.NOT.ALLOCATED(DstInitOutputData%LFairyt)) ALLOCATE(DstInitOutputData%LFairyt(i1))
  DstInitOutputData%LFairyt = SrcInitOutputData%LFairyt
ENDIF
IF ( ALLOCATED( SrcInitOutputData%LFairzt ) ) THEN
  i1 = SIZE(SrcInitOutputData%LFairzt,1)
  IF (.NOT.ALLOCATED(DstInitOutputData%LFairzt)) ALLOCATE(DstInitOutputData%LFairzt(i1))
  DstInitOutputData%LFairzt = SrcInitOutputData%LFairzt
ENDIF
 END SUBROUTINE FEAM_CopyInitOutput

 SUBROUTINE FEAM_DestroyInitOutput( InitOutputData, ErrStat, ErrMsg )
  TYPE(FEAM_initoutputtype), INTENT(INOUT) :: InitOutputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  IF ( ALLOCATED(InitOutputData%WriteOutputHdr) ) DEALLOCATE(InitOutputData%WriteOutputHdr)
  IF ( ALLOCATED(InitOutputData%WriteOutputUnt) ) DEALLOCATE(InitOutputData%WriteOutputUnt)
  IF ( ALLOCATED(InitOutputData%LAnchxi) ) DEALLOCATE(InitOutputData%LAnchxi)
  IF ( ALLOCATED(InitOutputData%LAnchyi) ) DEALLOCATE(InitOutputData%LAnchyi)
  IF ( ALLOCATED(InitOutputData%LAnchzi) ) DEALLOCATE(InitOutputData%LAnchzi)
  IF ( ALLOCATED(InitOutputData%LFairxt) ) DEALLOCATE(InitOutputData%LFairxt)
  IF ( ALLOCATED(InitOutputData%LFairyt) ) DEALLOCATE(InitOutputData%LFairyt)
  IF ( ALLOCATED(InitOutputData%LFairzt) ) DEALLOCATE(InitOutputData%LFairzt)
 END SUBROUTINE FEAM_DestroyInitOutput

 SUBROUTINE FEAM_PackInitOutput( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(FEAM_initoutputtype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Re_BufSz    = Re_BufSz    + SIZE( InData%LAnchxi )  ! LAnchxi 
  Re_BufSz    = Re_BufSz    + SIZE( InData%LAnchyi )  ! LAnchyi 
  Re_BufSz    = Re_BufSz    + SIZE( InData%LAnchzi )  ! LAnchzi 
  Re_BufSz    = Re_BufSz    + SIZE( InData%LFairxt )  ! LFairxt 
  Re_BufSz    = Re_BufSz    + SIZE( InData%LFairyt )  ! LFairyt 
  Re_BufSz    = Re_BufSz    + SIZE( InData%LFairzt )  ! LFairzt 
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( ALLOCATED(InData%LAnchxi) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%LAnchxi))-1 ) =  PACK(InData%LAnchxi ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%LAnchxi)
  ENDIF
  IF ( ALLOCATED(InData%LAnchyi) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%LAnchyi))-1 ) =  PACK(InData%LAnchyi ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%LAnchyi)
  ENDIF
  IF ( ALLOCATED(InData%LAnchzi) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%LAnchzi))-1 ) =  PACK(InData%LAnchzi ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%LAnchzi)
  ENDIF
  IF ( ALLOCATED(InData%LFairxt) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%LFairxt))-1 ) =  PACK(InData%LFairxt ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%LFairxt)
  ENDIF
  IF ( ALLOCATED(InData%LFairyt) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%LFairyt))-1 ) =  PACK(InData%LFairyt ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%LFairyt)
  ENDIF
  IF ( ALLOCATED(InData%LFairzt) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%LFairzt))-1 ) =  PACK(InData%LFairzt ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%LFairzt)
  ENDIF
 END SUBROUTINE FEAM_PackInitOutput

 SUBROUTINE FEAM_UnpackInitOutput( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(FEAM_initoutputtype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  IF ( ALLOCATED(OutData%LAnchxi) ) THEN
  ALLOCATE(mask1(SIZE(OutData%LAnchxi,1))); mask1 = .TRUE.
    OutData%LAnchxi = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%LAnchxi))-1 ),mask1,OutData%LAnchxi)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%LAnchxi)
  ENDIF
  IF ( ALLOCATED(OutData%LAnchyi) ) THEN
  ALLOCATE(mask1(SIZE(OutData%LAnchyi,1))); mask1 = .TRUE.
    OutData%LAnchyi = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%LAnchyi))-1 ),mask1,OutData%LAnchyi)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%LAnchyi)
  ENDIF
  IF ( ALLOCATED(OutData%LAnchzi) ) THEN
  ALLOCATE(mask1(SIZE(OutData%LAnchzi,1))); mask1 = .TRUE.
    OutData%LAnchzi = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%LAnchzi))-1 ),mask1,OutData%LAnchzi)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%LAnchzi)
  ENDIF
  IF ( ALLOCATED(OutData%LFairxt) ) THEN
  ALLOCATE(mask1(SIZE(OutData%LFairxt,1))); mask1 = .TRUE.
    OutData%LFairxt = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%LFairxt))-1 ),mask1,OutData%LFairxt)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%LFairxt)
  ENDIF
  IF ( ALLOCATED(OutData%LFairyt) ) THEN
  ALLOCATE(mask1(SIZE(OutData%LFairyt,1))); mask1 = .TRUE.
    OutData%LFairyt = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%LFairyt))-1 ),mask1,OutData%LFairyt)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%LFairyt)
  ENDIF
  IF ( ALLOCATED(OutData%LFairzt) ) THEN
  ALLOCATE(mask1(SIZE(OutData%LFairzt,1))); mask1 = .TRUE.
    OutData%LFairzt = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%LFairzt))-1 ),mask1,OutData%LFairzt)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%LFairzt)
  ENDIF
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE FEAM_UnpackInitOutput

 SUBROUTINE FEAM_CopyContState( SrcContStateData, DstContStateData, CtrlCode, ErrStat, ErrMsg )
  TYPE(FEAM_continuousstatetype), INTENT(INOUT) :: SrcContStateData
  TYPE(FEAM_continuousstatetype), INTENT(INOUT) :: DstContStateData
  INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF ( ALLOCATED( SrcContStateData%GLU ) ) THEN
  i1 = SIZE(SrcContStateData%GLU,1)
  i2 = SIZE(SrcContStateData%GLU,2)
  IF (.NOT.ALLOCATED(DstContStateData%GLU)) ALLOCATE(DstContStateData%GLU(i1,i2))
  DstContStateData%GLU = SrcContStateData%GLU
ENDIF
IF ( ALLOCATED( SrcContStateData%GLDU ) ) THEN
  i1 = SIZE(SrcContStateData%GLDU,1)
  i2 = SIZE(SrcContStateData%GLDU,2)
  IF (.NOT.ALLOCATED(DstContStateData%GLDU)) ALLOCATE(DstContStateData%GLDU(i1,i2))
  DstContStateData%GLDU = SrcContStateData%GLDU
ENDIF
 END SUBROUTINE FEAM_CopyContState

 SUBROUTINE FEAM_DestroyContState( ContStateData, ErrStat, ErrMsg )
  TYPE(FEAM_continuousstatetype), INTENT(INOUT) :: ContStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  IF ( ALLOCATED(ContStateData%GLU) ) DEALLOCATE(ContStateData%GLU)
  IF ( ALLOCATED(ContStateData%GLDU) ) DEALLOCATE(ContStateData%GLDU)
 END SUBROUTINE FEAM_DestroyContState

 SUBROUTINE FEAM_PackContState( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(FEAM_continuousstatetype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Re_BufSz    = Re_BufSz    + SIZE( InData%GLU )  ! GLU 
  Re_BufSz    = Re_BufSz    + SIZE( InData%GLDU )  ! GLDU 
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( ALLOCATED(InData%GLU) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%GLU))-1 ) =  PACK(InData%GLU ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%GLU)
  ENDIF
  IF ( ALLOCATED(InData%GLDU) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%GLDU))-1 ) =  PACK(InData%GLDU ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%GLDU)
  ENDIF
 END SUBROUTINE FEAM_PackContState

 SUBROUTINE FEAM_UnpackContState( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(FEAM_continuousstatetype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  IF ( ALLOCATED(OutData%GLU) ) THEN
  ALLOCATE(mask2(SIZE(OutData%GLU,1),SIZE(OutData%GLU,2))); mask2 = .TRUE.
    OutData%GLU = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%GLU))-1 ),mask2,OutData%GLU)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%GLU)
  ENDIF
  IF ( ALLOCATED(OutData%GLDU) ) THEN
  ALLOCATE(mask2(SIZE(OutData%GLDU,1),SIZE(OutData%GLDU,2))); mask2 = .TRUE.
    OutData%GLDU = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%GLDU))-1 ),mask2,OutData%GLDU)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%GLDU)
  ENDIF
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE FEAM_UnpackContState

 SUBROUTINE FEAM_CopyDiscState( SrcDiscStateData, DstDiscStateData, CtrlCode, ErrStat, ErrMsg )
  TYPE(FEAM_discretestatetype), INTENT(INOUT) :: SrcDiscStateData
  TYPE(FEAM_discretestatetype), INTENT(INOUT) :: DstDiscStateData
  INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  DstDiscStateData%DummyDiscState = SrcDiscStateData%DummyDiscState
 END SUBROUTINE FEAM_CopyDiscState

 SUBROUTINE FEAM_DestroyDiscState( DiscStateData, ErrStat, ErrMsg )
  TYPE(FEAM_discretestatetype), INTENT(INOUT) :: DiscStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
 END SUBROUTINE FEAM_DestroyDiscState

 SUBROUTINE FEAM_PackDiscState( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(FEAM_discretestatetype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Re_BufSz   = Re_BufSz   + 1  ! DummyDiscState
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%DummyDiscState )
  Re_Xferred   = Re_Xferred   + 1
 END SUBROUTINE FEAM_PackDiscState

 SUBROUTINE FEAM_UnpackDiscState( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(FEAM_discretestatetype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  OutData%DummyDiscState = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE FEAM_UnpackDiscState

 SUBROUTINE FEAM_CopyConstrState( SrcConstrStateData, DstConstrStateData, CtrlCode, ErrStat, ErrMsg )
  TYPE(FEAM_constraintstatetype), INTENT(INOUT) :: SrcConstrStateData
  TYPE(FEAM_constraintstatetype), INTENT(INOUT) :: DstConstrStateData
  INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  DstConstrStateData%TSN = SrcConstrStateData%TSN
  DstConstrStateData%TZER = SrcConstrStateData%TZER
 END SUBROUTINE FEAM_CopyConstrState

 SUBROUTINE FEAM_DestroyConstrState( ConstrStateData, ErrStat, ErrMsg )
  TYPE(FEAM_constraintstatetype), INTENT(INOUT) :: ConstrStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
 END SUBROUTINE FEAM_DestroyConstrState

 SUBROUTINE FEAM_PackConstrState( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(FEAM_constraintstatetype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Re_BufSz    = Re_BufSz    + SIZE( InData%TSN )  ! TSN 
  Re_BufSz    = Re_BufSz    + SIZE( InData%TZER )  ! TZER 
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%TSN))-1 ) =  PACK(InData%TSN ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%TSN)
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%TZER))-1 ) =  PACK(InData%TZER ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%TZER)
 END SUBROUTINE FEAM_PackConstrState

 SUBROUTINE FEAM_UnpackConstrState( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(FEAM_constraintstatetype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  ALLOCATE(mask1(SIZE(OutData%TSN,1))); mask1 = .TRUE.
  OutData%TSN = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%TSN))-1 ),mask1,OutData%TSN)
  DEALLOCATE(mask1)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%TSN)
  ALLOCATE(mask1(SIZE(OutData%TZER,1))); mask1 = .TRUE.
  OutData%TZER = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%TZER))-1 ),mask1,OutData%TZER)
  DEALLOCATE(mask1)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%TZER)
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE FEAM_UnpackConstrState

 SUBROUTINE FEAM_CopyOtherState( SrcOtherStateData, DstOtherStateData, CtrlCode, ErrStat, ErrMsg )
  TYPE(FEAM_otherstatetype), INTENT(INOUT) :: SrcOtherStateData
  TYPE(FEAM_otherstatetype), INTENT(INOUT) :: DstOtherStateData
  INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF ( ALLOCATED( SrcOtherStateData%GLU0 ) ) THEN
  i1 = SIZE(SrcOtherStateData%GLU0,1)
  i2 = SIZE(SrcOtherStateData%GLU0,2)
  IF (.NOT.ALLOCATED(DstOtherStateData%GLU0)) ALLOCATE(DstOtherStateData%GLU0(i1,i2))
  DstOtherStateData%GLU0 = SrcOtherStateData%GLU0
ENDIF
IF ( ALLOCATED( SrcOtherStateData%GLDDU ) ) THEN
  i1 = SIZE(SrcOtherStateData%GLDDU,1)
  i2 = SIZE(SrcOtherStateData%GLDDU,2)
  IF (.NOT.ALLOCATED(DstOtherStateData%GLDDU)) ALLOCATE(DstOtherStateData%GLDDU(i1,i2))
  DstOtherStateData%GLDDU = SrcOtherStateData%GLDDU
ENDIF
IF ( ALLOCATED( SrcOtherStateData%GLF ) ) THEN
  i1 = SIZE(SrcOtherStateData%GLF,1)
  i2 = SIZE(SrcOtherStateData%GLF,2)
  IF (.NOT.ALLOCATED(DstOtherStateData%GLF)) ALLOCATE(DstOtherStateData%GLF(i1,i2))
  DstOtherStateData%GLF = SrcOtherStateData%GLF
ENDIF
IF ( ALLOCATED( SrcOtherStateData%GLK ) ) THEN
  i1 = SIZE(SrcOtherStateData%GLK,1)
  i2 = SIZE(SrcOtherStateData%GLK,2)
  i3 = SIZE(SrcOtherStateData%GLK,3)
  IF (.NOT.ALLOCATED(DstOtherStateData%GLK)) ALLOCATE(DstOtherStateData%GLK(i1,i2,i3))
  DstOtherStateData%GLK = SrcOtherStateData%GLK
ENDIF
IF ( ALLOCATED( SrcOtherStateData%GLUZR ) ) THEN
  i1 = SIZE(SrcOtherStateData%GLUZR,1)
  i2 = SIZE(SrcOtherStateData%GLUZR,2)
  i3 = SIZE(SrcOtherStateData%GLUZR,3)
  IF (.NOT.ALLOCATED(DstOtherStateData%GLUZR)) ALLOCATE(DstOtherStateData%GLUZR(i1,i2,i3))
  DstOtherStateData%GLUZR = SrcOtherStateData%GLUZR
ENDIF
IF ( ALLOCATED( SrcOtherStateData%GTZER ) ) THEN
  i1 = SIZE(SrcOtherStateData%GTZER,1)
  i2 = SIZE(SrcOtherStateData%GTZER,2)
  IF (.NOT.ALLOCATED(DstOtherStateData%GTZER)) ALLOCATE(DstOtherStateData%GTZER(i1,i2))
  DstOtherStateData%GTZER = SrcOtherStateData%GTZER
ENDIF
IF ( ALLOCATED( SrcOtherStateData%GFORC0 ) ) THEN
  i1 = SIZE(SrcOtherStateData%GFORC0,1)
  i2 = SIZE(SrcOtherStateData%GFORC0,2)
  i3 = SIZE(SrcOtherStateData%GFORC0,3)
  IF (.NOT.ALLOCATED(DstOtherStateData%GFORC0)) ALLOCATE(DstOtherStateData%GFORC0(i1,i2,i3))
  DstOtherStateData%GFORC0 = SrcOtherStateData%GFORC0
ENDIF
IF ( ALLOCATED( SrcOtherStateData%GMASS0 ) ) THEN
  i1 = SIZE(SrcOtherStateData%GMASS0,1)
  i2 = SIZE(SrcOtherStateData%GMASS0,2)
  i3 = SIZE(SrcOtherStateData%GMASS0,3)
  i4 = SIZE(SrcOtherStateData%GMASS0,4)
  IF (.NOT.ALLOCATED(DstOtherStateData%GMASS0)) ALLOCATE(DstOtherStateData%GMASS0(i1,i2,i3,i4))
  DstOtherStateData%GMASS0 = SrcOtherStateData%GMASS0
ENDIF
IF ( ALLOCATED( SrcOtherStateData%FAST_FP ) ) THEN
  i1 = SIZE(SrcOtherStateData%FAST_FP,1)
  i2 = SIZE(SrcOtherStateData%FAST_FP,2)
  IF (.NOT.ALLOCATED(DstOtherStateData%FAST_FP)) ALLOCATE(DstOtherStateData%FAST_FP(i1,i2))
  DstOtherStateData%FAST_FP = SrcOtherStateData%FAST_FP
ENDIF
IF ( ALLOCATED( SrcOtherStateData%FAST_FPA ) ) THEN
  i1 = SIZE(SrcOtherStateData%FAST_FPA,1)
  i2 = SIZE(SrcOtherStateData%FAST_FPA,2)
  IF (.NOT.ALLOCATED(DstOtherStateData%FAST_FPA)) ALLOCATE(DstOtherStateData%FAST_FPA(i1,i2))
  DstOtherStateData%FAST_FPA = SrcOtherStateData%FAST_FPA
ENDIF
IF ( ALLOCATED( SrcOtherStateData%FAIR_T ) ) THEN
  i1 = SIZE(SrcOtherStateData%FAIR_T,1)
  IF (.NOT.ALLOCATED(DstOtherStateData%FAIR_T)) ALLOCATE(DstOtherStateData%FAIR_T(i1))
  DstOtherStateData%FAIR_T = SrcOtherStateData%FAIR_T
ENDIF
IF ( ALLOCATED( SrcOtherStateData%FAST_RP ) ) THEN
  i1 = SIZE(SrcOtherStateData%FAST_RP,1)
  i2 = SIZE(SrcOtherStateData%FAST_RP,2)
  IF (.NOT.ALLOCATED(DstOtherStateData%FAST_RP)) ALLOCATE(DstOtherStateData%FAST_RP(i1,i2))
  DstOtherStateData%FAST_RP = SrcOtherStateData%FAST_RP
ENDIF
IF ( ALLOCATED( SrcOtherStateData%ANCH_T ) ) THEN
  i1 = SIZE(SrcOtherStateData%ANCH_T,1)
  IF (.NOT.ALLOCATED(DstOtherStateData%ANCH_T)) ALLOCATE(DstOtherStateData%ANCH_T(i1))
  DstOtherStateData%ANCH_T = SrcOtherStateData%ANCH_T
ENDIF
IF ( ALLOCATED( SrcOtherStateData%FAIR_ANG ) ) THEN
  i1 = SIZE(SrcOtherStateData%FAIR_ANG,1)
  i2 = SIZE(SrcOtherStateData%FAIR_ANG,2)
  IF (.NOT.ALLOCATED(DstOtherStateData%FAIR_ANG)) ALLOCATE(DstOtherStateData%FAIR_ANG(i1,i2))
  DstOtherStateData%FAIR_ANG = SrcOtherStateData%FAIR_ANG
ENDIF
IF ( ALLOCATED( SrcOtherStateData%ANCH_ANG ) ) THEN
  i1 = SIZE(SrcOtherStateData%ANCH_ANG,1)
  i2 = SIZE(SrcOtherStateData%ANCH_ANG,2)
  IF (.NOT.ALLOCATED(DstOtherStateData%ANCH_ANG)) ALLOCATE(DstOtherStateData%ANCH_ANG(i1,i2))
  DstOtherStateData%ANCH_ANG = SrcOtherStateData%ANCH_ANG
ENDIF
  DstOtherStateData%ESTIF = SrcOtherStateData%ESTIF
  DstOtherStateData%EMASS = SrcOtherStateData%EMASS
  DstOtherStateData%FORCE = SrcOtherStateData%FORCE
  DstOtherStateData%RSDF = SrcOtherStateData%RSDF
IF ( ALLOCATED( SrcOtherStateData%F_Lines ) ) THEN
  i1 = SIZE(SrcOtherStateData%F_Lines,1)
  i2 = SIZE(SrcOtherStateData%F_Lines,2)
  IF (.NOT.ALLOCATED(DstOtherStateData%F_Lines)) ALLOCATE(DstOtherStateData%F_Lines(i1,i2))
  DstOtherStateData%F_Lines = SrcOtherStateData%F_Lines
ENDIF
  DstOtherStateData%U = SrcOtherStateData%U
  DstOtherStateData%U0 = SrcOtherStateData%U0
  DstOtherStateData%DU = SrcOtherStateData%DU
  DstOtherStateData%DDU = SrcOtherStateData%DDU
  DstOtherStateData%FORC0 = SrcOtherStateData%FORC0
  DstOtherStateData%EMAS0 = SrcOtherStateData%EMAS0
  DstOtherStateData%INCR = SrcOtherStateData%INCR
  DstOtherStateData%BottomTouch = SrcOtherStateData%BottomTouch
  DstOtherStateData%Iteration1 = SrcOtherStateData%Iteration1
  DstOtherStateData%Iteration2 = SrcOtherStateData%Iteration2
  DstOtherStateData%R = SrcOtherStateData%R
  DstOtherStateData%RP = SrcOtherStateData%RP
  DstOtherStateData%FP = SrcOtherStateData%FP
  DstOtherStateData%SLIN = SrcOtherStateData%SLIN
  DstOtherStateData%STIFR = SrcOtherStateData%STIFR
  DstOtherStateData%RHSR = SrcOtherStateData%RHSR
IF ( ALLOCATED( SrcOtherStateData%Line_Coordinate ) ) THEN
  i1 = SIZE(SrcOtherStateData%Line_Coordinate,1)
  i2 = SIZE(SrcOtherStateData%Line_Coordinate,2)
  i3 = SIZE(SrcOtherStateData%Line_Coordinate,3)
  IF (.NOT.ALLOCATED(DstOtherStateData%Line_Coordinate)) ALLOCATE(DstOtherStateData%Line_Coordinate(i1,i2,i3))
  DstOtherStateData%Line_Coordinate = SrcOtherStateData%Line_Coordinate
ENDIF
 END SUBROUTINE FEAM_CopyOtherState

 SUBROUTINE FEAM_DestroyOtherState( OtherStateData, ErrStat, ErrMsg )
  TYPE(FEAM_otherstatetype), INTENT(INOUT) :: OtherStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  IF ( ALLOCATED(OtherStateData%GLU0) ) DEALLOCATE(OtherStateData%GLU0)
  IF ( ALLOCATED(OtherStateData%GLDDU) ) DEALLOCATE(OtherStateData%GLDDU)
  IF ( ALLOCATED(OtherStateData%GLF) ) DEALLOCATE(OtherStateData%GLF)
  IF ( ALLOCATED(OtherStateData%GLK) ) DEALLOCATE(OtherStateData%GLK)
  IF ( ALLOCATED(OtherStateData%GLUZR) ) DEALLOCATE(OtherStateData%GLUZR)
  IF ( ALLOCATED(OtherStateData%GTZER) ) DEALLOCATE(OtherStateData%GTZER)
  IF ( ALLOCATED(OtherStateData%GFORC0) ) DEALLOCATE(OtherStateData%GFORC0)
  IF ( ALLOCATED(OtherStateData%GMASS0) ) DEALLOCATE(OtherStateData%GMASS0)
  IF ( ALLOCATED(OtherStateData%FAST_FP) ) DEALLOCATE(OtherStateData%FAST_FP)
  IF ( ALLOCATED(OtherStateData%FAST_FPA) ) DEALLOCATE(OtherStateData%FAST_FPA)
  IF ( ALLOCATED(OtherStateData%FAIR_T) ) DEALLOCATE(OtherStateData%FAIR_T)
  IF ( ALLOCATED(OtherStateData%FAST_RP) ) DEALLOCATE(OtherStateData%FAST_RP)
  IF ( ALLOCATED(OtherStateData%ANCH_T) ) DEALLOCATE(OtherStateData%ANCH_T)
  IF ( ALLOCATED(OtherStateData%FAIR_ANG) ) DEALLOCATE(OtherStateData%FAIR_ANG)
  IF ( ALLOCATED(OtherStateData%ANCH_ANG) ) DEALLOCATE(OtherStateData%ANCH_ANG)
  IF ( ALLOCATED(OtherStateData%F_Lines) ) DEALLOCATE(OtherStateData%F_Lines)
  IF ( ALLOCATED(OtherStateData%Line_Coordinate) ) DEALLOCATE(OtherStateData%Line_Coordinate)
 END SUBROUTINE FEAM_DestroyOtherState

 SUBROUTINE FEAM_PackOtherState( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(FEAM_otherstatetype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Re_BufSz    = Re_BufSz    + SIZE( InData%GLU0 )  ! GLU0 
  Re_BufSz    = Re_BufSz    + SIZE( InData%GLDDU )  ! GLDDU 
  Re_BufSz    = Re_BufSz    + SIZE( InData%GLF )  ! GLF 
  Re_BufSz    = Re_BufSz    + SIZE( InData%GLK )  ! GLK 
  Re_BufSz    = Re_BufSz    + SIZE( InData%GLUZR )  ! GLUZR 
  Re_BufSz    = Re_BufSz    + SIZE( InData%GTZER )  ! GTZER 
  Re_BufSz    = Re_BufSz    + SIZE( InData%GFORC0 )  ! GFORC0 
  Re_BufSz    = Re_BufSz    + SIZE( InData%GMASS0 )  ! GMASS0 
  Re_BufSz    = Re_BufSz    + SIZE( InData%FAST_FP )  ! FAST_FP 
  Re_BufSz    = Re_BufSz    + SIZE( InData%FAST_FPA )  ! FAST_FPA 
  Re_BufSz    = Re_BufSz    + SIZE( InData%FAIR_T )  ! FAIR_T 
  Re_BufSz    = Re_BufSz    + SIZE( InData%FAST_RP )  ! FAST_RP 
  Re_BufSz    = Re_BufSz    + SIZE( InData%ANCH_T )  ! ANCH_T 
  Re_BufSz    = Re_BufSz    + SIZE( InData%FAIR_ANG )  ! FAIR_ANG 
  Re_BufSz    = Re_BufSz    + SIZE( InData%ANCH_ANG )  ! ANCH_ANG 
  Re_BufSz    = Re_BufSz    + SIZE( InData%ESTIF )  ! ESTIF 
  Re_BufSz    = Re_BufSz    + SIZE( InData%EMASS )  ! EMASS 
  Re_BufSz    = Re_BufSz    + SIZE( InData%FORCE )  ! FORCE 
  Re_BufSz    = Re_BufSz    + SIZE( InData%RSDF )  ! RSDF 
  Re_BufSz    = Re_BufSz    + SIZE( InData%F_Lines )  ! F_Lines 
  Re_BufSz    = Re_BufSz    + SIZE( InData%U )  ! U 
  Re_BufSz    = Re_BufSz    + SIZE( InData%U0 )  ! U0 
  Re_BufSz    = Re_BufSz    + SIZE( InData%DU )  ! DU 
  Re_BufSz    = Re_BufSz    + SIZE( InData%DDU )  ! DDU 
  Re_BufSz    = Re_BufSz    + SIZE( InData%FORC0 )  ! FORC0 
  Re_BufSz    = Re_BufSz    + SIZE( InData%EMAS0 )  ! EMAS0 
  Int_BufSz  = Int_BufSz  + 1  ! INCR
  Re_BufSz    = Re_BufSz    + SIZE( InData%R )  ! R 
  Re_BufSz    = Re_BufSz    + SIZE( InData%RP )  ! RP 
  Re_BufSz    = Re_BufSz    + SIZE( InData%FP )  ! FP 
  Re_BufSz    = Re_BufSz    + SIZE( InData%SLIN )  ! SLIN 
  Re_BufSz    = Re_BufSz    + SIZE( InData%STIFR )  ! STIFR 
  Re_BufSz    = Re_BufSz    + SIZE( InData%RHSR )  ! RHSR 
  Re_BufSz    = Re_BufSz    + SIZE( InData%Line_Coordinate )  ! Line_Coordinate 
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( ALLOCATED(InData%GLU0) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%GLU0))-1 ) =  PACK(InData%GLU0 ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%GLU0)
  ENDIF
  IF ( ALLOCATED(InData%GLDDU) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%GLDDU))-1 ) =  PACK(InData%GLDDU ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%GLDDU)
  ENDIF
  IF ( ALLOCATED(InData%GLF) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%GLF))-1 ) =  PACK(InData%GLF ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%GLF)
  ENDIF
  IF ( ALLOCATED(InData%GLK) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%GLK))-1 ) =  PACK(InData%GLK ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%GLK)
  ENDIF
  IF ( ALLOCATED(InData%GLUZR) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%GLUZR))-1 ) =  PACK(InData%GLUZR ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%GLUZR)
  ENDIF
  IF ( ALLOCATED(InData%GTZER) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%GTZER))-1 ) =  PACK(InData%GTZER ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%GTZER)
  ENDIF
  IF ( ALLOCATED(InData%GFORC0) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%GFORC0))-1 ) =  PACK(InData%GFORC0 ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%GFORC0)
  ENDIF
  IF ( ALLOCATED(InData%GMASS0) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%GMASS0))-1 ) =  PACK(InData%GMASS0 ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%GMASS0)
  ENDIF
  IF ( ALLOCATED(InData%FAST_FP) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%FAST_FP))-1 ) =  PACK(InData%FAST_FP ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%FAST_FP)
  ENDIF
  IF ( ALLOCATED(InData%FAST_FPA) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%FAST_FPA))-1 ) =  PACK(InData%FAST_FPA ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%FAST_FPA)
  ENDIF
  IF ( ALLOCATED(InData%FAIR_T) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%FAIR_T))-1 ) =  PACK(InData%FAIR_T ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%FAIR_T)
  ENDIF
  IF ( ALLOCATED(InData%FAST_RP) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%FAST_RP))-1 ) =  PACK(InData%FAST_RP ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%FAST_RP)
  ENDIF
  IF ( ALLOCATED(InData%ANCH_T) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%ANCH_T))-1 ) =  PACK(InData%ANCH_T ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%ANCH_T)
  ENDIF
  IF ( ALLOCATED(InData%FAIR_ANG) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%FAIR_ANG))-1 ) =  PACK(InData%FAIR_ANG ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%FAIR_ANG)
  ENDIF
  IF ( ALLOCATED(InData%ANCH_ANG) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%ANCH_ANG))-1 ) =  PACK(InData%ANCH_ANG ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%ANCH_ANG)
  ENDIF
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%ESTIF))-1 ) =  PACK(InData%ESTIF ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%ESTIF)
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%EMASS))-1 ) =  PACK(InData%EMASS ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%EMASS)
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%FORCE))-1 ) =  PACK(InData%FORCE ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%FORCE)
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%RSDF))-1 ) =  PACK(InData%RSDF ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%RSDF)
  IF ( ALLOCATED(InData%F_Lines) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%F_Lines))-1 ) =  PACK(InData%F_Lines ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%F_Lines)
  ENDIF
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%U))-1 ) =  PACK(InData%U ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%U)
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%U0))-1 ) =  PACK(InData%U0 ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%U0)
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%DU))-1 ) =  PACK(InData%DU ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%DU)
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%DDU))-1 ) =  PACK(InData%DDU ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%DDU)
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%FORC0))-1 ) =  PACK(InData%FORC0 ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%FORC0)
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%EMAS0))-1 ) =  PACK(InData%EMAS0 ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%EMAS0)
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%INCR )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%R))-1 ) =  PACK(InData%R ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%R)
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%RP))-1 ) =  PACK(InData%RP ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%RP)
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%FP))-1 ) =  PACK(InData%FP ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%FP)
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%SLIN))-1 ) =  PACK(InData%SLIN ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%SLIN)
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%STIFR))-1 ) =  PACK(InData%STIFR ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%STIFR)
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%RHSR))-1 ) =  PACK(InData%RHSR ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%RHSR)
  IF ( ALLOCATED(InData%Line_Coordinate) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Line_Coordinate))-1 ) =  PACK(InData%Line_Coordinate ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%Line_Coordinate)
  ENDIF
 END SUBROUTINE FEAM_PackOtherState

 SUBROUTINE FEAM_UnpackOtherState( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(FEAM_otherstatetype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  IF ( ALLOCATED(OutData%GLU0) ) THEN
  ALLOCATE(mask2(SIZE(OutData%GLU0,1),SIZE(OutData%GLU0,2))); mask2 = .TRUE.
    OutData%GLU0 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%GLU0))-1 ),mask2,OutData%GLU0)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%GLU0)
  ENDIF
  IF ( ALLOCATED(OutData%GLDDU) ) THEN
  ALLOCATE(mask2(SIZE(OutData%GLDDU,1),SIZE(OutData%GLDDU,2))); mask2 = .TRUE.
    OutData%GLDDU = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%GLDDU))-1 ),mask2,OutData%GLDDU)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%GLDDU)
  ENDIF
  IF ( ALLOCATED(OutData%GLF) ) THEN
  ALLOCATE(mask2(SIZE(OutData%GLF,1),SIZE(OutData%GLF,2))); mask2 = .TRUE.
    OutData%GLF = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%GLF))-1 ),mask2,OutData%GLF)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%GLF)
  ENDIF
  IF ( ALLOCATED(OutData%GLK) ) THEN
  ALLOCATE(mask3(SIZE(OutData%GLK,1),SIZE(OutData%GLK,2),SIZE(OutData%GLK,3))); mask3 = .TRUE.
    OutData%GLK = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%GLK))-1 ),mask3,OutData%GLK)
  DEALLOCATE(mask3)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%GLK)
  ENDIF
  IF ( ALLOCATED(OutData%GLUZR) ) THEN
  ALLOCATE(mask3(SIZE(OutData%GLUZR,1),SIZE(OutData%GLUZR,2),SIZE(OutData%GLUZR,3))); mask3 = .TRUE.
    OutData%GLUZR = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%GLUZR))-1 ),mask3,OutData%GLUZR)
  DEALLOCATE(mask3)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%GLUZR)
  ENDIF
  IF ( ALLOCATED(OutData%GTZER) ) THEN
  ALLOCATE(mask2(SIZE(OutData%GTZER,1),SIZE(OutData%GTZER,2))); mask2 = .TRUE.
    OutData%GTZER = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%GTZER))-1 ),mask2,OutData%GTZER)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%GTZER)
  ENDIF
  IF ( ALLOCATED(OutData%GFORC0) ) THEN
  ALLOCATE(mask3(SIZE(OutData%GFORC0,1),SIZE(OutData%GFORC0,2),SIZE(OutData%GFORC0,3))); mask3 = .TRUE.
    OutData%GFORC0 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%GFORC0))-1 ),mask3,OutData%GFORC0)
  DEALLOCATE(mask3)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%GFORC0)
  ENDIF
  IF ( ALLOCATED(OutData%GMASS0) ) THEN
  ALLOCATE(mask4(SIZE(OutData%GMASS0,1),SIZE(OutData%GMASS0,2),SIZE(OutData%GMASS0,3),SIZE(OutData%GMASS0,4))); mask4 = .TRUE.
    OutData%GMASS0 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%GMASS0))-1 ),mask4,OutData%GMASS0)
  DEALLOCATE(mask4)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%GMASS0)
  ENDIF
  IF ( ALLOCATED(OutData%FAST_FP) ) THEN
  ALLOCATE(mask2(SIZE(OutData%FAST_FP,1),SIZE(OutData%FAST_FP,2))); mask2 = .TRUE.
    OutData%FAST_FP = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%FAST_FP))-1 ),mask2,OutData%FAST_FP)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%FAST_FP)
  ENDIF
  IF ( ALLOCATED(OutData%FAST_FPA) ) THEN
  ALLOCATE(mask2(SIZE(OutData%FAST_FPA,1),SIZE(OutData%FAST_FPA,2))); mask2 = .TRUE.
    OutData%FAST_FPA = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%FAST_FPA))-1 ),mask2,OutData%FAST_FPA)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%FAST_FPA)
  ENDIF
  IF ( ALLOCATED(OutData%FAIR_T) ) THEN
  ALLOCATE(mask1(SIZE(OutData%FAIR_T,1))); mask1 = .TRUE.
    OutData%FAIR_T = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%FAIR_T))-1 ),mask1,OutData%FAIR_T)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%FAIR_T)
  ENDIF
  IF ( ALLOCATED(OutData%FAST_RP) ) THEN
  ALLOCATE(mask2(SIZE(OutData%FAST_RP,1),SIZE(OutData%FAST_RP,2))); mask2 = .TRUE.
    OutData%FAST_RP = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%FAST_RP))-1 ),mask2,OutData%FAST_RP)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%FAST_RP)
  ENDIF
  IF ( ALLOCATED(OutData%ANCH_T) ) THEN
  ALLOCATE(mask1(SIZE(OutData%ANCH_T,1))); mask1 = .TRUE.
    OutData%ANCH_T = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%ANCH_T))-1 ),mask1,OutData%ANCH_T)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%ANCH_T)
  ENDIF
  IF ( ALLOCATED(OutData%FAIR_ANG) ) THEN
  ALLOCATE(mask2(SIZE(OutData%FAIR_ANG,1),SIZE(OutData%FAIR_ANG,2))); mask2 = .TRUE.
    OutData%FAIR_ANG = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%FAIR_ANG))-1 ),mask2,OutData%FAIR_ANG)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%FAIR_ANG)
  ENDIF
  IF ( ALLOCATED(OutData%ANCH_ANG) ) THEN
  ALLOCATE(mask2(SIZE(OutData%ANCH_ANG,1),SIZE(OutData%ANCH_ANG,2))); mask2 = .TRUE.
    OutData%ANCH_ANG = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%ANCH_ANG))-1 ),mask2,OutData%ANCH_ANG)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%ANCH_ANG)
  ENDIF
  ALLOCATE(mask2(SIZE(OutData%ESTIF,1),SIZE(OutData%ESTIF,2))); mask2 = .TRUE.
  OutData%ESTIF = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%ESTIF))-1 ),mask2,OutData%ESTIF)
  DEALLOCATE(mask2)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%ESTIF)
  ALLOCATE(mask2(SIZE(OutData%EMASS,1),SIZE(OutData%EMASS,2))); mask2 = .TRUE.
  OutData%EMASS = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%EMASS))-1 ),mask2,OutData%EMASS)
  DEALLOCATE(mask2)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%EMASS)
  ALLOCATE(mask1(SIZE(OutData%FORCE,1))); mask1 = .TRUE.
  OutData%FORCE = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%FORCE))-1 ),mask1,OutData%FORCE)
  DEALLOCATE(mask1)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%FORCE)
  ALLOCATE(mask1(SIZE(OutData%RSDF,1))); mask1 = .TRUE.
  OutData%RSDF = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%RSDF))-1 ),mask1,OutData%RSDF)
  DEALLOCATE(mask1)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%RSDF)
  IF ( ALLOCATED(OutData%F_Lines) ) THEN
  ALLOCATE(mask2(SIZE(OutData%F_Lines,1),SIZE(OutData%F_Lines,2))); mask2 = .TRUE.
    OutData%F_Lines = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%F_Lines))-1 ),mask2,OutData%F_Lines)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%F_Lines)
  ENDIF
  ALLOCATE(mask2(SIZE(OutData%U,1),SIZE(OutData%U,2))); mask2 = .TRUE.
  OutData%U = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%U))-1 ),mask2,OutData%U)
  DEALLOCATE(mask2)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%U)
  ALLOCATE(mask2(SIZE(OutData%U0,1),SIZE(OutData%U0,2))); mask2 = .TRUE.
  OutData%U0 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%U0))-1 ),mask2,OutData%U0)
  DEALLOCATE(mask2)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%U0)
  ALLOCATE(mask2(SIZE(OutData%DU,1),SIZE(OutData%DU,2))); mask2 = .TRUE.
  OutData%DU = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%DU))-1 ),mask2,OutData%DU)
  DEALLOCATE(mask2)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%DU)
  ALLOCATE(mask2(SIZE(OutData%DDU,1),SIZE(OutData%DDU,2))); mask2 = .TRUE.
  OutData%DDU = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%DDU))-1 ),mask2,OutData%DDU)
  DEALLOCATE(mask2)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%DDU)
  ALLOCATE(mask1(SIZE(OutData%FORC0,1))); mask1 = .TRUE.
  OutData%FORC0 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%FORC0))-1 ),mask1,OutData%FORC0)
  DEALLOCATE(mask1)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%FORC0)
  ALLOCATE(mask2(SIZE(OutData%EMAS0,1),SIZE(OutData%EMAS0,2))); mask2 = .TRUE.
  OutData%EMAS0 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%EMAS0))-1 ),mask2,OutData%EMAS0)
  DEALLOCATE(mask2)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%EMAS0)
  OutData%INCR = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  ALLOCATE(mask1(SIZE(OutData%R,1))); mask1 = .TRUE.
  OutData%R = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%R))-1 ),mask1,OutData%R)
  DEALLOCATE(mask1)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%R)
  ALLOCATE(mask1(SIZE(OutData%RP,1))); mask1 = .TRUE.
  OutData%RP = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%RP))-1 ),mask1,OutData%RP)
  DEALLOCATE(mask1)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%RP)
  ALLOCATE(mask1(SIZE(OutData%FP,1))); mask1 = .TRUE.
  OutData%FP = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%FP))-1 ),mask1,OutData%FP)
  DEALLOCATE(mask1)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%FP)
  ALLOCATE(mask1(SIZE(OutData%SLIN,1))); mask1 = .TRUE.
  OutData%SLIN = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%SLIN))-1 ),mask1,OutData%SLIN)
  DEALLOCATE(mask1)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%SLIN)
  ALLOCATE(mask2(SIZE(OutData%STIFR,1),SIZE(OutData%STIFR,2))); mask2 = .TRUE.
  OutData%STIFR = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%STIFR))-1 ),mask2,OutData%STIFR)
  DEALLOCATE(mask2)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%STIFR)
  ALLOCATE(mask1(SIZE(OutData%RHSR,1))); mask1 = .TRUE.
  OutData%RHSR = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%RHSR))-1 ),mask1,OutData%RHSR)
  DEALLOCATE(mask1)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%RHSR)
  IF ( ALLOCATED(OutData%Line_Coordinate) ) THEN
  ALLOCATE(mask3(SIZE(OutData%Line_Coordinate,1),SIZE(OutData%Line_Coordinate,2),SIZE(OutData%Line_Coordinate,3))); mask3 = .TRUE.
    OutData%Line_Coordinate = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Line_Coordinate))-1 ),mask3,OutData%Line_Coordinate)
  DEALLOCATE(mask3)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%Line_Coordinate)
  ENDIF
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE FEAM_UnpackOtherState

 SUBROUTINE FEAM_CopyParam( SrcParamData, DstParamData, CtrlCode, ErrStat, ErrMsg )
  TYPE(FEAM_parametertype), INTENT(INOUT) :: SrcParamData
  TYPE(FEAM_parametertype), INTENT(INOUT) :: DstParamData
  INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  DstParamData%DT = SrcParamData%DT
  DstParamData%GRAV = SrcParamData%GRAV
  DstParamData%EPS = SrcParamData%EPS
  DstParamData%Gravity = SrcParamData%Gravity
  DstParamData%WtrDens = SrcParamData%WtrDens
  DstParamData%MITER = SrcParamData%MITER
  DstParamData%NHBD = SrcParamData%NHBD
  DstParamData%NDIM = SrcParamData%NDIM
IF ( ALLOCATED( SrcParamData%NEQ ) ) THEN
  i1 = SIZE(SrcParamData%NEQ,1)
  IF (.NOT.ALLOCATED(DstParamData%NEQ)) ALLOCATE(DstParamData%NEQ(i1))
  DstParamData%NEQ = SrcParamData%NEQ
ENDIF
  DstParamData%NBAND = SrcParamData%NBAND
  DstParamData%DYN = SrcParamData%DYN
  DstParamData%NumLines = SrcParamData%NumLines
  DstParamData%NumElems = SrcParamData%NumElems
IF ( ALLOCATED( SrcParamData%GSL ) ) THEN
  i1 = SIZE(SrcParamData%GSL,1)
  i2 = SIZE(SrcParamData%GSL,2)
  i3 = SIZE(SrcParamData%GSL,3)
  IF (.NOT.ALLOCATED(DstParamData%GSL)) ALLOCATE(DstParamData%GSL(i1,i2,i3))
  DstParamData%GSL = SrcParamData%GSL
ENDIF
IF ( ALLOCATED( SrcParamData%GP ) ) THEN
  i1 = SIZE(SrcParamData%GP,1)
  i2 = SIZE(SrcParamData%GP,2)
  IF (.NOT.ALLOCATED(DstParamData%GP)) ALLOCATE(DstParamData%GP(i1,i2))
  DstParamData%GP = SrcParamData%GP
ENDIF
IF ( ALLOCATED( SrcParamData%LineCI ) ) THEN
  i1 = SIZE(SrcParamData%LineCI,1)
  IF (.NOT.ALLOCATED(DstParamData%LineCI)) ALLOCATE(DstParamData%LineCI(i1))
  DstParamData%LineCI = SrcParamData%LineCI
ENDIF
IF ( ALLOCATED( SrcParamData%LineCD ) ) THEN
  i1 = SIZE(SrcParamData%LineCD,1)
  IF (.NOT.ALLOCATED(DstParamData%LineCD)) ALLOCATE(DstParamData%LineCD(i1))
  DstParamData%LineCD = SrcParamData%LineCD
ENDIF
IF ( ALLOCATED( SrcParamData%SectionA ) ) THEN
  i1 = SIZE(SrcParamData%SectionA,1)
  IF (.NOT.ALLOCATED(DstParamData%SectionA)) ALLOCATE(DstParamData%SectionA(i1))
  DstParamData%SectionA = SrcParamData%SectionA
ENDIF
IF ( ALLOCATED( SrcParamData%Elength ) ) THEN
  i1 = SIZE(SrcParamData%Elength,1)
  IF (.NOT.ALLOCATED(DstParamData%Elength)) ALLOCATE(DstParamData%Elength(i1))
  DstParamData%Elength = SrcParamData%Elength
ENDIF
IF ( ALLOCATED( SrcParamData%BottmElev ) ) THEN
  i1 = SIZE(SrcParamData%BottmElev,1)
  IF (.NOT.ALLOCATED(DstParamData%BottmElev)) ALLOCATE(DstParamData%BottmElev(i1))
  DstParamData%BottmElev = SrcParamData%BottmElev
ENDIF
IF ( ALLOCATED( SrcParamData%BottmStiff ) ) THEN
  i1 = SIZE(SrcParamData%BottmStiff,1)
  IF (.NOT.ALLOCATED(DstParamData%BottmStiff)) ALLOCATE(DstParamData%BottmStiff(i1))
  DstParamData%BottmStiff = SrcParamData%BottmStiff
ENDIF
IF ( ALLOCATED( SrcParamData%LMassDen ) ) THEN
  i1 = SIZE(SrcParamData%LMassDen,1)
  IF (.NOT.ALLOCATED(DstParamData%LMassDen)) ALLOCATE(DstParamData%LMassDen(i1))
  DstParamData%LMassDen = SrcParamData%LMassDen
ENDIF
IF ( ALLOCATED( SrcParamData%LDMassDen ) ) THEN
  i1 = SIZE(SrcParamData%LDMassDen,1)
  IF (.NOT.ALLOCATED(DstParamData%LDMassDen)) ALLOCATE(DstParamData%LDMassDen(i1))
  DstParamData%LDMassDen = SrcParamData%LDMassDen
ENDIF
IF ( ALLOCATED( SrcParamData%LEAStiff ) ) THEN
  i1 = SIZE(SrcParamData%LEAStiff,1)
  IF (.NOT.ALLOCATED(DstParamData%LEAStiff)) ALLOCATE(DstParamData%LEAStiff(i1))
  DstParamData%LEAStiff = SrcParamData%LEAStiff
ENDIF
IF ( ALLOCATED( SrcParamData%Bvp ) ) THEN
  i1 = SIZE(SrcParamData%Bvp,1)
  i2 = SIZE(SrcParamData%Bvp,2)
  IF (.NOT.ALLOCATED(DstParamData%Bvp)) ALLOCATE(DstParamData%Bvp(i1,i2))
  DstParamData%Bvp = SrcParamData%Bvp
ENDIF
  DstParamData%SHAP = SrcParamData%SHAP
  DstParamData%SHAPS = SrcParamData%SHAPS
  DstParamData%GAUSSW = SrcParamData%GAUSSW
  DstParamData%NGAUSS = SrcParamData%NGAUSS
  DstParamData%SHAPT = SrcParamData%SHAPT
  DstParamData%SHAPTS = SrcParamData%SHAPTS
  DstParamData%NTRAP = SrcParamData%NTRAP
  DstParamData%SBEND = SrcParamData%SBEND
  DstParamData%STEN = SrcParamData%STEN
  DstParamData%RMASS = SrcParamData%RMASS
  DstParamData%RADDM = SrcParamData%RADDM
  DstParamData%PMPN = SrcParamData%PMPN
  DstParamData%AM = SrcParamData%AM
  DstParamData%PM = SrcParamData%PM
  DstParamData%IDOF = SrcParamData%IDOF
  DstParamData%JDOF = SrcParamData%JDOF
  DstParamData%PPA = SrcParamData%PPA
  DstParamData%PtfmRefzt = SrcParamData%PtfmRefzt
  DstParamData%NumOuts = SrcParamData%NumOuts
  DstParamData%RootName = SrcParamData%RootName
IF ( ALLOCATED( SrcParamData%OutParam ) ) THEN
  i1 = SIZE(SrcParamData%OutParam,1)
  IF (.NOT.ALLOCATED(DstParamData%OutParam)) ALLOCATE(DstParamData%OutParam(i1))
  DstParamData%OutParam = SrcParamData%OutParam
ENDIF
  DstParamData%Delim = SrcParamData%Delim
 END SUBROUTINE FEAM_CopyParam

 SUBROUTINE FEAM_DestroyParam( ParamData, ErrStat, ErrMsg )
  TYPE(FEAM_parametertype), INTENT(INOUT) :: ParamData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  IF ( ALLOCATED(ParamData%NEQ) ) DEALLOCATE(ParamData%NEQ)
  IF ( ALLOCATED(ParamData%GSL) ) DEALLOCATE(ParamData%GSL)
  IF ( ALLOCATED(ParamData%GP) ) DEALLOCATE(ParamData%GP)
  IF ( ALLOCATED(ParamData%LineCI) ) DEALLOCATE(ParamData%LineCI)
  IF ( ALLOCATED(ParamData%LineCD) ) DEALLOCATE(ParamData%LineCD)
  IF ( ALLOCATED(ParamData%SectionA) ) DEALLOCATE(ParamData%SectionA)
  IF ( ALLOCATED(ParamData%Elength) ) DEALLOCATE(ParamData%Elength)
  IF ( ALLOCATED(ParamData%BottmElev) ) DEALLOCATE(ParamData%BottmElev)
  IF ( ALLOCATED(ParamData%BottmStiff) ) DEALLOCATE(ParamData%BottmStiff)
  IF ( ALLOCATED(ParamData%LMassDen) ) DEALLOCATE(ParamData%LMassDen)
  IF ( ALLOCATED(ParamData%LDMassDen) ) DEALLOCATE(ParamData%LDMassDen)
  IF ( ALLOCATED(ParamData%LEAStiff) ) DEALLOCATE(ParamData%LEAStiff)
  IF ( ALLOCATED(ParamData%Bvp) ) DEALLOCATE(ParamData%Bvp)
  IF ( ALLOCATED(ParamData%OutParam) ) DEALLOCATE(ParamData%OutParam)
 END SUBROUTINE FEAM_DestroyParam

 SUBROUTINE FEAM_PackParam( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(FEAM_parametertype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Db_BufSz   = Db_BufSz   + 1  ! DT
  Re_BufSz    = Re_BufSz    + SIZE( InData%GRAV )  ! GRAV 
  Re_BufSz   = Re_BufSz   + 1  ! EPS
  Re_BufSz   = Re_BufSz   + 1  ! Gravity
  Re_BufSz   = Re_BufSz   + 1  ! WtrDens
  Int_BufSz  = Int_BufSz  + 1  ! MITER
  Int_BufSz  = Int_BufSz  + 1  ! NHBD
  Int_BufSz  = Int_BufSz  + 1  ! NDIM
  Int_BufSz   = Int_BufSz   + SIZE( InData%NEQ )  ! NEQ 
  Int_BufSz  = Int_BufSz  + 1  ! NBAND
  Int_BufSz  = Int_BufSz  + 1  ! NumLines
  Int_BufSz  = Int_BufSz  + 1  ! NumElems
  Re_BufSz    = Re_BufSz    + SIZE( InData%GSL )  ! GSL 
  Re_BufSz    = Re_BufSz    + SIZE( InData%GP )  ! GP 
  Re_BufSz    = Re_BufSz    + SIZE( InData%LineCI )  ! LineCI 
  Re_BufSz    = Re_BufSz    + SIZE( InData%LineCD )  ! LineCD 
  Re_BufSz    = Re_BufSz    + SIZE( InData%SectionA )  ! SectionA 
  Re_BufSz    = Re_BufSz    + SIZE( InData%Elength )  ! Elength 
  Re_BufSz    = Re_BufSz    + SIZE( InData%BottmElev )  ! BottmElev 
  Re_BufSz    = Re_BufSz    + SIZE( InData%BottmStiff )  ! BottmStiff 
  Re_BufSz    = Re_BufSz    + SIZE( InData%LMassDen )  ! LMassDen 
  Re_BufSz    = Re_BufSz    + SIZE( InData%LDMassDen )  ! LDMassDen 
  Re_BufSz    = Re_BufSz    + SIZE( InData%LEAStiff )  ! LEAStiff 
  Re_BufSz    = Re_BufSz    + SIZE( InData%Bvp )  ! Bvp 
  Re_BufSz    = Re_BufSz    + SIZE( InData%SHAP )  ! SHAP 
  Re_BufSz    = Re_BufSz    + SIZE( InData%SHAPS )  ! SHAPS 
  Re_BufSz    = Re_BufSz    + SIZE( InData%GAUSSW )  ! GAUSSW 
  Int_BufSz  = Int_BufSz  + 1  ! NGAUSS
  Re_BufSz    = Re_BufSz    + SIZE( InData%SHAPT )  ! SHAPT 
  Re_BufSz    = Re_BufSz    + SIZE( InData%SHAPTS )  ! SHAPTS 
  Re_BufSz   = Re_BufSz   + 1  ! NTRAP
  Re_BufSz    = Re_BufSz    + SIZE( InData%SBEND )  ! SBEND 
  Re_BufSz    = Re_BufSz    + SIZE( InData%STEN )  ! STEN 
  Re_BufSz    = Re_BufSz    + SIZE( InData%RMASS )  ! RMASS 
  Re_BufSz    = Re_BufSz    + SIZE( InData%RADDM )  ! RADDM 
  Re_BufSz    = Re_BufSz    + SIZE( InData%PMPN )  ! PMPN 
  Re_BufSz    = Re_BufSz    + SIZE( InData%AM )  ! AM 
  Re_BufSz    = Re_BufSz    + SIZE( InData%PM )  ! PM 
  Int_BufSz   = Int_BufSz   + SIZE( InData%IDOF )  ! IDOF 
  Int_BufSz   = Int_BufSz   + SIZE( InData%JDOF )  ! JDOF 
  Re_BufSz    = Re_BufSz    + SIZE( InData%PPA )  ! PPA 
  Re_BufSz   = Re_BufSz   + 1  ! PtfmRefzt
  Int_BufSz  = Int_BufSz  + 1  ! NumOuts
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(1)-1 ) =  (InData%DT )
  Db_Xferred   = Db_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%GRAV))-1 ) =  PACK(InData%GRAV ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%GRAV)
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%EPS )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%Gravity )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%WtrDens )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%MITER )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NHBD )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NDIM )
  Int_Xferred   = Int_Xferred   + 1
  IF ( ALLOCATED(InData%NEQ) ) THEN
    IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%NEQ))-1 ) = PACK(InData%NEQ ,.TRUE.)
    Int_Xferred   = Int_Xferred   + SIZE(InData%NEQ)
  ENDIF
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NBAND )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NumLines )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NumElems )
  Int_Xferred   = Int_Xferred   + 1
  IF ( ALLOCATED(InData%GSL) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%GSL))-1 ) =  PACK(InData%GSL ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%GSL)
  ENDIF
  IF ( ALLOCATED(InData%GP) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%GP))-1 ) =  PACK(InData%GP ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%GP)
  ENDIF
  IF ( ALLOCATED(InData%LineCI) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%LineCI))-1 ) =  PACK(InData%LineCI ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%LineCI)
  ENDIF
  IF ( ALLOCATED(InData%LineCD) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%LineCD))-1 ) =  PACK(InData%LineCD ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%LineCD)
  ENDIF
  IF ( ALLOCATED(InData%SectionA) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%SectionA))-1 ) =  PACK(InData%SectionA ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%SectionA)
  ENDIF
  IF ( ALLOCATED(InData%Elength) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Elength))-1 ) =  PACK(InData%Elength ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%Elength)
  ENDIF
  IF ( ALLOCATED(InData%BottmElev) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%BottmElev))-1 ) =  PACK(InData%BottmElev ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%BottmElev)
  ENDIF
  IF ( ALLOCATED(InData%BottmStiff) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%BottmStiff))-1 ) =  PACK(InData%BottmStiff ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%BottmStiff)
  ENDIF
  IF ( ALLOCATED(InData%LMassDen) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%LMassDen))-1 ) =  PACK(InData%LMassDen ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%LMassDen)
  ENDIF
  IF ( ALLOCATED(InData%LDMassDen) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%LDMassDen))-1 ) =  PACK(InData%LDMassDen ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%LDMassDen)
  ENDIF
  IF ( ALLOCATED(InData%LEAStiff) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%LEAStiff))-1 ) =  PACK(InData%LEAStiff ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%LEAStiff)
  ENDIF
  IF ( ALLOCATED(InData%Bvp) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Bvp))-1 ) =  PACK(InData%Bvp ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%Bvp)
  ENDIF
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%SHAP))-1 ) =  PACK(InData%SHAP ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%SHAP)
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%SHAPS))-1 ) =  PACK(InData%SHAPS ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%SHAPS)
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%GAUSSW))-1 ) =  PACK(InData%GAUSSW ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%GAUSSW)
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NGAUSS )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%SHAPT))-1 ) =  PACK(InData%SHAPT ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%SHAPT)
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%SHAPTS))-1 ) =  PACK(InData%SHAPTS ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%SHAPTS)
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%NTRAP )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%SBEND))-1 ) =  PACK(InData%SBEND ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%SBEND)
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%STEN))-1 ) =  PACK(InData%STEN ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%STEN)
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%RMASS))-1 ) =  PACK(InData%RMASS ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%RMASS)
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%RADDM))-1 ) =  PACK(InData%RADDM ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%RADDM)
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%PMPN))-1 ) =  PACK(InData%PMPN ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%PMPN)
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%AM))-1 ) =  PACK(InData%AM ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%AM)
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%PM))-1 ) =  PACK(InData%PM ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%PM)
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%IDOF))-1 ) = PACK(InData%IDOF ,.TRUE.)
  Int_Xferred   = Int_Xferred   + SIZE(InData%IDOF)
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%JDOF))-1 ) = PACK(InData%JDOF ,.TRUE.)
  Int_Xferred   = Int_Xferred   + SIZE(InData%JDOF)
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%PPA))-1 ) =  PACK(InData%PPA ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%PPA)
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%PtfmRefzt )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NumOuts )
  Int_Xferred   = Int_Xferred   + 1
 END SUBROUTINE FEAM_PackParam

 SUBROUTINE FEAM_UnpackParam( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(FEAM_parametertype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  OutData%DT = DbKiBuf ( Db_Xferred )
  Db_Xferred   = Db_Xferred   + 1
  ALLOCATE(mask1(SIZE(OutData%GRAV,1))); mask1 = .TRUE.
  OutData%GRAV = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%GRAV))-1 ),mask1,OutData%GRAV)
  DEALLOCATE(mask1)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%GRAV)
  OutData%EPS = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%Gravity = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%WtrDens = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%MITER = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%NHBD = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%NDIM = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  IF ( ALLOCATED(OutData%NEQ) ) THEN
  ALLOCATE(mask1(SIZE(OutData%NEQ,1))); mask1 = .TRUE.
    OutData%NEQ = UNPACK(IntKiBuf( Int_Xferred:Re_Xferred+(SIZE(OutData%NEQ))-1 ),mask1,OutData%NEQ)
  DEALLOCATE(mask1)
    Int_Xferred   = Int_Xferred   + SIZE(OutData%NEQ)
  ENDIF
  OutData%NBAND = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%NumLines = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%NumElems = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  IF ( ALLOCATED(OutData%GSL) ) THEN
  ALLOCATE(mask3(SIZE(OutData%GSL,1),SIZE(OutData%GSL,2),SIZE(OutData%GSL,3))); mask3 = .TRUE.
    OutData%GSL = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%GSL))-1 ),mask3,OutData%GSL)
  DEALLOCATE(mask3)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%GSL)
  ENDIF
  IF ( ALLOCATED(OutData%GP) ) THEN
  ALLOCATE(mask2(SIZE(OutData%GP,1),SIZE(OutData%GP,2))); mask2 = .TRUE.
    OutData%GP = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%GP))-1 ),mask2,OutData%GP)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%GP)
  ENDIF
  IF ( ALLOCATED(OutData%LineCI) ) THEN
  ALLOCATE(mask1(SIZE(OutData%LineCI,1))); mask1 = .TRUE.
    OutData%LineCI = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%LineCI))-1 ),mask1,OutData%LineCI)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%LineCI)
  ENDIF
  IF ( ALLOCATED(OutData%LineCD) ) THEN
  ALLOCATE(mask1(SIZE(OutData%LineCD,1))); mask1 = .TRUE.
    OutData%LineCD = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%LineCD))-1 ),mask1,OutData%LineCD)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%LineCD)
  ENDIF
  IF ( ALLOCATED(OutData%SectionA) ) THEN
  ALLOCATE(mask1(SIZE(OutData%SectionA,1))); mask1 = .TRUE.
    OutData%SectionA = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%SectionA))-1 ),mask1,OutData%SectionA)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%SectionA)
  ENDIF
  IF ( ALLOCATED(OutData%Elength) ) THEN
  ALLOCATE(mask1(SIZE(OutData%Elength,1))); mask1 = .TRUE.
    OutData%Elength = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Elength))-1 ),mask1,OutData%Elength)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%Elength)
  ENDIF
  IF ( ALLOCATED(OutData%BottmElev) ) THEN
  ALLOCATE(mask1(SIZE(OutData%BottmElev,1))); mask1 = .TRUE.
    OutData%BottmElev = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%BottmElev))-1 ),mask1,OutData%BottmElev)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%BottmElev)
  ENDIF
  IF ( ALLOCATED(OutData%BottmStiff) ) THEN
  ALLOCATE(mask1(SIZE(OutData%BottmStiff,1))); mask1 = .TRUE.
    OutData%BottmStiff = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%BottmStiff))-1 ),mask1,OutData%BottmStiff)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%BottmStiff)
  ENDIF
  IF ( ALLOCATED(OutData%LMassDen) ) THEN
  ALLOCATE(mask1(SIZE(OutData%LMassDen,1))); mask1 = .TRUE.
    OutData%LMassDen = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%LMassDen))-1 ),mask1,OutData%LMassDen)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%LMassDen)
  ENDIF
  IF ( ALLOCATED(OutData%LDMassDen) ) THEN
  ALLOCATE(mask1(SIZE(OutData%LDMassDen,1))); mask1 = .TRUE.
    OutData%LDMassDen = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%LDMassDen))-1 ),mask1,OutData%LDMassDen)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%LDMassDen)
  ENDIF
  IF ( ALLOCATED(OutData%LEAStiff) ) THEN
  ALLOCATE(mask1(SIZE(OutData%LEAStiff,1))); mask1 = .TRUE.
    OutData%LEAStiff = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%LEAStiff))-1 ),mask1,OutData%LEAStiff)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%LEAStiff)
  ENDIF
  IF ( ALLOCATED(OutData%Bvp) ) THEN
  ALLOCATE(mask2(SIZE(OutData%Bvp,1),SIZE(OutData%Bvp,2))); mask2 = .TRUE.
    OutData%Bvp = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Bvp))-1 ),mask2,OutData%Bvp)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%Bvp)
  ENDIF
  ALLOCATE(mask2(SIZE(OutData%SHAP,1),SIZE(OutData%SHAP,2))); mask2 = .TRUE.
  OutData%SHAP = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%SHAP))-1 ),mask2,OutData%SHAP)
  DEALLOCATE(mask2)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%SHAP)
  ALLOCATE(mask2(SIZE(OutData%SHAPS,1),SIZE(OutData%SHAPS,2))); mask2 = .TRUE.
  OutData%SHAPS = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%SHAPS))-1 ),mask2,OutData%SHAPS)
  DEALLOCATE(mask2)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%SHAPS)
  ALLOCATE(mask1(SIZE(OutData%GAUSSW,1))); mask1 = .TRUE.
  OutData%GAUSSW = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%GAUSSW))-1 ),mask1,OutData%GAUSSW)
  DEALLOCATE(mask1)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%GAUSSW)
  OutData%NGAUSS = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  ALLOCATE(mask2(SIZE(OutData%SHAPT,1),SIZE(OutData%SHAPT,2))); mask2 = .TRUE.
  OutData%SHAPT = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%SHAPT))-1 ),mask2,OutData%SHAPT)
  DEALLOCATE(mask2)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%SHAPT)
  ALLOCATE(mask2(SIZE(OutData%SHAPTS,1),SIZE(OutData%SHAPTS,2))); mask2 = .TRUE.
  OutData%SHAPTS = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%SHAPTS))-1 ),mask2,OutData%SHAPTS)
  DEALLOCATE(mask2)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%SHAPTS)
  OutData%NTRAP = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  ALLOCATE(mask2(SIZE(OutData%SBEND,1),SIZE(OutData%SBEND,2))); mask2 = .TRUE.
  OutData%SBEND = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%SBEND))-1 ),mask2,OutData%SBEND)
  DEALLOCATE(mask2)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%SBEND)
  ALLOCATE(mask3(SIZE(OutData%STEN,1),SIZE(OutData%STEN,2),SIZE(OutData%STEN,3))); mask3 = .TRUE.
  OutData%STEN = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%STEN))-1 ),mask3,OutData%STEN)
  DEALLOCATE(mask3)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%STEN)
  ALLOCATE(mask2(SIZE(OutData%RMASS,1),SIZE(OutData%RMASS,2))); mask2 = .TRUE.
  OutData%RMASS = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%RMASS))-1 ),mask2,OutData%RMASS)
  DEALLOCATE(mask2)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%RMASS)
  ALLOCATE(mask4(SIZE(OutData%RADDM,1),SIZE(OutData%RADDM,2),SIZE(OutData%RADDM,3),SIZE(OutData%RADDM,4))); mask4 = .TRUE.
  OutData%RADDM = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%RADDM))-1 ),mask4,OutData%RADDM)
  DEALLOCATE(mask4)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%RADDM)
  ALLOCATE(mask2(SIZE(OutData%PMPN,1),SIZE(OutData%PMPN,2))); mask2 = .TRUE.
  OutData%PMPN = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%PMPN))-1 ),mask2,OutData%PMPN)
  DEALLOCATE(mask2)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%PMPN)
  ALLOCATE(mask1(SIZE(OutData%AM,1))); mask1 = .TRUE.
  OutData%AM = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%AM))-1 ),mask1,OutData%AM)
  DEALLOCATE(mask1)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%AM)
  ALLOCATE(mask1(SIZE(OutData%PM,1))); mask1 = .TRUE.
  OutData%PM = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%PM))-1 ),mask1,OutData%PM)
  DEALLOCATE(mask1)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%PM)
  ALLOCATE(mask2(SIZE(OutData%IDOF,1),SIZE(OutData%IDOF,2))); mask2 = .TRUE.
  OutData%IDOF = UNPACK(IntKiBuf( Int_Xferred:Re_Xferred+(SIZE(OutData%IDOF))-1 ),mask2,OutData%IDOF)
  DEALLOCATE(mask2)
  Int_Xferred   = Int_Xferred   + SIZE(OutData%IDOF)
  ALLOCATE(mask1(SIZE(OutData%JDOF,1))); mask1 = .TRUE.
  OutData%JDOF = UNPACK(IntKiBuf( Int_Xferred:Re_Xferred+(SIZE(OutData%JDOF))-1 ),mask1,OutData%JDOF)
  DEALLOCATE(mask1)
  Int_Xferred   = Int_Xferred   + SIZE(OutData%JDOF)
  ALLOCATE(mask3(SIZE(OutData%PPA,1),SIZE(OutData%PPA,2),SIZE(OutData%PPA,3))); mask3 = .TRUE.
  OutData%PPA = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%PPA))-1 ),mask3,OutData%PPA)
  DEALLOCATE(mask3)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%PPA)
  OutData%PtfmRefzt = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%NumOuts = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE FEAM_UnpackParam

 SUBROUTINE FEAM_CopyInput( SrcInputData, DstInputData, CtrlCode, ErrStat, ErrMsg )
  TYPE(FEAM_inputtype), INTENT(INOUT) :: SrcInputData
  TYPE(FEAM_inputtype), INTENT(INOUT) :: DstInputData
  INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  CALL MeshCopy( SrcInputData%HydroForceLineMesh, DstInputData%HydroForceLineMesh, CtrlCode, ErrStat, ErrMsg )
  CALL MeshCopy( SrcInputData%PtFairleadDisplacement, DstInputData%PtFairleadDisplacement, CtrlCode, ErrStat, ErrMsg )
 END SUBROUTINE FEAM_CopyInput

 SUBROUTINE FEAM_DestroyInput( InputData, ErrStat, ErrMsg )
  TYPE(FEAM_inputtype), INTENT(INOUT) :: InputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  CALL MeshDestroy( InputData%HydroForceLineMesh, ErrStat, ErrMsg )
  CALL MeshDestroy( InputData%PtFairleadDisplacement, ErrStat, ErrMsg )
 END SUBROUTINE FEAM_DestroyInput

 SUBROUTINE FEAM_PackInput( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(FEAM_inputtype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_HydroForceLineMesh_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_HydroForceLineMesh_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_HydroForceLineMesh_Buf(:)
  REAL(ReKi),     ALLOCATABLE :: Re_PtFairleadDisplacement_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_PtFairleadDisplacement_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_PtFairleadDisplacement_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
 ! Allocate mesh buffers, if any (we'll also get sizes from these) 
  CALL MeshPack( InData%HydroForceLineMesh, Re_HydroForceLineMesh_Buf, Db_HydroForceLineMesh_Buf, Int_HydroForceLineMesh_Buf, ErrStat, ErrMsg, .TRUE. ) ! HydroForceLineMesh 
  IF(ALLOCATED(Re_HydroForceLineMesh_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_HydroForceLineMesh_Buf  ) ! HydroForceLineMesh
  IF(ALLOCATED(Db_HydroForceLineMesh_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_HydroForceLineMesh_Buf  ) ! HydroForceLineMesh
  IF(ALLOCATED(Int_HydroForceLineMesh_Buf))Int_BufSz = Int_BufSz + SIZE( Int_HydroForceLineMesh_Buf ) ! HydroForceLineMesh
  IF(ALLOCATED(Re_HydroForceLineMesh_Buf))  DEALLOCATE(Re_HydroForceLineMesh_Buf)
  IF(ALLOCATED(Db_HydroForceLineMesh_Buf))  DEALLOCATE(Db_HydroForceLineMesh_Buf)
  IF(ALLOCATED(Int_HydroForceLineMesh_Buf)) DEALLOCATE(Int_HydroForceLineMesh_Buf)
  CALL MeshPack( InData%PtFairleadDisplacement, Re_PtFairleadDisplacement_Buf, Db_PtFairleadDisplacement_Buf, Int_PtFairleadDisplacement_Buf, ErrStat, ErrMsg, .TRUE. ) ! PtFairleadDisplacement 
  IF(ALLOCATED(Re_PtFairleadDisplacement_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_PtFairleadDisplacement_Buf  ) ! PtFairleadDisplacement
  IF(ALLOCATED(Db_PtFairleadDisplacement_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_PtFairleadDisplacement_Buf  ) ! PtFairleadDisplacement
  IF(ALLOCATED(Int_PtFairleadDisplacement_Buf))Int_BufSz = Int_BufSz + SIZE( Int_PtFairleadDisplacement_Buf ) ! PtFairleadDisplacement
  IF(ALLOCATED(Re_PtFairleadDisplacement_Buf))  DEALLOCATE(Re_PtFairleadDisplacement_Buf)
  IF(ALLOCATED(Db_PtFairleadDisplacement_Buf))  DEALLOCATE(Db_PtFairleadDisplacement_Buf)
  IF(ALLOCATED(Int_PtFairleadDisplacement_Buf)) DEALLOCATE(Int_PtFairleadDisplacement_Buf)
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  CALL MeshPack( InData%HydroForceLineMesh, Re_HydroForceLineMesh_Buf, Db_HydroForceLineMesh_Buf, Int_HydroForceLineMesh_Buf, ErrStat, ErrMsg, OnlySize ) ! HydroForceLineMesh 
  IF(ALLOCATED(Re_HydroForceLineMesh_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_HydroForceLineMesh_Buf)-1 ) = Re_HydroForceLineMesh_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_HydroForceLineMesh_Buf)
  ENDIF
  IF(ALLOCATED(Db_HydroForceLineMesh_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_HydroForceLineMesh_Buf)-1 ) = Db_HydroForceLineMesh_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_HydroForceLineMesh_Buf)
  ENDIF
  IF(ALLOCATED(Int_HydroForceLineMesh_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_HydroForceLineMesh_Buf)-1 ) = Int_HydroForceLineMesh_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_HydroForceLineMesh_Buf)
  ENDIF
  IF( ALLOCATED(Re_HydroForceLineMesh_Buf) )  DEALLOCATE(Re_HydroForceLineMesh_Buf)
  IF( ALLOCATED(Db_HydroForceLineMesh_Buf) )  DEALLOCATE(Db_HydroForceLineMesh_Buf)
  IF( ALLOCATED(Int_HydroForceLineMesh_Buf) ) DEALLOCATE(Int_HydroForceLineMesh_Buf)
  CALL MeshPack( InData%PtFairleadDisplacement, Re_PtFairleadDisplacement_Buf, Db_PtFairleadDisplacement_Buf, Int_PtFairleadDisplacement_Buf, ErrStat, ErrMsg, OnlySize ) ! PtFairleadDisplacement 
  IF(ALLOCATED(Re_PtFairleadDisplacement_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_PtFairleadDisplacement_Buf)-1 ) = Re_PtFairleadDisplacement_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_PtFairleadDisplacement_Buf)
  ENDIF
  IF(ALLOCATED(Db_PtFairleadDisplacement_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_PtFairleadDisplacement_Buf)-1 ) = Db_PtFairleadDisplacement_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_PtFairleadDisplacement_Buf)
  ENDIF
  IF(ALLOCATED(Int_PtFairleadDisplacement_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_PtFairleadDisplacement_Buf)-1 ) = Int_PtFairleadDisplacement_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_PtFairleadDisplacement_Buf)
  ENDIF
  IF( ALLOCATED(Re_PtFairleadDisplacement_Buf) )  DEALLOCATE(Re_PtFairleadDisplacement_Buf)
  IF( ALLOCATED(Db_PtFairleadDisplacement_Buf) )  DEALLOCATE(Db_PtFairleadDisplacement_Buf)
  IF( ALLOCATED(Int_PtFairleadDisplacement_Buf) ) DEALLOCATE(Int_PtFairleadDisplacement_Buf)
 END SUBROUTINE FEAM_PackInput

 SUBROUTINE FEAM_UnpackInput( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(FEAM_inputtype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_HydroForceLineMesh_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_HydroForceLineMesh_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_HydroForceLineMesh_Buf(:)
  REAL(ReKi),    ALLOCATABLE :: Re_PtFairleadDisplacement_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_PtFairleadDisplacement_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_PtFairleadDisplacement_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
 ! first call MeshPack to get correctly sized buffers for unpacking
  CALL MeshPack( OutData%HydroForceLineMesh, Re_HydroForceLineMesh_Buf, Db_HydroForceLineMesh_Buf, Int_HydroForceLineMesh_Buf, ErrStat, ErrMsg , .TRUE. ) ! HydroForceLineMesh 
  IF(ALLOCATED(Re_HydroForceLineMesh_Buf)) THEN
    Re_HydroForceLineMesh_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_HydroForceLineMesh_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_HydroForceLineMesh_Buf)
  ENDIF
  IF(ALLOCATED(Db_HydroForceLineMesh_Buf)) THEN
    Db_HydroForceLineMesh_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_HydroForceLineMesh_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_HydroForceLineMesh_Buf)
  ENDIF
  IF(ALLOCATED(Int_HydroForceLineMesh_Buf)) THEN
    Int_HydroForceLineMesh_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_HydroForceLineMesh_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_HydroForceLineMesh_Buf)
  ENDIF
  CALL MeshUnPack( OutData%HydroForceLineMesh, Re_HydroForceLineMesh_Buf, Db_HydroForceLineMesh_Buf, Int_HydroForceLineMesh_Buf, ErrStat, ErrMsg ) ! HydroForceLineMesh 
  IF( ALLOCATED(Re_HydroForceLineMesh_Buf) )  DEALLOCATE(Re_HydroForceLineMesh_Buf)
  IF( ALLOCATED(Db_HydroForceLineMesh_Buf) )  DEALLOCATE(Db_HydroForceLineMesh_Buf)
  IF( ALLOCATED(Int_HydroForceLineMesh_Buf) ) DEALLOCATE(Int_HydroForceLineMesh_Buf)
  CALL MeshPack( OutData%PtFairleadDisplacement, Re_PtFairleadDisplacement_Buf, Db_PtFairleadDisplacement_Buf, Int_PtFairleadDisplacement_Buf, ErrStat, ErrMsg , .TRUE. ) ! PtFairleadDisplacement 
  IF(ALLOCATED(Re_PtFairleadDisplacement_Buf)) THEN
    Re_PtFairleadDisplacement_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_PtFairleadDisplacement_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_PtFairleadDisplacement_Buf)
  ENDIF
  IF(ALLOCATED(Db_PtFairleadDisplacement_Buf)) THEN
    Db_PtFairleadDisplacement_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_PtFairleadDisplacement_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_PtFairleadDisplacement_Buf)
  ENDIF
  IF(ALLOCATED(Int_PtFairleadDisplacement_Buf)) THEN
    Int_PtFairleadDisplacement_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_PtFairleadDisplacement_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_PtFairleadDisplacement_Buf)
  ENDIF
  CALL MeshUnPack( OutData%PtFairleadDisplacement, Re_PtFairleadDisplacement_Buf, Db_PtFairleadDisplacement_Buf, Int_PtFairleadDisplacement_Buf, ErrStat, ErrMsg ) ! PtFairleadDisplacement 
  IF( ALLOCATED(Re_PtFairleadDisplacement_Buf) )  DEALLOCATE(Re_PtFairleadDisplacement_Buf)
  IF( ALLOCATED(Db_PtFairleadDisplacement_Buf) )  DEALLOCATE(Db_PtFairleadDisplacement_Buf)
  IF( ALLOCATED(Int_PtFairleadDisplacement_Buf) ) DEALLOCATE(Int_PtFairleadDisplacement_Buf)
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE FEAM_UnpackInput

 SUBROUTINE FEAM_CopyOutput( SrcOutputData, DstOutputData, CtrlCode, ErrStat, ErrMsg )
  TYPE(FEAM_outputtype), INTENT(INOUT) :: SrcOutputData
  TYPE(FEAM_outputtype), INTENT(INOUT) :: DstOutputData
  INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF ( ALLOCATED( SrcOutputData%WriteOutput ) ) THEN
  i1 = SIZE(SrcOutputData%WriteOutput,1)
  IF (.NOT.ALLOCATED(DstOutputData%WriteOutput)) ALLOCATE(DstOutputData%WriteOutput(i1))
  DstOutputData%WriteOutput = SrcOutputData%WriteOutput
ENDIF
  CALL MeshCopy( SrcOutputData%PtFairleadLoad, DstOutputData%PtFairleadLoad, CtrlCode, ErrStat, ErrMsg )
  CALL MeshCopy( SrcOutputData%LineMeshPosition, DstOutputData%LineMeshPosition, CtrlCode, ErrStat, ErrMsg )
 END SUBROUTINE FEAM_CopyOutput

 SUBROUTINE FEAM_DestroyOutput( OutputData, ErrStat, ErrMsg )
  TYPE(FEAM_outputtype), INTENT(INOUT) :: OutputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  IF ( ALLOCATED(OutputData%WriteOutput) ) DEALLOCATE(OutputData%WriteOutput)
  CALL MeshDestroy( OutputData%PtFairleadLoad, ErrStat, ErrMsg )
  CALL MeshDestroy( OutputData%LineMeshPosition, ErrStat, ErrMsg )
 END SUBROUTINE FEAM_DestroyOutput

 SUBROUTINE FEAM_PackOutput( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(FEAM_outputtype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_PtFairleadLoad_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_PtFairleadLoad_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_PtFairleadLoad_Buf(:)
  REAL(ReKi),     ALLOCATABLE :: Re_LineMeshPosition_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_LineMeshPosition_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_LineMeshPosition_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Re_BufSz    = Re_BufSz    + SIZE( InData%WriteOutput )  ! WriteOutput 
 ! Allocate mesh buffers, if any (we'll also get sizes from these) 
  CALL MeshPack( InData%PtFairleadLoad, Re_PtFairleadLoad_Buf, Db_PtFairleadLoad_Buf, Int_PtFairleadLoad_Buf, ErrStat, ErrMsg, .TRUE. ) ! PtFairleadLoad 
  IF(ALLOCATED(Re_PtFairleadLoad_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_PtFairleadLoad_Buf  ) ! PtFairleadLoad
  IF(ALLOCATED(Db_PtFairleadLoad_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_PtFairleadLoad_Buf  ) ! PtFairleadLoad
  IF(ALLOCATED(Int_PtFairleadLoad_Buf))Int_BufSz = Int_BufSz + SIZE( Int_PtFairleadLoad_Buf ) ! PtFairleadLoad
  IF(ALLOCATED(Re_PtFairleadLoad_Buf))  DEALLOCATE(Re_PtFairleadLoad_Buf)
  IF(ALLOCATED(Db_PtFairleadLoad_Buf))  DEALLOCATE(Db_PtFairleadLoad_Buf)
  IF(ALLOCATED(Int_PtFairleadLoad_Buf)) DEALLOCATE(Int_PtFairleadLoad_Buf)
  CALL MeshPack( InData%LineMeshPosition, Re_LineMeshPosition_Buf, Db_LineMeshPosition_Buf, Int_LineMeshPosition_Buf, ErrStat, ErrMsg, .TRUE. ) ! LineMeshPosition 
  IF(ALLOCATED(Re_LineMeshPosition_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_LineMeshPosition_Buf  ) ! LineMeshPosition
  IF(ALLOCATED(Db_LineMeshPosition_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_LineMeshPosition_Buf  ) ! LineMeshPosition
  IF(ALLOCATED(Int_LineMeshPosition_Buf))Int_BufSz = Int_BufSz + SIZE( Int_LineMeshPosition_Buf ) ! LineMeshPosition
  IF(ALLOCATED(Re_LineMeshPosition_Buf))  DEALLOCATE(Re_LineMeshPosition_Buf)
  IF(ALLOCATED(Db_LineMeshPosition_Buf))  DEALLOCATE(Db_LineMeshPosition_Buf)
  IF(ALLOCATED(Int_LineMeshPosition_Buf)) DEALLOCATE(Int_LineMeshPosition_Buf)
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( ALLOCATED(InData%WriteOutput) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%WriteOutput))-1 ) =  PACK(InData%WriteOutput ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%WriteOutput)
  ENDIF
  CALL MeshPack( InData%PtFairleadLoad, Re_PtFairleadLoad_Buf, Db_PtFairleadLoad_Buf, Int_PtFairleadLoad_Buf, ErrStat, ErrMsg, OnlySize ) ! PtFairleadLoad 
  IF(ALLOCATED(Re_PtFairleadLoad_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_PtFairleadLoad_Buf)-1 ) = Re_PtFairleadLoad_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_PtFairleadLoad_Buf)
  ENDIF
  IF(ALLOCATED(Db_PtFairleadLoad_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_PtFairleadLoad_Buf)-1 ) = Db_PtFairleadLoad_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_PtFairleadLoad_Buf)
  ENDIF
  IF(ALLOCATED(Int_PtFairleadLoad_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_PtFairleadLoad_Buf)-1 ) = Int_PtFairleadLoad_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_PtFairleadLoad_Buf)
  ENDIF
  IF( ALLOCATED(Re_PtFairleadLoad_Buf) )  DEALLOCATE(Re_PtFairleadLoad_Buf)
  IF( ALLOCATED(Db_PtFairleadLoad_Buf) )  DEALLOCATE(Db_PtFairleadLoad_Buf)
  IF( ALLOCATED(Int_PtFairleadLoad_Buf) ) DEALLOCATE(Int_PtFairleadLoad_Buf)
  CALL MeshPack( InData%LineMeshPosition, Re_LineMeshPosition_Buf, Db_LineMeshPosition_Buf, Int_LineMeshPosition_Buf, ErrStat, ErrMsg, OnlySize ) ! LineMeshPosition 
  IF(ALLOCATED(Re_LineMeshPosition_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_LineMeshPosition_Buf)-1 ) = Re_LineMeshPosition_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_LineMeshPosition_Buf)
  ENDIF
  IF(ALLOCATED(Db_LineMeshPosition_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_LineMeshPosition_Buf)-1 ) = Db_LineMeshPosition_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_LineMeshPosition_Buf)
  ENDIF
  IF(ALLOCATED(Int_LineMeshPosition_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_LineMeshPosition_Buf)-1 ) = Int_LineMeshPosition_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_LineMeshPosition_Buf)
  ENDIF
  IF( ALLOCATED(Re_LineMeshPosition_Buf) )  DEALLOCATE(Re_LineMeshPosition_Buf)
  IF( ALLOCATED(Db_LineMeshPosition_Buf) )  DEALLOCATE(Db_LineMeshPosition_Buf)
  IF( ALLOCATED(Int_LineMeshPosition_Buf) ) DEALLOCATE(Int_LineMeshPosition_Buf)
 END SUBROUTINE FEAM_PackOutput

 SUBROUTINE FEAM_UnpackOutput( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(FEAM_outputtype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_PtFairleadLoad_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_PtFairleadLoad_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_PtFairleadLoad_Buf(:)
  REAL(ReKi),    ALLOCATABLE :: Re_LineMeshPosition_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_LineMeshPosition_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_LineMeshPosition_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  IF ( ALLOCATED(OutData%WriteOutput) ) THEN
  ALLOCATE(mask1(SIZE(OutData%WriteOutput,1))); mask1 = .TRUE.
    OutData%WriteOutput = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%WriteOutput))-1 ),mask1,OutData%WriteOutput)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%WriteOutput)
  ENDIF
 ! first call MeshPack to get correctly sized buffers for unpacking
  CALL MeshPack( OutData%PtFairleadLoad, Re_PtFairleadLoad_Buf, Db_PtFairleadLoad_Buf, Int_PtFairleadLoad_Buf, ErrStat, ErrMsg , .TRUE. ) ! PtFairleadLoad 
  IF(ALLOCATED(Re_PtFairleadLoad_Buf)) THEN
    Re_PtFairleadLoad_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_PtFairleadLoad_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_PtFairleadLoad_Buf)
  ENDIF
  IF(ALLOCATED(Db_PtFairleadLoad_Buf)) THEN
    Db_PtFairleadLoad_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_PtFairleadLoad_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_PtFairleadLoad_Buf)
  ENDIF
  IF(ALLOCATED(Int_PtFairleadLoad_Buf)) THEN
    Int_PtFairleadLoad_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_PtFairleadLoad_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_PtFairleadLoad_Buf)
  ENDIF
  CALL MeshUnPack( OutData%PtFairleadLoad, Re_PtFairleadLoad_Buf, Db_PtFairleadLoad_Buf, Int_PtFairleadLoad_Buf, ErrStat, ErrMsg ) ! PtFairleadLoad 
  IF( ALLOCATED(Re_PtFairleadLoad_Buf) )  DEALLOCATE(Re_PtFairleadLoad_Buf)
  IF( ALLOCATED(Db_PtFairleadLoad_Buf) )  DEALLOCATE(Db_PtFairleadLoad_Buf)
  IF( ALLOCATED(Int_PtFairleadLoad_Buf) ) DEALLOCATE(Int_PtFairleadLoad_Buf)
  CALL MeshPack( OutData%LineMeshPosition, Re_LineMeshPosition_Buf, Db_LineMeshPosition_Buf, Int_LineMeshPosition_Buf, ErrStat, ErrMsg , .TRUE. ) ! LineMeshPosition 
  IF(ALLOCATED(Re_LineMeshPosition_Buf)) THEN
    Re_LineMeshPosition_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_LineMeshPosition_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_LineMeshPosition_Buf)
  ENDIF
  IF(ALLOCATED(Db_LineMeshPosition_Buf)) THEN
    Db_LineMeshPosition_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_LineMeshPosition_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_LineMeshPosition_Buf)
  ENDIF
  IF(ALLOCATED(Int_LineMeshPosition_Buf)) THEN
    Int_LineMeshPosition_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_LineMeshPosition_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_LineMeshPosition_Buf)
  ENDIF
  CALL MeshUnPack( OutData%LineMeshPosition, Re_LineMeshPosition_Buf, Db_LineMeshPosition_Buf, Int_LineMeshPosition_Buf, ErrStat, ErrMsg ) ! LineMeshPosition 
  IF( ALLOCATED(Re_LineMeshPosition_Buf) )  DEALLOCATE(Re_LineMeshPosition_Buf)
  IF( ALLOCATED(Db_LineMeshPosition_Buf) )  DEALLOCATE(Db_LineMeshPosition_Buf)
  IF( ALLOCATED(Int_LineMeshPosition_Buf) ) DEALLOCATE(Int_LineMeshPosition_Buf)
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE FEAM_UnpackOutput

 SUBROUTINE FEAM_Pack( Re_RetAry, Db_RetAry, Int_RetAry, &
                     InData, ParamData, ContStateData, DiscStateData, &
                     ConstrStateData, OtherStateData, OutData, ErrStat, ErrMsg, &
                     SizeOnly )
  TYPE(FEAM_InputType),           INTENT(INOUT) :: InData
  TYPE(FEAM_ParameterType),       INTENT(INOUT) :: ParamData
  TYPE(FEAM_ContinuousStateType), INTENT(INOUT) :: ContStateData
  TYPE(FEAM_DiscreteStateType),   INTENT(INOUT) :: DiscStateData
  TYPE(FEAM_ConstraintStateType), INTENT(INOUT) :: ConstrStateData
  TYPE(FEAM_OtherStateType),      INTENT(INOUT) :: OtherStateData
  TYPE(FEAM_OutputType),          INTENT(INOUT) :: OutData
  REAL(ReKi), ALLOCATABLE,      INTENT(  OUT) :: Re_RetAry(:)
  REAL(DbKi), ALLOCATABLE,      INTENT(  OUT) :: Db_RetAry(:)
  INTEGER(IntKi), ALLOCATABLE,  INTENT(  OUT) :: Int_RetAry(:)
  INTEGER(IntKi),               INTENT(  OUT) :: ErrStat
  CHARACTER(*),                 INTENT(  OUT) :: ErrMsg
  LOGICAL, OPTIONAL,            INTENT(IN   ) :: SizeOnly
    ! Local variables
  REAL(ReKi), ALLOCATABLE                :: Re_Ary(:)
  REAL(DbKi), ALLOCATABLE                :: Db_Ary(:)
  INTEGER(IntKi), ALLOCATABLE            :: Int_Ary(:)
  INTEGER(IntKi)                         :: Re_BufSz
  INTEGER(IntKi)                         :: Re_Xferred
  INTEGER(IntKi)                         :: Re_CurrSz
  INTEGER(IntKi)                         :: Db_BufSz
  INTEGER(IntKi)                         :: Db_Xferred
  INTEGER(IntKi)                         :: Db_CurrSz
  INTEGER(IntKi)                         :: Int_BufSz
  INTEGER(IntKi)                         :: Int_Xferred
  INTEGER(IntKi)                         :: Int_CurrSz
  INTEGER(IntKi)                         :: ErrStat2
  CHARACTER(Len(ErrMsg))                 :: ErrMsg2
  LOGICAL                                :: OnlySize ! if present and true, do not pack, just allocate buffers
    ! Executable statements
  ErrStat = ErrID_None
  ErrMsg  = ""
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
    ! Pack Input
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
  CALL FEAM_PackInput(Re_Ary,Db_Ary,Int_Ary,InData,ErrStat2,ErrMsg2,SizeOnly=.TRUE.)
  IF ( ALLOCATED( Re_Ary ) ) THEN
    Re_Xferred = Re_Xferred + SIZE( Re_Ary )
    DEALLOCATE(Re_Ary)
  ENDIF
  IF ( ALLOCATED( Db_Ary ) ) THEN
    Db_Xferred = Db_Xferred + SIZE( Db_Ary )
    DEALLOCATE(Db_Ary)
  ENDIF
  IF ( ALLOCATED( Int_Ary ) ) THEN
    Int_Xferred = Int_Xferred + SIZE( Int_Ary )
    DEALLOCATE(Int_Ary)
  ENDIF
    ! Pack Param
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
  CALL FEAM_PackParam(Re_Ary,Db_Ary,Int_Ary,ParamData,ErrStat2,ErrMsg2,SizeOnly=.TRUE.)
  IF ( ALLOCATED( Re_Ary ) ) THEN
    Re_Xferred = Re_Xferred + SIZE( Re_Ary )
    DEALLOCATE(Re_Ary)
  ENDIF
  IF ( ALLOCATED( Db_Ary ) ) THEN
    Db_Xferred = Db_Xferred + SIZE( Db_Ary )
    DEALLOCATE(Db_Ary)
  ENDIF
  IF ( ALLOCATED( Int_Ary ) ) THEN
    Int_Xferred = Int_Xferred + SIZE( Int_Ary )
    DEALLOCATE(Int_Ary)
  ENDIF
    ! Pack ContState
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
  CALL FEAM_PackContState(Re_Ary,Db_Ary,Int_Ary,ContStateData,ErrStat2,ErrMsg2,SizeOnly=.TRUE.)
  IF ( ALLOCATED( Re_Ary ) ) THEN
    Re_Xferred = Re_Xferred + SIZE( Re_Ary )
    DEALLOCATE(Re_Ary)
  ENDIF
  IF ( ALLOCATED( Db_Ary ) ) THEN
    Db_Xferred = Db_Xferred + SIZE( Db_Ary )
    DEALLOCATE(Db_Ary)
  ENDIF
  IF ( ALLOCATED( Int_Ary ) ) THEN
    Int_Xferred = Int_Xferred + SIZE( Int_Ary )
    DEALLOCATE(Int_Ary)
  ENDIF
    ! Pack DiscState
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
  CALL FEAM_PackDiscState(Re_Ary,Db_Ary,Int_Ary,DiscStateData,ErrStat2,ErrMsg2,SizeOnly=.TRUE.)
  IF ( ALLOCATED( Re_Ary ) ) THEN
    Re_Xferred = Re_Xferred + SIZE( Re_Ary )
    DEALLOCATE(Re_Ary)
  ENDIF
  IF ( ALLOCATED( Db_Ary ) ) THEN
    Db_Xferred = Db_Xferred + SIZE( Db_Ary )
    DEALLOCATE(Db_Ary)
  ENDIF
  IF ( ALLOCATED( Int_Ary ) ) THEN
    Int_Xferred = Int_Xferred + SIZE( Int_Ary )
    DEALLOCATE(Int_Ary)
  ENDIF
    ! Pack ConstrState
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
  CALL FEAM_PackConstrState(Re_Ary,Db_Ary,Int_Ary,ConstrStateData,ErrStat2,ErrMsg2,SizeOnly=.TRUE.)
  IF ( ALLOCATED( Re_Ary ) ) THEN
    Re_Xferred = Re_Xferred + SIZE( Re_Ary )
    DEALLOCATE(Re_Ary)
  ENDIF
  IF ( ALLOCATED( Db_Ary ) ) THEN
    Db_Xferred = Db_Xferred + SIZE( Db_Ary )
    DEALLOCATE(Db_Ary)
  ENDIF
  IF ( ALLOCATED( Int_Ary ) ) THEN
    Int_Xferred = Int_Xferred + SIZE( Int_Ary )
    DEALLOCATE(Int_Ary)
  ENDIF
    ! Pack OtherState
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
  CALL FEAM_PackOtherState(Re_Ary,Db_Ary,Int_Ary,OtherStateData,ErrStat2,ErrMsg2,SizeOnly=.TRUE.)
  IF ( ALLOCATED( Re_Ary ) ) THEN
    Re_Xferred = Re_Xferred + SIZE( Re_Ary )
    DEALLOCATE(Re_Ary)
  ENDIF
  IF ( ALLOCATED( Db_Ary ) ) THEN
    Db_Xferred = Db_Xferred + SIZE( Db_Ary )
    DEALLOCATE(Db_Ary)
  ENDIF
  IF ( ALLOCATED( Int_Ary ) ) THEN
    Int_Xferred = Int_Xferred + SIZE( Int_Ary )
    DEALLOCATE(Int_Ary)
  ENDIF
    ! Pack Output
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
  CALL FEAM_PackOutput(Re_Ary,Db_Ary,Int_Ary,OutData,ErrStat2,ErrMsg2,SizeOnly=.TRUE.)
  IF ( ALLOCATED( Re_Ary ) ) THEN
    Re_Xferred = Re_Xferred + SIZE( Re_Ary )
    DEALLOCATE(Re_Ary)
  ENDIF
  IF ( ALLOCATED( Db_Ary ) ) THEN
    Db_Xferred = Db_Xferred + SIZE( Db_Ary )
    DEALLOCATE(Db_Ary)
  ENDIF
  IF ( ALLOCATED( Int_Ary ) ) THEN
    Int_Xferred = Int_Xferred + SIZE( Int_Ary )
    DEALLOCATE(Int_Ary)
  ENDIF
  Re_Xferred  = Re_Xferred - 1
  Db_Xferred  = Db_Xferred - 1
  Int_Xferred  = Int_Xferred - 1
  IF ( ALLOCATED( Re_RetAry ) ) DEALLOCATE( Re_RetAry ) ;
  IF ( Re_Xferred .GT. 0) ALLOCATE( Re_RetAry( Re_Xferred ) ) ;
  IF ( ALLOCATED( Db_RetAry ) ) DEALLOCATE( Db_RetAry ) ;
  IF ( Db_Xferred .GT. 0) ALLOCATE( Db_RetAry( Db_Xferred ) ) ;
  IF ( ALLOCATED( Int_RetAry ) ) DEALLOCATE( Int_RetAry ) ;
  IF ( Int_Xferred .GT. 0) ALLOCATE( Int_RetAry( Int_Xferred ) ) ;
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
    ! Pack Input
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
  CALL FEAM_PackInput(Re_Ary,Db_Ary,Int_Ary,InData,ErrStat2,ErrMsg2)
  IF ( ALLOCATED( Re_Ary ) ) THEN
    IF ( .NOT. OnlySize ) Re_RetAry(Re_Xferred:Re_Xferred+SIZE(Re_Ary)-1)=Re_Ary
    Re_Xferred = Re_Xferred + SIZE( Re_Ary )
    DEALLOCATE(Re_Ary)
  ENDIF
  IF ( ALLOCATED( Db_Ary ) ) THEN
    IF ( .NOT. OnlySize ) Db_RetAry(Db_Xferred:Db_Xferred+SIZE(Db_Ary)-1)=Db_Ary
    Db_Xferred = Db_Xferred + SIZE( Db_Ary )
    DEALLOCATE(Db_Ary)
  ENDIF
  IF ( ALLOCATED( Int_Ary ) ) THEN
    IF ( .NOT. OnlySize ) Int_RetAry(Int_Xferred:Int_Xferred+SIZE(Int_Ary)-1)=Int_Ary
    Int_Xferred = Int_Xferred + SIZE( Int_Ary )
    DEALLOCATE(Int_Ary)
  ENDIF
    ! Pack Param
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
  CALL FEAM_PackParam(Re_Ary,Db_Ary,Int_Ary,ParamData,ErrStat2,ErrMsg2)
  IF ( ALLOCATED( Re_Ary ) ) THEN
    IF ( .NOT. OnlySize ) Re_RetAry(Re_Xferred:Re_Xferred+SIZE(Re_Ary)-1)=Re_Ary
    Re_Xferred = Re_Xferred + SIZE( Re_Ary )
    DEALLOCATE(Re_Ary)
  ENDIF
  IF ( ALLOCATED( Db_Ary ) ) THEN
    IF ( .NOT. OnlySize ) Db_RetAry(Db_Xferred:Db_Xferred+SIZE(Db_Ary)-1)=Db_Ary
    Db_Xferred = Db_Xferred + SIZE( Db_Ary )
    DEALLOCATE(Db_Ary)
  ENDIF
  IF ( ALLOCATED( Int_Ary ) ) THEN
    IF ( .NOT. OnlySize ) Int_RetAry(Int_Xferred:Int_Xferred+SIZE(Int_Ary)-1)=Int_Ary
    Int_Xferred = Int_Xferred + SIZE( Int_Ary )
    DEALLOCATE(Int_Ary)
  ENDIF
    ! Pack ContState
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
  CALL FEAM_PackContState(Re_Ary,Db_Ary,Int_Ary,ContStateData,ErrStat2,ErrMsg2)
  IF ( ALLOCATED( Re_Ary ) ) THEN
    IF ( .NOT. OnlySize ) Re_RetAry(Re_Xferred:Re_Xferred+SIZE(Re_Ary)-1)=Re_Ary
    Re_Xferred = Re_Xferred + SIZE( Re_Ary )
    DEALLOCATE(Re_Ary)
  ENDIF
  IF ( ALLOCATED( Db_Ary ) ) THEN
    IF ( .NOT. OnlySize ) Db_RetAry(Db_Xferred:Db_Xferred+SIZE(Db_Ary)-1)=Db_Ary
    Db_Xferred = Db_Xferred + SIZE( Db_Ary )
    DEALLOCATE(Db_Ary)
  ENDIF
  IF ( ALLOCATED( Int_Ary ) ) THEN
    IF ( .NOT. OnlySize ) Int_RetAry(Int_Xferred:Int_Xferred+SIZE(Int_Ary)-1)=Int_Ary
    Int_Xferred = Int_Xferred + SIZE( Int_Ary )
    DEALLOCATE(Int_Ary)
  ENDIF
    ! Pack DiscState
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
  CALL FEAM_PackDiscState(Re_Ary,Db_Ary,Int_Ary,DiscStateData,ErrStat2,ErrMsg2)
  IF ( ALLOCATED( Re_Ary ) ) THEN
    IF ( .NOT. OnlySize ) Re_RetAry(Re_Xferred:Re_Xferred+SIZE(Re_Ary)-1)=Re_Ary
    Re_Xferred = Re_Xferred + SIZE( Re_Ary )
    DEALLOCATE(Re_Ary)
  ENDIF
  IF ( ALLOCATED( Db_Ary ) ) THEN
    IF ( .NOT. OnlySize ) Db_RetAry(Db_Xferred:Db_Xferred+SIZE(Db_Ary)-1)=Db_Ary
    Db_Xferred = Db_Xferred + SIZE( Db_Ary )
    DEALLOCATE(Db_Ary)
  ENDIF
  IF ( ALLOCATED( Int_Ary ) ) THEN
    IF ( .NOT. OnlySize ) Int_RetAry(Int_Xferred:Int_Xferred+SIZE(Int_Ary)-1)=Int_Ary
    Int_Xferred = Int_Xferred + SIZE( Int_Ary )
    DEALLOCATE(Int_Ary)
  ENDIF
    ! Pack ConstrState
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
  CALL FEAM_PackConstrState(Re_Ary,Db_Ary,Int_Ary,ConstrStateData,ErrStat2,ErrMsg2)
  IF ( ALLOCATED( Re_Ary ) ) THEN
    IF ( .NOT. OnlySize ) Re_RetAry(Re_Xferred:Re_Xferred+SIZE(Re_Ary)-1)=Re_Ary
    Re_Xferred = Re_Xferred + SIZE( Re_Ary )
    DEALLOCATE(Re_Ary)
  ENDIF
  IF ( ALLOCATED( Db_Ary ) ) THEN
    IF ( .NOT. OnlySize ) Db_RetAry(Db_Xferred:Db_Xferred+SIZE(Db_Ary)-1)=Db_Ary
    Db_Xferred = Db_Xferred + SIZE( Db_Ary )
    DEALLOCATE(Db_Ary)
  ENDIF
  IF ( ALLOCATED( Int_Ary ) ) THEN
    IF ( .NOT. OnlySize ) Int_RetAry(Int_Xferred:Int_Xferred+SIZE(Int_Ary)-1)=Int_Ary
    Int_Xferred = Int_Xferred + SIZE( Int_Ary )
    DEALLOCATE(Int_Ary)
  ENDIF
    ! Pack OtherState
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
  CALL FEAM_PackOtherState(Re_Ary,Db_Ary,Int_Ary,OtherStateData,ErrStat2,ErrMsg2)
  IF ( ALLOCATED( Re_Ary ) ) THEN
    IF ( .NOT. OnlySize ) Re_RetAry(Re_Xferred:Re_Xferred+SIZE(Re_Ary)-1)=Re_Ary
    Re_Xferred = Re_Xferred + SIZE( Re_Ary )
    DEALLOCATE(Re_Ary)
  ENDIF
  IF ( ALLOCATED( Db_Ary ) ) THEN
    IF ( .NOT. OnlySize ) Db_RetAry(Db_Xferred:Db_Xferred+SIZE(Db_Ary)-1)=Db_Ary
    Db_Xferred = Db_Xferred + SIZE( Db_Ary )
    DEALLOCATE(Db_Ary)
  ENDIF
  IF ( ALLOCATED( Int_Ary ) ) THEN
    IF ( .NOT. OnlySize ) Int_RetAry(Int_Xferred:Int_Xferred+SIZE(Int_Ary)-1)=Int_Ary
    Int_Xferred = Int_Xferred + SIZE( Int_Ary )
    DEALLOCATE(Int_Ary)
  ENDIF
    ! Pack Output
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
  CALL FEAM_PackOutput(Re_Ary,Db_Ary,Int_Ary,OutData,ErrStat2,ErrMsg2)
  IF ( ALLOCATED( Re_Ary ) ) THEN
    IF ( .NOT. OnlySize ) Re_RetAry(Re_Xferred:Re_Xferred+SIZE(Re_Ary)-1)=Re_Ary
    Re_Xferred = Re_Xferred + SIZE( Re_Ary )
    DEALLOCATE(Re_Ary)
  ENDIF
  IF ( ALLOCATED( Db_Ary ) ) THEN
    IF ( .NOT. OnlySize ) Db_RetAry(Db_Xferred:Db_Xferred+SIZE(Db_Ary)-1)=Db_Ary
    Db_Xferred = Db_Xferred + SIZE( Db_Ary )
    DEALLOCATE(Db_Ary)
  ENDIF
  IF ( ALLOCATED( Int_Ary ) ) THEN
    IF ( .NOT. OnlySize ) Int_RetAry(Int_Xferred:Int_Xferred+SIZE(Int_Ary)-1)=Int_Ary
    Int_Xferred = Int_Xferred + SIZE( Int_Ary )
    DEALLOCATE(Int_Ary)
  ENDIF
  Re_Xferred   = Re_Xferred - 1
  Db_Xferred   = Db_Xferred - 1
  Int_Xferred  = Int_Xferred - 1
 END SUBROUTINE FEAM_Pack

 SUBROUTINE FEAM_Unpack( Re_RetAry, Db_RetAry, Int_RetAry, &
                     InData, ParamData, ContStateData, DiscStateData, &
                     ConstrStateData, OtherStateData, OutData, ErrStat, ErrMsg )
  TYPE(FEAM_InputType),           INTENT(INOUT) :: InData
  TYPE(FEAM_ParameterType),       INTENT(INOUT) :: ParamData
  TYPE(FEAM_ContinuousStateType), INTENT(INOUT) :: ContStateData
  TYPE(FEAM_DiscreteStateType),   INTENT(INOUT) :: DiscStateData
  TYPE(FEAM_ConstraintStateType), INTENT(INOUT) :: ConstrStateData
  TYPE(FEAM_OtherStateType),      INTENT(INOUT) :: OtherStateData
  TYPE(FEAM_OutputType),          INTENT(INOUT) :: OutData
  REAL(ReKi), ALLOCATABLE,      INTENT(IN   ) :: Re_RetAry(:)
  REAL(DbKi), ALLOCATABLE,      INTENT(IN   ) :: Db_RetAry(:)
  INTEGER(IntKi), ALLOCATABLE,   INTENT(IN   ) :: Int_RetAry(:)
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  REAL(ReKi), ALLOCATABLE                :: Re_Ary(:)
  REAL(DbKi), ALLOCATABLE                :: Db_Ary(:)
  INTEGER(IntKi), ALLOCATABLE            :: Int_Ary(:)
  INTEGER(IntKi)                         :: Re_BufSz
  INTEGER(IntKi)                         :: Re_Xferred
  INTEGER(IntKi)                         :: Re_CurrSz
  INTEGER(IntKi)                         :: Db_BufSz
  INTEGER(IntKi)                         :: Db_Xferred
  INTEGER(IntKi)                         :: Db_CurrSz
  INTEGER(IntKi)                         :: Int_BufSz
  INTEGER(IntKi)                         :: Int_Xferred
  INTEGER(IntKi)                         :: Int_CurrSz
  INTEGER(IntKi)                         :: ErrStat2
  CHARACTER(Len(ErrMsg))                 :: ErrMsg2
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
    ! Unpack Input
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
  CALL FEAM_PackInput(Re_Ary,Db_Ary,Int_Ary,InData,ErrStat2,ErrMsg2,SizeOnly=.TRUE.)
  IF ( ALLOCATED( Re_Ary ) ) THEN
    Re_Ary = Re_RetAry(Re_Xferred:Re_Xferred+SIZE(Re_Ary)-1)
    Re_Xferred = Re_Xferred + SIZE( Re_Ary )
  ENDIF
  IF ( ALLOCATED( Db_Ary ) ) THEN
    DB_Ary = Db_RetAry(Db_Xferred:Db_Xferred+SIZE(Db_Ary)-1)
    Db_Xferred = Db_Xferred + SIZE( Db_Ary )
  ENDIF
  IF ( ALLOCATED( Int_Ary ) ) THEN
    Int_Ary = Int_RetAry(Int_Xferred:Int_Xferred+SIZE(Int_Ary)-1)
    Int_Xferred = Int_Xferred + SIZE( Int_Ary )
  ENDIF
  CALL FEAM_UnpackInput(Re_Ary,Db_Ary,Int_Ary,InData,ErrStat2,ErrMsg2)
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
    ! Unpack Param
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
  CALL FEAM_PackParam(Re_Ary,Db_Ary,Int_Ary,ParamData,ErrStat2,ErrMsg2,SizeOnly=.TRUE.)
  IF ( ALLOCATED( Re_Ary ) ) THEN
    Re_Ary = Re_RetAry(Re_Xferred:Re_Xferred+SIZE(Re_Ary)-1)
    Re_Xferred = Re_Xferred + SIZE( Re_Ary )
  ENDIF
  IF ( ALLOCATED( Db_Ary ) ) THEN
    DB_Ary = Db_RetAry(Db_Xferred:Db_Xferred+SIZE(Db_Ary)-1)
    Db_Xferred = Db_Xferred + SIZE( Db_Ary )
  ENDIF
  IF ( ALLOCATED( Int_Ary ) ) THEN
    Int_Ary = Int_RetAry(Int_Xferred:Int_Xferred+SIZE(Int_Ary)-1)
    Int_Xferred = Int_Xferred + SIZE( Int_Ary )
  ENDIF
  CALL FEAM_UnpackParam(Re_Ary,Db_Ary,Int_Ary,ParamData,ErrStat2,ErrMsg2)
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
    ! Unpack ContState
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
  CALL FEAM_PackContState(Re_Ary,Db_Ary,Int_Ary,ContStateData,ErrStat2,ErrMsg2,SizeOnly=.TRUE.)
  IF ( ALLOCATED( Re_Ary ) ) THEN
    Re_Ary = Re_RetAry(Re_Xferred:Re_Xferred+SIZE(Re_Ary)-1)
    Re_Xferred = Re_Xferred + SIZE( Re_Ary )
  ENDIF
  IF ( ALLOCATED( Db_Ary ) ) THEN
    DB_Ary = Db_RetAry(Db_Xferred:Db_Xferred+SIZE(Db_Ary)-1)
    Db_Xferred = Db_Xferred + SIZE( Db_Ary )
  ENDIF
  IF ( ALLOCATED( Int_Ary ) ) THEN
    Int_Ary = Int_RetAry(Int_Xferred:Int_Xferred+SIZE(Int_Ary)-1)
    Int_Xferred = Int_Xferred + SIZE( Int_Ary )
  ENDIF
  CALL FEAM_UnpackContState(Re_Ary,Db_Ary,Int_Ary,ContStateData,ErrStat2,ErrMsg2)
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
    ! Unpack DiscState
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
  CALL FEAM_PackDiscState(Re_Ary,Db_Ary,Int_Ary,DiscStateData,ErrStat2,ErrMsg2,SizeOnly=.TRUE.)
  IF ( ALLOCATED( Re_Ary ) ) THEN
    Re_Ary = Re_RetAry(Re_Xferred:Re_Xferred+SIZE(Re_Ary)-1)
    Re_Xferred = Re_Xferred + SIZE( Re_Ary )
  ENDIF
  IF ( ALLOCATED( Db_Ary ) ) THEN
    DB_Ary = Db_RetAry(Db_Xferred:Db_Xferred+SIZE(Db_Ary)-1)
    Db_Xferred = Db_Xferred + SIZE( Db_Ary )
  ENDIF
  IF ( ALLOCATED( Int_Ary ) ) THEN
    Int_Ary = Int_RetAry(Int_Xferred:Int_Xferred+SIZE(Int_Ary)-1)
    Int_Xferred = Int_Xferred + SIZE( Int_Ary )
  ENDIF
  CALL FEAM_UnpackDiscState(Re_Ary,Db_Ary,Int_Ary,DiscStateData,ErrStat2,ErrMsg2)
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
    ! Unpack ConstrState
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
  CALL FEAM_PackConstrState(Re_Ary,Db_Ary,Int_Ary,ConstrStateData,ErrStat2,ErrMsg2,SizeOnly=.TRUE.)
  IF ( ALLOCATED( Re_Ary ) ) THEN
    Re_Ary = Re_RetAry(Re_Xferred:Re_Xferred+SIZE(Re_Ary)-1)
    Re_Xferred = Re_Xferred + SIZE( Re_Ary )
  ENDIF
  IF ( ALLOCATED( Db_Ary ) ) THEN
    DB_Ary = Db_RetAry(Db_Xferred:Db_Xferred+SIZE(Db_Ary)-1)
    Db_Xferred = Db_Xferred + SIZE( Db_Ary )
  ENDIF
  IF ( ALLOCATED( Int_Ary ) ) THEN
    Int_Ary = Int_RetAry(Int_Xferred:Int_Xferred+SIZE(Int_Ary)-1)
    Int_Xferred = Int_Xferred + SIZE( Int_Ary )
  ENDIF
  CALL FEAM_UnpackConstrState(Re_Ary,Db_Ary,Int_Ary,ConstrStateData,ErrStat2,ErrMsg2)
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
    ! Unpack OtherState
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
  CALL FEAM_PackOtherState(Re_Ary,Db_Ary,Int_Ary,OtherStateData,ErrStat2,ErrMsg2,SizeOnly=.TRUE.)
  IF ( ALLOCATED( Re_Ary ) ) THEN
    Re_Ary = Re_RetAry(Re_Xferred:Re_Xferred+SIZE(Re_Ary)-1)
    Re_Xferred = Re_Xferred + SIZE( Re_Ary )
  ENDIF
  IF ( ALLOCATED( Db_Ary ) ) THEN
    DB_Ary = Db_RetAry(Db_Xferred:Db_Xferred+SIZE(Db_Ary)-1)
    Db_Xferred = Db_Xferred + SIZE( Db_Ary )
  ENDIF
  IF ( ALLOCATED( Int_Ary ) ) THEN
    Int_Ary = Int_RetAry(Int_Xferred:Int_Xferred+SIZE(Int_Ary)-1)
    Int_Xferred = Int_Xferred + SIZE( Int_Ary )
  ENDIF
  CALL FEAM_UnpackOtherState(Re_Ary,Db_Ary,Int_Ary,OtherStateData,ErrStat2,ErrMsg2)
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
    ! Unpack Output
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
  CALL FEAM_PackOutput(Re_Ary,Db_Ary,Int_Ary,OutData,ErrStat2,ErrMsg2,SizeOnly=.TRUE.)
  IF ( ALLOCATED( Re_Ary ) ) THEN
    Re_Ary = Re_RetAry(Re_Xferred:Re_Xferred+SIZE(Re_Ary)-1)
    Re_Xferred = Re_Xferred + SIZE( Re_Ary )
  ENDIF
  IF ( ALLOCATED( Db_Ary ) ) THEN
    DB_Ary = Db_RetAry(Db_Xferred:Db_Xferred+SIZE(Db_Ary)-1)
    Db_Xferred = Db_Xferred + SIZE( Db_Ary )
  ENDIF
  IF ( ALLOCATED( Int_Ary ) ) THEN
    Int_Ary = Int_RetAry(Int_Xferred:Int_Xferred+SIZE(Int_Ary)-1)
    Int_Xferred = Int_Xferred + SIZE( Int_Ary )
  ENDIF
  CALL FEAM_UnpackOutput(Re_Ary,Db_Ary,Int_Ary,OutData,ErrStat2,ErrMsg2)
  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE FEAM_Unpack


 SUBROUTINE FEAM_Input_ExtrapInterp(u, tin, u_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) input u_out at time t_out, from previous/future time
! values of u (which has values associated with times in t).  Order of the interpolation is given by the size of u
!
!  expressions below based on either
!
!  f(t) = a
!  f(t) = a + b * t, or
!  f(t) = a + b * t + c * t**2
!
!  where a, b and c are determined as the solution to
!  f(t1) = u1, f(t2) = u2, f(t3) = u3  (as appropriate)
!
!..................................................................................................................................

 TYPE(FEAM_inputtype), INTENT(INOUT)  :: u(:)      ! Inputs at t1 > t2 > t3
 REAL(DbKi),         INTENT(IN   )  :: tin(:)      ! Times associated with the inputs
 TYPE(FEAM_inputtype), INTENT(INOUT)  :: u_out     ! Inputs at t1 > t2 > t3
 REAL(DbKi),         INTENT(IN   )  :: tin_out     ! time to be extrap/interp'd to
 INTEGER(IntKi),     INTENT(  OUT)  :: ErrStat   ! Error status of the operation
 CHARACTER(*),       INTENT(  OUT)  :: ErrMsg    ! Error message if ErrStat /= ErrID_None
   ! local variables
 REAL(DbKi) :: t(SIZE(tin))    ! Times associated with the inputs
 REAL(DbKi) :: t_out           ! Time to which to be extrap/interpd
 TYPE(MeshType) :: tmpmesh
 INTEGER(IntKi)                 :: order    ! order of polynomial fit (max 2)
 REAL(ReKi),ALLOCATABLE,DIMENSION(:)        :: mr1       ! temporary for extrapolaton/interpolation
 REAL(ReKi),ALLOCATABLE,DIMENSION(:)        :: mr2       ! temporary for extrapolation/interpolation
 REAL(ReKi),ALLOCATABLE,DIMENSION(:)        :: mr3       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:)        :: md1       ! temporary for extrapolaton/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:)        :: md2       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:)        :: md3       ! temporary for extrapolation/interpolation
 INTEGER(IntKi),ALLOCATABLE,DIMENSION(:)    :: mi1       ! temporary for extrapolaton/interpolation
 INTEGER(IntKi),ALLOCATABLE,DIMENSION(:)    :: mi2       ! temporary for extrapolation/interpolation
 INTEGER(IntKi),ALLOCATABLE,DIMENSION(:)    :: mi3       ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: a0       ! temporary for extrapolaton/interpolation
 REAL(DbKi)                                 :: b0       ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: c0       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:)        :: b1       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:)        :: c1       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:)      :: b2       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:)      :: c2       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:)    :: b3       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:)    :: c3       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:,:)  :: b4       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:,:)  :: c4       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:,:,:):: b5       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:,:,:):: c5       ! temporary for extrapolation/interpolation
 INTEGER                                    :: i01    ! dim1 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i11    ! dim1 level 1 counter variable for arrays of ddts
 INTEGER                                    :: i21    ! dim1 level 2 counter variable for arrays of ddts
 INTEGER                                    :: i31    ! dim1 level 3 counter variable for arrays of ddts
 INTEGER                                    :: i41    ! dim1 level 4 counter variable for arrays of ddts
 INTEGER                                    :: i51    ! dim1 level 5 counter variable for arrays of ddts
 INTEGER                                    :: i61    ! dim1 level 6 counter variable for arrays of ddts
 INTEGER                                    :: i71    ! dim1 level 7 counter variable for arrays of ddts
 INTEGER                                    :: i81    ! dim1 level 8 counter variable for arrays of ddts
 INTEGER                                    :: i91    ! dim1 level 9 counter variable for arrays of ddts
 INTEGER                                    :: i02    ! dim2 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i12    ! dim2 level 1 counter variable for arrays of ddts
 INTEGER                                    :: i22    ! dim2 level 2 counter variable for arrays of ddts
 INTEGER                                    :: i32    ! dim2 level 3 counter variable for arrays of ddts
 INTEGER                                    :: i42    ! dim2 level 4 counter variable for arrays of ddts
 INTEGER                                    :: i52    ! dim2 level 5 counter variable for arrays of ddts
 INTEGER                                    :: i62    ! dim2 level 6 counter variable for arrays of ddts
 INTEGER                                    :: i72    ! dim2 level 7 counter variable for arrays of ddts
 INTEGER                                    :: i82    ! dim2 level 8 counter variable for arrays of ddts
 INTEGER                                    :: i92    ! dim2 level 9 counter variable for arrays of ddts
 INTEGER                                    :: i03    ! dim3 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i13    ! dim3 level 1 counter variable for arrays of ddts
 INTEGER                                    :: i23    ! dim3 level 2 counter variable for arrays of ddts
 INTEGER                                    :: i33    ! dim3 level 3 counter variable for arrays of ddts
 INTEGER                                    :: i43    ! dim3 level 4 counter variable for arrays of ddts
 INTEGER                                    :: i53    ! dim3 level 5 counter variable for arrays of ddts
 INTEGER                                    :: i63    ! dim3 level 6 counter variable for arrays of ddts
 INTEGER                                    :: i73    ! dim3 level 7 counter variable for arrays of ddts
 INTEGER                                    :: i83    ! dim3 level 8 counter variable for arrays of ddts
 INTEGER                                    :: i93    ! dim3 level 9 counter variable for arrays of ddts
 INTEGER                                    :: i04    ! dim4 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i14    ! dim4 level 1 counter variable for arrays of ddts
 INTEGER                                    :: i24    ! dim4 level 2 counter variable for arrays of ddts
 INTEGER                                    :: i34    ! dim4 level 3 counter variable for arrays of ddts
 INTEGER                                    :: i44    ! dim4 level 4 counter variable for arrays of ddts
 INTEGER                                    :: i54    ! dim4 level 5 counter variable for arrays of ddts
 INTEGER                                    :: i64    ! dim4 level 6 counter variable for arrays of ddts
 INTEGER                                    :: i74    ! dim4 level 7 counter variable for arrays of ddts
 INTEGER                                    :: i84    ! dim4 level 8 counter variable for arrays of ddts
 INTEGER                                    :: i94    ! dim4 level 9 counter variable for arrays of ddts
 INTEGER                                    :: i05    ! dim5 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i15    ! dim5 level 1 counter variable for arrays of ddts
 INTEGER                                    :: i25    ! dim5 level 2 counter variable for arrays of ddts
 INTEGER                                    :: i35    ! dim5 level 3 counter variable for arrays of ddts
 INTEGER                                    :: i45    ! dim5 level 4 counter variable for arrays of ddts
 INTEGER                                    :: i55    ! dim5 level 5 counter variable for arrays of ddts
 INTEGER                                    :: i65    ! dim5 level 6 counter variable for arrays of ddts
 INTEGER                                    :: i75    ! dim5 level 7 counter variable for arrays of ddts
 INTEGER                                    :: i85    ! dim5 level 8 counter variable for arrays of ddts
 INTEGER                                    :: i95    ! dim5 level 9 counter variable for arrays of ddts
    ! Initialize ErrStat
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
    ! we're subtract a constant from the times to resolve some 
    ! numerical issues when t gets large (and to simplify the equations)
 t = tin - tin(1)
 t_out = tin_out - tin(1)

 if ( size(t) .ne. size(u)) then
    ErrStat = ErrID_Fatal
    ErrMsg = ' Error in FEAM_Input_ExtrapInterp: size(t) must equal size(u) '
    RETURN
 endif
 if (size(u) .gt. 3) then
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in FEAM_Input_ExtrapInterp: size(u) must be less than 4 '
    RETURN
 endif
 order = SIZE(u) - 1
 IF ( order .eq. 0 ) THEN
  CALL MeshCopy(u(1)%HydroForceLineMesh, u_out%HydroForceLineMesh, MESH_UPDATECOPY, ErrStat, ErrMsg )
  CALL MeshCopy(u(1)%PtFairleadDisplacement, u_out%PtFairleadDisplacement, MESH_UPDATECOPY, ErrStat, ErrMsg )
 ELSE IF ( order .eq. 1 ) THEN
  IF ( EqualRealNos( t(1), t(2) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in FEAM_Input_ExtrapInterp: t(1) must not equal t(2) to avoid a division-by-zero error.'
    RETURN
  END IF
  CALL MeshPack(u(1)%HydroForceLineMesh, mr1, md1, mi1, ErrStat, ErrMsg )
  CALL MeshPack(u(2)%HydroForceLineMesh, mr2, md2, mi2, ErrStat, ErrMsg )
  ALLOCATE(b1(SIZE(mr1)))
  b1 = -(mr1 - mr2)/t(2)
  mr1 = mr1 + b1 * t_out
  DEALLOCATE(b1)
  ALLOCATE(b1(SIZE(md1)))
  b1 = -(md1 - md2)/t(2)
  md1 = md1 + b1 * t_out
  DEALLOCATE(b1)
  CALL MeshUnPack(tmpmesh, mr1, md1, mi1, ErrStat, ErrMsg )
  CALL MeshCopy(tmpmesh, u_out%HydroForceLineMesh, MESH_UPDATECOPY, ErrStat, ErrMsg )
  CALL MeshDestroy(tmpmesh, ErrStat, ErrMsg )
  DEALLOCATE(mr1,md1,mi1,mr2,md2,mi2)
  CALL MeshPack(u(1)%PtFairleadDisplacement, mr1, md1, mi1, ErrStat, ErrMsg )
  CALL MeshPack(u(2)%PtFairleadDisplacement, mr2, md2, mi2, ErrStat, ErrMsg )
  ALLOCATE(b1(SIZE(mr1)))
  b1 = -(mr1 - mr2)/t(2)
  mr1 = mr1 + b1 * t_out
  DEALLOCATE(b1)
  ALLOCATE(b1(SIZE(md1)))
  b1 = -(md1 - md2)/t(2)
  md1 = md1 + b1 * t_out
  DEALLOCATE(b1)
  CALL MeshUnPack(tmpmesh, mr1, md1, mi1, ErrStat, ErrMsg )
  CALL MeshCopy(tmpmesh, u_out%PtFairleadDisplacement, MESH_UPDATECOPY, ErrStat, ErrMsg )
  CALL MeshDestroy(tmpmesh, ErrStat, ErrMsg )
  DEALLOCATE(mr1,md1,mi1,mr2,md2,mi2)
 ELSE IF ( order .eq. 2 ) THEN
  IF ( EqualRealNos( t(1), t(2) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in FEAM_Input_ExtrapInterp: t(1) must not equal t(2) to avoid a division-by-zero error.'
    RETURN
  END IF
  IF ( EqualRealNos( t(2), t(3) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in FEAM_Input_ExtrapInterp: t(2) must not equal t(3) to avoid a division-by-zero error.'
    RETURN
  END IF
  IF ( EqualRealNos( t(1), t(3) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in FEAM_Input_ExtrapInterp: t(1) must not equal t(3) to avoid a division-by-zero error.'
    RETURN
  END IF
  CALL MeshPack(u(1)%HydroForceLineMesh, mr1, md1, mi1, ErrStat, ErrMsg )
  CALL MeshPack(u(2)%HydroForceLineMesh, mr2, md2, mi2, ErrStat, ErrMsg )
  CALL MeshPack(u(3)%HydroForceLineMesh, mr3, md3, mi3, ErrStat, ErrMsg )
  ALLOCATE(b1(SIZE(mr1)))
  ALLOCATE(c1(SIZE(mr1)))
  b1 = (t(3)**2*(mr1 - mr2) + t(2)**2*(-mr1 + mr3))/(t(2)*t(3)*(t(2) - t(3)))
  c1 = ( (t(2)-t(3))*mr1 + t(3)*mr2 - t(2)*mr3 ) / (t(2)*t(3)*(t(2) - t(3)))
  mr1 = mr1 + b1 * t_out + c1 * t_out**2
  DEALLOCATE(b1)
  DEALLOCATE(c1)
  ALLOCATE(b1(SIZE(md1)))
  ALLOCATE(c1(SIZE(md1)))
  b1 = (t(3)**2*(md1 - md2) + t(2)**2*(-md1 + md3))/(t(2)*t(3)*(t(2) - t(3)))
  c1 = ( (t(2)-t(3))*md1 + t(3)*md2 - t(2)*md3 ) / (t(2)*t(3)*(t(2) - t(3)))
  md1 = md1 + b1 * t_out + c1 * t_out**2
  DEALLOCATE(b1)
  DEALLOCATE(c1)
  CALL MeshUnPack(tmpmesh, mr1, md1, mi1, ErrStat, ErrMsg )
  CALL MeshCopy(tmpmesh, u_out%HydroForceLineMesh, MESH_UPDATECOPY, ErrStat, ErrMsg )
  CALL MeshDestroy(tmpmesh, ErrStat, ErrMsg )
  DEALLOCATE(mr1,md1,mi1,mr2,md2,mi2,mr3,md3,mi3)
  CALL MeshPack(u(1)%PtFairleadDisplacement, mr1, md1, mi1, ErrStat, ErrMsg )
  CALL MeshPack(u(2)%PtFairleadDisplacement, mr2, md2, mi2, ErrStat, ErrMsg )
  CALL MeshPack(u(3)%PtFairleadDisplacement, mr3, md3, mi3, ErrStat, ErrMsg )
  ALLOCATE(b1(SIZE(mr1)))
  ALLOCATE(c1(SIZE(mr1)))
  b1 = (t(3)**2*(mr1 - mr2) + t(2)**2*(-mr1 + mr3))/(t(2)*t(3)*(t(2) - t(3)))
  c1 = ( (t(2)-t(3))*mr1 + t(3)*mr2 - t(2)*mr3 ) / (t(2)*t(3)*(t(2) - t(3)))
  mr1 = mr1 + b1 * t_out + c1 * t_out**2
  DEALLOCATE(b1)
  DEALLOCATE(c1)
  ALLOCATE(b1(SIZE(md1)))
  ALLOCATE(c1(SIZE(md1)))
  b1 = (t(3)**2*(md1 - md2) + t(2)**2*(-md1 + md3))/(t(2)*t(3)*(t(2) - t(3)))
  c1 = ( (t(2)-t(3))*md1 + t(3)*md2 - t(2)*md3 ) / (t(2)*t(3)*(t(2) - t(3)))
  md1 = md1 + b1 * t_out + c1 * t_out**2
  DEALLOCATE(b1)
  DEALLOCATE(c1)
  CALL MeshUnPack(tmpmesh, mr1, md1, mi1, ErrStat, ErrMsg )
  CALL MeshCopy(tmpmesh, u_out%PtFairleadDisplacement, MESH_UPDATECOPY, ErrStat, ErrMsg )
  CALL MeshDestroy(tmpmesh, ErrStat, ErrMsg )
  DEALLOCATE(mr1,md1,mi1,mr2,md2,mi2,mr3,md3,mi3)
 ELSE 
   ErrStat = ErrID_Fatal
   ErrMsg = ' order must be less than 3 in FEAM_Input_ExtrapInterp '
   RETURN
 ENDIF 
 END SUBROUTINE FEAM_Input_ExtrapInterp


 SUBROUTINE FEAM_Output_ExtrapInterp(u, tin, u_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) input u_out at time t_out, from previous/future time
! values of u (which has values associated with times in t).  Order of the interpolation is given by the size of u
!
!  expressions below based on either
!
!  f(t) = a
!  f(t) = a + b * t, or
!  f(t) = a + b * t + c * t**2
!
!  where a, b and c are determined as the solution to
!  f(t1) = u1, f(t2) = u2, f(t3) = u3  (as appropriate)
!
!..................................................................................................................................

 TYPE(FEAM_outputtype), INTENT(INOUT)  :: u(:)      ! Inputs at t1 > t2 > t3
 REAL(DbKi),         INTENT(IN   )  :: tin(:)      ! Times associated with the inputs
 TYPE(FEAM_outputtype), INTENT(INOUT)  :: u_out     ! Inputs at t1 > t2 > t3
 REAL(DbKi),         INTENT(IN   )  :: tin_out     ! time to be extrap/interp'd to
 INTEGER(IntKi),     INTENT(  OUT)  :: ErrStat   ! Error status of the operation
 CHARACTER(*),       INTENT(  OUT)  :: ErrMsg    ! Error message if ErrStat /= ErrID_None
   ! local variables
 REAL(DbKi) :: t(SIZE(tin))    ! Times associated with the inputs
 REAL(DbKi) :: t_out           ! Time to which to be extrap/interpd
 TYPE(MeshType) :: tmpmesh
 INTEGER(IntKi)                 :: order    ! order of polynomial fit (max 2)
 REAL(ReKi),ALLOCATABLE,DIMENSION(:)        :: mr1       ! temporary for extrapolaton/interpolation
 REAL(ReKi),ALLOCATABLE,DIMENSION(:)        :: mr2       ! temporary for extrapolation/interpolation
 REAL(ReKi),ALLOCATABLE,DIMENSION(:)        :: mr3       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:)        :: md1       ! temporary for extrapolaton/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:)        :: md2       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:)        :: md3       ! temporary for extrapolation/interpolation
 INTEGER(IntKi),ALLOCATABLE,DIMENSION(:)    :: mi1       ! temporary for extrapolaton/interpolation
 INTEGER(IntKi),ALLOCATABLE,DIMENSION(:)    :: mi2       ! temporary for extrapolation/interpolation
 INTEGER(IntKi),ALLOCATABLE,DIMENSION(:)    :: mi3       ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: a0       ! temporary for extrapolaton/interpolation
 REAL(DbKi)                                 :: b0       ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: c0       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:)        :: b1       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:)        :: c1       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:)      :: b2       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:)      :: c2       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:)    :: b3       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:)    :: c3       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:,:)  :: b4       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:,:)  :: c4       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:,:,:):: b5       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:,:,:):: c5       ! temporary for extrapolation/interpolation
 INTEGER                                    :: i01    ! dim1 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i11    ! dim1 level 1 counter variable for arrays of ddts
 INTEGER                                    :: i21    ! dim1 level 2 counter variable for arrays of ddts
 INTEGER                                    :: i31    ! dim1 level 3 counter variable for arrays of ddts
 INTEGER                                    :: i41    ! dim1 level 4 counter variable for arrays of ddts
 INTEGER                                    :: i51    ! dim1 level 5 counter variable for arrays of ddts
 INTEGER                                    :: i61    ! dim1 level 6 counter variable for arrays of ddts
 INTEGER                                    :: i71    ! dim1 level 7 counter variable for arrays of ddts
 INTEGER                                    :: i81    ! dim1 level 8 counter variable for arrays of ddts
 INTEGER                                    :: i91    ! dim1 level 9 counter variable for arrays of ddts
 INTEGER                                    :: i02    ! dim2 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i12    ! dim2 level 1 counter variable for arrays of ddts
 INTEGER                                    :: i22    ! dim2 level 2 counter variable for arrays of ddts
 INTEGER                                    :: i32    ! dim2 level 3 counter variable for arrays of ddts
 INTEGER                                    :: i42    ! dim2 level 4 counter variable for arrays of ddts
 INTEGER                                    :: i52    ! dim2 level 5 counter variable for arrays of ddts
 INTEGER                                    :: i62    ! dim2 level 6 counter variable for arrays of ddts
 INTEGER                                    :: i72    ! dim2 level 7 counter variable for arrays of ddts
 INTEGER                                    :: i82    ! dim2 level 8 counter variable for arrays of ddts
 INTEGER                                    :: i92    ! dim2 level 9 counter variable for arrays of ddts
 INTEGER                                    :: i03    ! dim3 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i13    ! dim3 level 1 counter variable for arrays of ddts
 INTEGER                                    :: i23    ! dim3 level 2 counter variable for arrays of ddts
 INTEGER                                    :: i33    ! dim3 level 3 counter variable for arrays of ddts
 INTEGER                                    :: i43    ! dim3 level 4 counter variable for arrays of ddts
 INTEGER                                    :: i53    ! dim3 level 5 counter variable for arrays of ddts
 INTEGER                                    :: i63    ! dim3 level 6 counter variable for arrays of ddts
 INTEGER                                    :: i73    ! dim3 level 7 counter variable for arrays of ddts
 INTEGER                                    :: i83    ! dim3 level 8 counter variable for arrays of ddts
 INTEGER                                    :: i93    ! dim3 level 9 counter variable for arrays of ddts
 INTEGER                                    :: i04    ! dim4 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i14    ! dim4 level 1 counter variable for arrays of ddts
 INTEGER                                    :: i24    ! dim4 level 2 counter variable for arrays of ddts
 INTEGER                                    :: i34    ! dim4 level 3 counter variable for arrays of ddts
 INTEGER                                    :: i44    ! dim4 level 4 counter variable for arrays of ddts
 INTEGER                                    :: i54    ! dim4 level 5 counter variable for arrays of ddts
 INTEGER                                    :: i64    ! dim4 level 6 counter variable for arrays of ddts
 INTEGER                                    :: i74    ! dim4 level 7 counter variable for arrays of ddts
 INTEGER                                    :: i84    ! dim4 level 8 counter variable for arrays of ddts
 INTEGER                                    :: i94    ! dim4 level 9 counter variable for arrays of ddts
 INTEGER                                    :: i05    ! dim5 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i15    ! dim5 level 1 counter variable for arrays of ddts
 INTEGER                                    :: i25    ! dim5 level 2 counter variable for arrays of ddts
 INTEGER                                    :: i35    ! dim5 level 3 counter variable for arrays of ddts
 INTEGER                                    :: i45    ! dim5 level 4 counter variable for arrays of ddts
 INTEGER                                    :: i55    ! dim5 level 5 counter variable for arrays of ddts
 INTEGER                                    :: i65    ! dim5 level 6 counter variable for arrays of ddts
 INTEGER                                    :: i75    ! dim5 level 7 counter variable for arrays of ddts
 INTEGER                                    :: i85    ! dim5 level 8 counter variable for arrays of ddts
 INTEGER                                    :: i95    ! dim5 level 9 counter variable for arrays of ddts
    ! Initialize ErrStat
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
    ! we're subtract a constant from the times to resolve some 
    ! numerical issues when t gets large (and to simplify the equations)
 t = tin - tin(1)
 t_out = tin_out - tin(1)

 if ( size(t) .ne. size(u)) then
    ErrStat = ErrID_Fatal
    ErrMsg = ' Error in FEAM_Output_ExtrapInterp: size(t) must equal size(u) '
    RETURN
 endif
 if (size(u) .gt. 3) then
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in FEAM_Output_ExtrapInterp: size(u) must be less than 4 '
    RETURN
 endif
 order = SIZE(u) - 1
 IF ( order .eq. 0 ) THEN
  u_out%WriteOutput = u(1)%WriteOutput
  CALL MeshCopy(u(1)%PtFairleadLoad, u_out%PtFairleadLoad, MESH_UPDATECOPY, ErrStat, ErrMsg )
  CALL MeshCopy(u(1)%LineMeshPosition, u_out%LineMeshPosition, MESH_UPDATECOPY, ErrStat, ErrMsg )
 ELSE IF ( order .eq. 1 ) THEN
  IF ( EqualRealNos( t(1), t(2) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in FEAM_Output_ExtrapInterp: t(1) must not equal t(2) to avoid a division-by-zero error.'
    RETURN
  END IF
  ALLOCATE(b1(SIZE(u_out%WriteOutput,1)))
  ALLOCATE(c1(SIZE(u_out%WriteOutput,1)))
  b1 = -(u(1)%WriteOutput - u(2)%WriteOutput)/t(2)
  u_out%WriteOutput = u(1)%WriteOutput + b1 * t_out
  DEALLOCATE(b1)
  DEALLOCATE(c1)
  CALL MeshPack(u(1)%PtFairleadLoad, mr1, md1, mi1, ErrStat, ErrMsg )
  CALL MeshPack(u(2)%PtFairleadLoad, mr2, md2, mi2, ErrStat, ErrMsg )
  ALLOCATE(b1(SIZE(mr1)))
  b1 = -(mr1 - mr2)/t(2)
  mr1 = mr1 + b1 * t_out
  DEALLOCATE(b1)
  ALLOCATE(b1(SIZE(md1)))
  b1 = -(md1 - md2)/t(2)
  md1 = md1 + b1 * t_out
  DEALLOCATE(b1)
  CALL MeshUnPack(tmpmesh, mr1, md1, mi1, ErrStat, ErrMsg )
  CALL MeshCopy(tmpmesh, u_out%PtFairleadLoad, MESH_UPDATECOPY, ErrStat, ErrMsg )
  CALL MeshDestroy(tmpmesh, ErrStat, ErrMsg )
  DEALLOCATE(mr1,md1,mi1,mr2,md2,mi2)
  CALL MeshPack(u(1)%LineMeshPosition, mr1, md1, mi1, ErrStat, ErrMsg )
  CALL MeshPack(u(2)%LineMeshPosition, mr2, md2, mi2, ErrStat, ErrMsg )
  ALLOCATE(b1(SIZE(mr1)))
  b1 = -(mr1 - mr2)/t(2)
  mr1 = mr1 + b1 * t_out
  DEALLOCATE(b1)
  ALLOCATE(b1(SIZE(md1)))
  b1 = -(md1 - md2)/t(2)
  md1 = md1 + b1 * t_out
  DEALLOCATE(b1)
  CALL MeshUnPack(tmpmesh, mr1, md1, mi1, ErrStat, ErrMsg )
  CALL MeshCopy(tmpmesh, u_out%LineMeshPosition, MESH_UPDATECOPY, ErrStat, ErrMsg )
  CALL MeshDestroy(tmpmesh, ErrStat, ErrMsg )
  DEALLOCATE(mr1,md1,mi1,mr2,md2,mi2)
 ELSE IF ( order .eq. 2 ) THEN
  IF ( EqualRealNos( t(1), t(2) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in FEAM_Output_ExtrapInterp: t(1) must not equal t(2) to avoid a division-by-zero error.'
    RETURN
  END IF
  IF ( EqualRealNos( t(2), t(3) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in FEAM_Output_ExtrapInterp: t(2) must not equal t(3) to avoid a division-by-zero error.'
    RETURN
  END IF
  IF ( EqualRealNos( t(1), t(3) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in FEAM_Output_ExtrapInterp: t(1) must not equal t(3) to avoid a division-by-zero error.'
    RETURN
  END IF
  ALLOCATE(b1(SIZE(u_out%WriteOutput,1)))
  ALLOCATE(c1(SIZE(u_out%WriteOutput,1)))
  b1 = (t(3)**2*(u(1)%WriteOutput - u(2)%WriteOutput) + t(2)**2*(-u(1)%WriteOutput + u(3)%WriteOutput))/(t(2)*t(3)*(t(2) - t(3)))
  c1 = ( (t(2)-t(3))*u(1)%WriteOutput + t(3)*u(2)%WriteOutput - t(2)*u(3)%WriteOutput ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%WriteOutput = u(1)%WriteOutput + b1 * t_out + c1 * t_out**2
  DEALLOCATE(b1)
  DEALLOCATE(c1)
  CALL MeshPack(u(1)%PtFairleadLoad, mr1, md1, mi1, ErrStat, ErrMsg )
  CALL MeshPack(u(2)%PtFairleadLoad, mr2, md2, mi2, ErrStat, ErrMsg )
  CALL MeshPack(u(3)%PtFairleadLoad, mr3, md3, mi3, ErrStat, ErrMsg )
  ALLOCATE(b1(SIZE(mr1)))
  ALLOCATE(c1(SIZE(mr1)))
  b1 = (t(3)**2*(mr1 - mr2) + t(2)**2*(-mr1 + mr3))/(t(2)*t(3)*(t(2) - t(3)))
  c1 = ( (t(2)-t(3))*mr1 + t(3)*mr2 - t(2)*mr3 ) / (t(2)*t(3)*(t(2) - t(3)))
  mr1 = mr1 + b1 * t_out + c1 * t_out**2
  DEALLOCATE(b1)
  DEALLOCATE(c1)
  ALLOCATE(b1(SIZE(md1)))
  ALLOCATE(c1(SIZE(md1)))
  b1 = (t(3)**2*(md1 - md2) + t(2)**2*(-md1 + md3))/(t(2)*t(3)*(t(2) - t(3)))
  c1 = ( (t(2)-t(3))*md1 + t(3)*md2 - t(2)*md3 ) / (t(2)*t(3)*(t(2) - t(3)))
  md1 = md1 + b1 * t_out + c1 * t_out**2
  DEALLOCATE(b1)
  DEALLOCATE(c1)
  CALL MeshUnPack(tmpmesh, mr1, md1, mi1, ErrStat, ErrMsg )
  CALL MeshCopy(tmpmesh, u_out%PtFairleadLoad, MESH_UPDATECOPY, ErrStat, ErrMsg )
  CALL MeshDestroy(tmpmesh, ErrStat, ErrMsg )
  DEALLOCATE(mr1,md1,mi1,mr2,md2,mi2,mr3,md3,mi3)
  CALL MeshPack(u(1)%LineMeshPosition, mr1, md1, mi1, ErrStat, ErrMsg )
  CALL MeshPack(u(2)%LineMeshPosition, mr2, md2, mi2, ErrStat, ErrMsg )
  CALL MeshPack(u(3)%LineMeshPosition, mr3, md3, mi3, ErrStat, ErrMsg )
  ALLOCATE(b1(SIZE(mr1)))
  ALLOCATE(c1(SIZE(mr1)))
  b1 = (t(3)**2*(mr1 - mr2) + t(2)**2*(-mr1 + mr3))/(t(2)*t(3)*(t(2) - t(3)))
  c1 = ( (t(2)-t(3))*mr1 + t(3)*mr2 - t(2)*mr3 ) / (t(2)*t(3)*(t(2) - t(3)))
  mr1 = mr1 + b1 * t_out + c1 * t_out**2
  DEALLOCATE(b1)
  DEALLOCATE(c1)
  ALLOCATE(b1(SIZE(md1)))
  ALLOCATE(c1(SIZE(md1)))
  b1 = (t(3)**2*(md1 - md2) + t(2)**2*(-md1 + md3))/(t(2)*t(3)*(t(2) - t(3)))
  c1 = ( (t(2)-t(3))*md1 + t(3)*md2 - t(2)*md3 ) / (t(2)*t(3)*(t(2) - t(3)))
  md1 = md1 + b1 * t_out + c1 * t_out**2
  DEALLOCATE(b1)
  DEALLOCATE(c1)
  CALL MeshUnPack(tmpmesh, mr1, md1, mi1, ErrStat, ErrMsg )
  CALL MeshCopy(tmpmesh, u_out%LineMeshPosition, MESH_UPDATECOPY, ErrStat, ErrMsg )
  CALL MeshDestroy(tmpmesh, ErrStat, ErrMsg )
  DEALLOCATE(mr1,md1,mi1,mr2,md2,mi2,mr3,md3,mi3)
 ELSE 
   ErrStat = ErrID_Fatal
   ErrMsg = ' order must be less than 3 in FEAM_Output_ExtrapInterp '
   RETURN
 ENDIF 
 END SUBROUTINE FEAM_Output_ExtrapInterp

END MODULE FEAMooring_Types
!ENDOFREGISTRYGENERATEDFILE
