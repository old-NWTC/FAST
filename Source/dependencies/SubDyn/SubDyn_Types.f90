!STARTOFREGISTRYGENERATEDFILE './SubDyn_Types.f90'
!
! WARNING This file is generated automatically by the FAST registry
! Do not edit.  Your changes to this file will be lost.
!
! FAST Registry (v2.04.01, 20-Nov-2014)
!*********************************************************************************************************************************
! SubDyn_Types
!.................................................................................................................................
! This file is part of SubDyn.
!
! Copyright (C) 2012-2014 National Renewable Energy Laboratory
!
! Licensed under the Apache License, Version 2.0 (the "License");
! you may not use this file except in compliance with the License.
! You may obtain a copy of the License at
!
!     http://www.apache.org/licenses/LICENSE-2.0
!
! Unless required by applicable law or agreed to in writing, software
! distributed under the License is distributed on an "AS IS" BASIS,
! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
! See the License for the specific language governing permissions and
! limitations under the License.
!
!
! W A R N I N G : This file was automatically generated from the FAST registry.  Changes made to this file may be lost.
!
!*********************************************************************************************************************************
MODULE SubDyn_Types
! This module contains all of the user-defined types needed in SubDyn. It also contains copy, destroy, pack, and
! unpack routines associated with each defined data type. This code will be generated by the FAST Registry.
!---------------------------------------------------------------------------------------------------------------------------------
USE NWTC_Library
IMPLICIT NONE
! =========  SD_InitInputType  =======
  TYPE, PUBLIC :: SD_InitInputType
    CHARACTER(1024)  :: SDInputFile      ! Name of the input file [-]
    CHARACTER(1024)  :: RootName      ! SubDyn rootname [-]
    REAL(ReKi)  :: g      ! Gravity acceleration [-]
    REAL(ReKi)  :: WtrDpth      ! Water Depth (positive valued) [-]
    REAL(ReKi) , DIMENSION(1:3)  :: TP_RefPoint      ! global position of transition piece reference point (could also be defined in SubDyn itself) [-]
    REAL(ReKi)  :: SubRotateZ      ! Rotation angle in degrees about global Z [-]
  END TYPE SD_InitInputType
! =======================
! =========  SD_InitOutputType  =======
  TYPE, PUBLIC :: SD_InitOutputType
    CHARACTER(10) , DIMENSION(:), ALLOCATABLE  :: WriteOutputHdr      ! Names of the output-to-file channels [-]
    CHARACTER(10) , DIMENSION(:), ALLOCATABLE  :: WriteOutputUnt      ! Units of the output-to-file channels [-]
    TYPE(ProgDesc)  :: Ver      ! This module's name, version, and date [-]
  END TYPE SD_InitOutputType
! =======================
! =========  MeshAuxDataType  =======
  TYPE, PUBLIC :: MeshAuxDataType
    INTEGER(IntKi)  :: MemberID      ! Member ID for Output [-]
    INTEGER(IntKi)  :: NOutCnt      ! Number of Nodes for the output member [-]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: NodeCnt      ! Node ordinal numbers for the output member [-]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: NodeIDs      ! Node IDs associated with ordinal numbers for the output member [-]
    INTEGER(IntKi) , DIMENSION(:,:), ALLOCATABLE  :: ElmIDs      ! Element IDs connected to each NodeIDs; max 10 elements [-]
    INTEGER(IntKi) , DIMENSION(:,:), ALLOCATABLE  :: ElmNds      ! Flag to indicate 1st or 2nd node of element for each ElmIDs [-]
    INTEGER(IntKi) , DIMENSION(1:2)  :: ElmID2s      ! Element IDs connected to each joint node [-]
    INTEGER(IntKi) , DIMENSION(1:2)  :: ElmNd2s      ! Flag [to]
    REAL(ReKi) , DIMENSION(:,:,:,:), ALLOCATABLE  :: Me      ! Mass matrix connected to each joint element for outAll output [-]
    REAL(ReKi) , DIMENSION(:,:,:,:), ALLOCATABLE  :: Ke      ! Mass matrix connected to each joint element for outAll output [-]
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: Fg      ! Gravity load vector connected to each joint element for requested member output [-]
    REAL(ReKi) , DIMENSION(1:12,1:12,1:2)  :: Me2      ! Mass matrix connected to each joint element for outAll output [-]
    REAL(ReKi) , DIMENSION(1:12,1:12,1:2)  :: Ke2      ! Mass matrix connected to each joint element for outAll output [-]
    REAL(ReKi) , DIMENSION(1:12,1:2)  :: Fg2      ! Gravity load vector connected to each joint element for outAll output [-]
  END TYPE MeshAuxDataType
! =======================
! =========  CB_MatArrays  =======
  TYPE, PUBLIC :: CB_MatArrays
    INTEGER(IntKi)  :: DOFM      ! retained degrees of freedom (modes) [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: TI2      ! TI2 matrix to refer to total mass to (0,0,0) [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: MBB      ! FULL MBB ( no constraints applied) [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: MBM      ! FULL MBM ( no constraints applied) [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: KBB      ! FULL KBB ( no constraints applied) [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: PhiL      ! Retained CB modes, possibly allPhiL(DOFL,DOFL), or PhiL(DOFL,DOFM) [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: PhiR      ! FULL PhiR ( no constraints applied) [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: OmegaL      ! Eigenvalues of retained CB modes, possibly all (DOFL or DOFM) [-]
  END TYPE CB_MatArrays
! =======================
! =========  FEM_MatArrays  =======
  TYPE, PUBLIC :: FEM_MatArrays
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: Omega      ! Eigenvalues of full FEM model,  we calculate them all [-]
    INTEGER(IntKi)  :: NOmega      ! Number of full FEM Eigenvalues (for now TDOF-6*Nreact) [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: Modes      ! Eigenmodes of full FEM model,  we calculate them all [-]
  END TYPE FEM_MatArrays
! =======================
! =========  ElemPropType  =======
  TYPE, PUBLIC :: ElemPropType
    REAL(ReKi)  :: Area      ! Area of an element [-]
    REAL(ReKi)  :: Length      ! Length of an element [-]
    REAL(ReKi)  :: Ixx      ! Moment of inertia of an element [-]
    REAL(ReKi)  :: Iyy      ! Moment of inertia of an element [-]
    REAL(ReKi)  :: Jzz      ! Moment of inertia of an element [-]
    LOGICAL  :: Shear      ! Use timoshenko (true) E-B (false) [-]
    REAL(ReKi)  :: Kappa      ! Shear coefficient [-]
    REAL(ReKi)  :: YoungE      ! Young's modulus [-]
    REAL(ReKi)  :: ShearG      ! Shear modulus [-]
    REAL(ReKi)  :: Rho      ! Density [-]
    REAL(ReKi) , DIMENSION(1:3,1:3)  :: DirCos      ! Element direction cosine matrix [-]
  END TYPE ElemPropType
! =======================
! =========  SD_InitType  =======
  TYPE, PUBLIC :: SD_InitType
    CHARACTER(1024)  :: RootName      ! SubDyn rootname [-]
    REAL(ReKi) , DIMENSION(1:3)  :: TP_RefPoint      ! global position of transition piece reference point (could also be defined in SubDyn itself) [-]
    REAL(ReKi)  :: SubRotateZ      ! Rotation angle in degrees about global Z [-]
    REAL(ReKi)  :: g      ! Gravity acceleration [-]
    REAL(DbKi)  :: DT      ! Time step from Glue Code [seconds]
    INTEGER(IntKi)  :: NJoints      ! Number of joints of the sub structure [-]
    INTEGER(IntKi)  :: NPropSets      ! Number of property sets [-]
    INTEGER(IntKi)  :: NXPropSets      ! Number of extended property sets [-]
    INTEGER(IntKi)  :: NInterf      ! Number of joints attached to transition piece [-]
    INTEGER(IntKi)  :: NCMass      ! Number of joints with concentrated mass [-]
    INTEGER(IntKi)  :: NCOSMs      ! Number of independent cosine matrices [-]
    INTEGER(IntKi)  :: FEMMod      ! FEM switch: element model in the FEM [-]
    INTEGER(IntKi)  :: NDiv      ! Number of divisions for each member [-]
    LOGICAL  :: CBMod      ! Perform C-B flag [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: Joints      ! Joints number and coordinate values [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: PropSets      ! Property sets number and values [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: XPropSets      ! Extended property sets [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: COSMs      ! Independent direction cosine matrices [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: CMass      ! Concentrated mass information [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: JDampings      ! Damping coefficients for internal modes [-]
    INTEGER(IntKi) , DIMENSION(:,:), ALLOCATABLE  :: Members      ! Member joints connection [-]
    INTEGER(IntKi) , DIMENSION(:,:), ALLOCATABLE  :: Interf      ! Interface degree of freedoms [-]
    CHARACTER(10) , DIMENSION(:), ALLOCATABLE  :: SSOutList      ! List of Output Channels [-]
    LOGICAL  :: OutCOSM      ! Output Cos-matrices Flag [-]
    LOGICAL  :: TabDelim      ! Generate a tab-delimited output file in OutJckF-Flag [-]
    INTEGER(IntKi)  :: NNode      ! Total number of nodes [-]
    INTEGER(IntKi)  :: NElem      ! Total number of elements [-]
    INTEGER(IntKi)  :: NProp      ! Total number of property sets [-]
    INTEGER(IntKi)  :: TDOF      ! Total degree of freedom [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: Nodes      ! Nodes number and coordinates [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: Props      ! Property sets and values [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: K      ! System stiffness matrix [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: M      ! System mass matrix [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: F      ! System force vector [N]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: FG      ! Gravity force vector [N]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: ElemProps      ! Element properties(A, L, Ixx, Iyy, Jzz, Shear, Kappa, E, G, Rho, DirCos(1,1), DirCos(2, 1), ....., DirCos(3, 3) ) [-]
    INTEGER(IntKi) , DIMENSION(:,:), ALLOCATABLE  :: BCs      ! Boundary constraint degree of freedoms. First column - DOFs(rows in the system matrices), Second column - constrained(1) or not(0) [-]
    INTEGER(IntKi) , DIMENSION(:,:), ALLOCATABLE  :: IntFc      ! Interface constraint degree of freedoms [-]
    INTEGER(IntKi) , DIMENSION(:,:), ALLOCATABLE  :: MemberNodes      ! Member number and nodes in the member [-]
    INTEGER(IntKi) , DIMENSION(:,:), ALLOCATABLE  :: NodesConnN      ! Nodes that connect to a common node [-]
    INTEGER(IntKi) , DIMENSION(:,:), ALLOCATABLE  :: NodesConnE      ! Elements that connect to a common node [-]
    LOGICAL  :: SSSum      ! SubDyn Summary File Flag [-]
  END TYPE SD_InitType
! =======================
! =========  SD_ContinuousStateType  =======
  TYPE, PUBLIC :: SD_ContinuousStateType
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: qm      ! Virtual states, Nmod elements [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: qmdot      ! Derivative of states, Nmod elements [-]
  END TYPE SD_ContinuousStateType
! =======================
! =========  SD_DiscreteStateType  =======
  TYPE, PUBLIC :: SD_DiscreteStateType
    REAL(ReKi)  :: DummyDiscState      ! Remove this variable if you have discrete states [-]
  END TYPE SD_DiscreteStateType
! =======================
! =========  SD_ConstraintStateType  =======
  TYPE, PUBLIC :: SD_ConstraintStateType
    REAL(ReKi)  :: DummyConstrState      ! Remove this variable if you have constraint states [-]
  END TYPE SD_ConstraintStateType
! =======================
! =========  SD_OtherStateType  =======
  TYPE, PUBLIC :: SD_OtherStateType
    TYPE(SD_ContinuousStateType) , DIMENSION(:), ALLOCATABLE  :: xdot      ! previous state derivs for m-step time integrator [-]
    INTEGER(IntKi)  :: n      ! tracks time step for which OtherState was updated last [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: SDWrOutput      ! Data from previous step to be written to a SubDyn output file [-]
    REAL(DbKi)  :: LastOutTime      ! The time of the most recent stored output data [s]
    INTEGER(IntKi)  :: Decimat      ! Current output decimation counter [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: qmdotdot      ! 2nd Derivative of states, used only for output-file purposes [-]
    REAL(ReKi) , DIMENSION(1:6)  :: u_TP 
    REAL(ReKi) , DIMENSION(1:6)  :: udot_TP 
    REAL(ReKi) , DIMENSION(1:6)  :: udotdot_TP 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: UFL 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: UR_bar 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: UR_bar_dot 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: UR_bar_dotdot 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: UL 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: UL_dot 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: UL_dotdot 
  END TYPE SD_OtherStateType
! =======================
! =========  SD_ParameterType  =======
  TYPE, PUBLIC :: SD_ParameterType
    REAL(DbKi)  :: SDDeltaT      ! Time step (for integration of continuous states) [seconds]
    LOGICAL  :: SttcSolve      ! Solve dynamics about static equilibrium point (flag) [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: NOmegaM2      ! Coefficient of x in X (negative omegaM squared) [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: N2OmegaMJDamp      ! Coefficient of x in X (negative 2 omegaM * JDamping) [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: MMB      ! Matrix after C-B reduction (transpose of MBM [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: PhiM_T      ! Coefficient of u in X (transpose of phiM) [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: FX      ! Load components in X [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: C1_11      ! Coefficient of x in Y1 [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: C1_12      ! Coefficient of x in Y1 [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: D1_13      ! Coefficient of u in Y1 [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: D1_14      ! Coefficient of u in Y1 [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: D1_15      ! Coefficient of u in Y1 [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: FY      ! Load Components in  Y1 [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: PhiM      ! Coefficient of x in Y2 [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: C2_61      ! Coefficient of x in Y2 (URdotdot ULdotdot) [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: C2_62      ! Coefficient of x in Y2 (URdotdot ULdotdot) [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: PhiRb_TI      ! Coefficient of u in Y2 (Phi_R bar * TI) [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: D2_63      ! Coefficient of u in Y2 (URdotdot ULdotdot) [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: D2_64      ! Coefficient of u in Y2 (URdotdot ULdotdot) [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: F2_61      ! Load Component in Y2 [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: MBB      ! Matrix after C-B reduction [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: KBB      ! Matrix after C-B reduction [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: MBM      ! Matrix after C-B reduction [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: PhiL_T      ! Transpose of Matrix of C-B  modes [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: PhiLInvOmgL2      ! Matrix of C-B  modes times the inverse of OmegaL**2 (Phi_L*(Omg**2)^-1) [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: FGL      ! Internal node DOFL, gravity loads [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: AM2Jac      ! Jacobian (factored) for Adams-Boulton 2nd order Integration [-]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: AM2JacPiv      ! Pivot array for Jacobian factorization (for Adams-Boulton 2nd order Integration) [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: TI      ! Matrix to calculate TP reference point reaction at top of structure [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: TIreact      ! Matrix to calculate single point reaction at base of structure [-]
    INTEGER(IntKi)  :: NModes      ! Number of modes to retain in C-B method [-]
    INTEGER(IntKi) , DIMENSION(:,:), ALLOCATABLE  :: Elems      ! Element nodes connections [-]
    INTEGER(IntKi)  :: qmL      ! Length of state array [-]
    INTEGER(IntKi)  :: DofL      ! Internal nodes   of DOFs [-]
    INTEGER(IntKi)  :: NNodes_I      ! Number of Interface nodes [-]
    INTEGER(IntKi)  :: NNodes_L      ! Number of Internal nodes [-]
    INTEGER(IntKi)  :: NNodes_RbarL      ! Number of Interface + Internal nodes [-]
    INTEGER(IntKi)  :: DofI      ! Interface nodes   of DOFs [-]
    INTEGER(IntKi)  :: DofR      ! Interface and restrained nodes   of DOFs [-]
    INTEGER(IntKi)  :: DofC      ! Contrained nodes   of DOFs [-]
    INTEGER(IntKi)  :: NReact      ! Number of joints with reactions [-]
    INTEGER(IntKi) , DIMENSION(:,:), ALLOCATABLE  :: Reacts      ! React degree of freedoms [-]
    INTEGER(IntKi)  :: Nmembers      ! Number of members of the sub structure [-]
    INTEGER(IntKi)  :: URbarL      ! Length of URbar, subarray of y2 array (DOFRb) [-]
    INTEGER(IntKi)  :: IntMethod      ! INtegration Method (1/2/3)Length of y2 array [-]
    INTEGER(IntKi)  :: NAvgEls = 2      ! Max number of elements that should be averaged when calculating outputs at nodes [-]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: IDI      ! Index array of the interface(nodes connect to TP) dofs [-]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: IDR      ! Index array of the interface and restraint dofs [-]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: IDL      ! Index array of the internal dofs [-]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: IDC      ! Index array of the contraint dofs [-]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: IDY      ! Index array of the all dofs in Y2 [-]
    INTEGER(IntKi)  :: NMOutputs      ! Number of members whose output is written [-]
    INTEGER(IntKi)  :: NumOuts      ! Number of output channels read from input file [-]
    INTEGER(IntKi)  :: OutSwtch      ! Output Requested Channels to local or global output file [1/2/3] [-]
    INTEGER(IntKi)  :: UnJckF      ! Unit of SD ouput file [-]
    CHARACTER(1)  :: Delim      ! Column delimiter for output text files [-]
    CHARACTER(20)  :: OutFmt      ! Format for Output [-]
    CHARACTER(20)  :: OutSFmt      ! Format for Output Headers [-]
    TYPE(MeshAuxDataType) , DIMENSION(:), ALLOCATABLE  :: MoutLst      ! List of user requested members and nodes [-]
    TYPE(MeshAuxDataType) , DIMENSION(:), ALLOCATABLE  :: MoutLst2      ! List of all member joint nodes and elements for output [-]
    TYPE(MeshAuxDataType) , DIMENSION(:), ALLOCATABLE  :: MoutLst3      ! List of all member joint nodes and elements for output [-]
    TYPE(ElemPropType) , DIMENSION(:), ALLOCATABLE  :: ElemProps      ! List of element properties [-]
    TYPE(OutParmType) , DIMENSION(:), ALLOCATABLE  :: OutParam      ! An array holding names, units, and indices of all of the selected output channels.   logical [-]
    LOGICAL  :: OutAll      ! Flag to output or not all joint forces [-]
    LOGICAL  :: OutReact      ! Flag to check whether reactions are requested [-]
    INTEGER(IntKi)  :: OutAllInt      ! Integer version of OutAll [-]
    INTEGER(IntKi)  :: OutAllDims      ! Integer version of OutAll [-]
    INTEGER(IntKi)  :: OutDec      ! Output Decimation for Requested Channels [-]
  END TYPE SD_ParameterType
! =======================
! =========  SD_InputType  =======
  TYPE, PUBLIC :: SD_InputType
    TYPE(MeshType)  :: TPMesh      ! Transition piece inputs on a point mesh [-]
    TYPE(MeshType)  :: LMesh      ! Point mesh for interior node inputs [-]
  END TYPE SD_InputType
! =======================
! =========  SD_OutputType  =======
  TYPE, PUBLIC :: SD_OutputType
    TYPE(MeshType)  :: Y1Mesh      ! Transition piece outputs on a point mesh [-]
    TYPE(MeshType)  :: Y2Mesh      ! Interior+Interface nodes outputs on a point mesh [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: WriteOutput      ! Data to be written to an output file [-]
  END TYPE SD_OutputType
! =======================
! =========  SD_PartialOutputPInputType  =======
  TYPE, PUBLIC :: SD_PartialOutputPInputType
    TYPE(SD_InputType)  :: DummyOutput      ! If you have output equations and input data, update this variable [-]
  END TYPE SD_PartialOutputPInputType
! =======================
! =========  SD_PartialContStatePInputType  =======
  TYPE, PUBLIC :: SD_PartialContStatePInputType
    TYPE(SD_InputType)  :: DummyContState      ! If you have continuous state equations and input data, update this variable [-]
  END TYPE SD_PartialContStatePInputType
! =======================
! =========  SD_PartialDiscStatePInputType  =======
  TYPE, PUBLIC :: SD_PartialDiscStatePInputType
    TYPE(SD_InputType)  :: DummyDiscState      ! If you have discrete state equations and input data, update this variable [-]
  END TYPE SD_PartialDiscStatePInputType
! =======================
! =========  SD_PartialConstrStatePInputType  =======
  TYPE, PUBLIC :: SD_PartialConstrStatePInputType
    TYPE(SD_InputType)  :: DummyConstrState      ! If you have constraint state equations and input data, update this variable [-]
  END TYPE SD_PartialConstrStatePInputType
! =======================
! =========  SD_PartialOutputPContStateType  =======
  TYPE, PUBLIC :: SD_PartialOutputPContStateType
    TYPE(SD_ContinuousStateType)  :: DummyOutput      ! If you have output equations and continuous states, update this variable [-]
  END TYPE SD_PartialOutputPContStateType
! =======================
! =========  SD_PartialContStatePContStateType  =======
  TYPE, PUBLIC :: SD_PartialContStatePContStateType
    TYPE(SD_ContinuousStateType)  :: DummyContState      ! If you have continuous state equations and continuous states, update this variable [-]
  END TYPE SD_PartialContStatePContStateType
! =======================
! =========  SD_PartialDiscStatePContStateType  =======
  TYPE, PUBLIC :: SD_PartialDiscStatePContStateType
    TYPE(SD_ContinuousStateType)  :: DummyDiscState      ! If you have discrete state equations and continuous states, update this variable [-]
  END TYPE SD_PartialDiscStatePContStateType
! =======================
! =========  SD_PartialConstrStatePContStateType  =======
  TYPE, PUBLIC :: SD_PartialConstrStatePContStateType
    TYPE(SD_ContinuousStateType)  :: DummyConstrState      ! If you have constraint state equations and continuous states, update this variable [-]
  END TYPE SD_PartialConstrStatePContStateType
! =======================
! =========  SD_PartialOutputPDiscStateType  =======
  TYPE, PUBLIC :: SD_PartialOutputPDiscStateType
    TYPE(SD_DiscreteStateType)  :: DummyOutput      ! If you have output equations and discrete states, update this variable [-]
  END TYPE SD_PartialOutputPDiscStateType
! =======================
! =========  SD_PartialContStatePDiscStateType  =======
  TYPE, PUBLIC :: SD_PartialContStatePDiscStateType
    TYPE(SD_DiscreteStateType)  :: DummyContState      ! If you have continuous state equations and discrete states, update this variable [-]
  END TYPE SD_PartialContStatePDiscStateType
! =======================
! =========  SD_PartialDiscStatePDiscStateType  =======
  TYPE, PUBLIC :: SD_PartialDiscStatePDiscStateType
    TYPE(SD_DiscreteStateType)  :: DummyDiscState      ! If you have discrete state equations and discrete states, update this variable [-]
  END TYPE SD_PartialDiscStatePDiscStateType
! =======================
! =========  SD_PartialConstrStatePDiscStateType  =======
  TYPE, PUBLIC :: SD_PartialConstrStatePDiscStateType
    TYPE(SD_DiscreteStateType)  :: DummyConstrState      ! If you have constraint state equations and discrete states, update this variable [-]
  END TYPE SD_PartialConstrStatePDiscStateType
! =======================
! =========  SD_PartialOutputPConstrStateType  =======
  TYPE, PUBLIC :: SD_PartialOutputPConstrStateType
    TYPE(SD_ConstraintStateType)  :: DummyOutput      ! If you have output equations and constraint states, update this variable [-]
  END TYPE SD_PartialOutputPConstrStateType
! =======================
! =========  SD_PartialContStatePConstrStateType  =======
  TYPE, PUBLIC :: SD_PartialContStatePConstrStateType
    TYPE(SD_ConstraintStateType)  :: DummyContState      ! If you have continuous state equations and constraint states, update this variable [-]
  END TYPE SD_PartialContStatePConstrStateType
! =======================
! =========  SD_PartialDiscStatePConstrStateType  =======
  TYPE, PUBLIC :: SD_PartialDiscStatePConstrStateType
    TYPE(SD_ConstraintStateType)  :: DummyDiscState      ! If you have discrete state equations and constraint states, update this variable [-]
  END TYPE SD_PartialDiscStatePConstrStateType
! =======================
! =========  SD_PartialConstrStatePConstrStateType  =======
  TYPE, PUBLIC :: SD_PartialConstrStatePConstrStateType
    TYPE(SD_ConstraintStateType)  :: DummyConstrState      ! If you have constraint state equations and constraint states, update this variable [-]
  END TYPE SD_PartialConstrStatePConstrStateType
! =======================
CONTAINS
 SUBROUTINE SD_CopyInitInput( SrcInitInputData, DstInitInputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(SD_initinputtype), INTENT(INOUT) :: SrcInitInputData
   TYPE(SD_initinputtype), INTENT(INOUT) :: DstInitInputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
   DstInitInputData%SDInputFile = SrcInitInputData%SDInputFile
   DstInitInputData%RootName = SrcInitInputData%RootName
   DstInitInputData%g = SrcInitInputData%g
   DstInitInputData%WtrDpth = SrcInitInputData%WtrDpth
   DstInitInputData%TP_RefPoint = SrcInitInputData%TP_RefPoint
   DstInitInputData%SubRotateZ = SrcInitInputData%SubRotateZ
 END SUBROUTINE SD_CopyInitInput

 SUBROUTINE SD_DestroyInitInput( InitInputData, ErrStat, ErrMsg )
  TYPE(SD_initinputtype), INTENT(INOUT) :: InitInputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
 END SUBROUTINE SD_DestroyInitInput

 SUBROUTINE SD_PackInitInput( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(SD_initinputtype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
!  missing buffer for SDInputFile
!  missing buffer for RootName
  Re_BufSz   = Re_BufSz   + 1  ! g
  Re_BufSz   = Re_BufSz   + 1  ! WtrDpth
  Re_BufSz    = Re_BufSz    + SIZE( InData%TP_RefPoint )  ! TP_RefPoint 
  Re_BufSz   = Re_BufSz   + 1  ! SubRotateZ
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%g )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%WtrDpth )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%TP_RefPoint))-1 ) =  PACK(InData%TP_RefPoint ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%TP_RefPoint)
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%SubRotateZ )
  Re_Xferred   = Re_Xferred   + 1
 END SUBROUTINE SD_PackInitInput

 SUBROUTINE SD_UnPackInitInput( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(SD_initinputtype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  OutData%g = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%WtrDpth = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  ALLOCATE(mask1(SIZE(OutData%TP_RefPoint,1))); mask1 = .TRUE.
  OutData%TP_RefPoint = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%TP_RefPoint))-1 ),mask1,OutData%TP_RefPoint)
  DEALLOCATE(mask1)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%TP_RefPoint)
  OutData%SubRotateZ = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE SD_UnPackInitInput

 SUBROUTINE SD_CopyInitOutput( SrcInitOutputData, DstInitOutputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(SD_initoutputtype), INTENT(INOUT) :: SrcInitOutputData
   TYPE(SD_initoutputtype), INTENT(INOUT) :: DstInitOutputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcInitOutputData%WriteOutputHdr)) THEN
   i1_l = LBOUND(SrcInitOutputData%WriteOutputHdr,1)
   i1_u = UBOUND(SrcInitOutputData%WriteOutputHdr,1)
   IF (.NOT. ALLOCATED(DstInitOutputData%WriteOutputHdr)) THEN 
      ALLOCATE(DstInitOutputData%WriteOutputHdr(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitOutputData%WriteOutputHdr.', ErrStat, ErrMsg,'SD_CopyInitOutput')
         RETURN
      END IF
   END IF
   DstInitOutputData%WriteOutputHdr = SrcInitOutputData%WriteOutputHdr
ENDIF
IF (ALLOCATED(SrcInitOutputData%WriteOutputUnt)) THEN
   i1_l = LBOUND(SrcInitOutputData%WriteOutputUnt,1)
   i1_u = UBOUND(SrcInitOutputData%WriteOutputUnt,1)
   IF (.NOT. ALLOCATED(DstInitOutputData%WriteOutputUnt)) THEN 
      ALLOCATE(DstInitOutputData%WriteOutputUnt(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitOutputData%WriteOutputUnt.', ErrStat, ErrMsg,'SD_CopyInitOutput')
         RETURN
      END IF
   END IF
   DstInitOutputData%WriteOutputUnt = SrcInitOutputData%WriteOutputUnt
ENDIF
      CALL NWTC_Library_Copyprogdesc( SrcInitOutputData%Ver, DstInitOutputData%Ver, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'SD_CopyInitOutput:Ver')
         IF (ErrStat>=AbortErrLev) RETURN
 END SUBROUTINE SD_CopyInitOutput

 SUBROUTINE SD_DestroyInitOutput( InitOutputData, ErrStat, ErrMsg )
  TYPE(SD_initoutputtype), INTENT(INOUT) :: InitOutputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(InitOutputData%WriteOutputHdr)) THEN
   DEALLOCATE(InitOutputData%WriteOutputHdr)
ENDIF
IF (ALLOCATED(InitOutputData%WriteOutputUnt)) THEN
   DEALLOCATE(InitOutputData%WriteOutputUnt)
ENDIF
  CALL NWTC_Library_Destroyprogdesc( InitOutputData%Ver, ErrStat, ErrMsg )
 END SUBROUTINE SD_DestroyInitOutput

 SUBROUTINE SD_PackInitOutput( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(SD_initoutputtype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_Ver_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_Ver_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_Ver_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
!  missing buffer for WriteOutputHdr
!  missing buffer for WriteOutputUnt
  CALL NWTC_Library_Packprogdesc( Re_Ver_Buf, Db_Ver_Buf, Int_Ver_Buf, InData%Ver, ErrStat, ErrMsg, .TRUE. ) ! Ver 
  IF(ALLOCATED(Re_Ver_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_Ver_Buf  ) ! Ver
  IF(ALLOCATED(Db_Ver_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_Ver_Buf  ) ! Ver
  IF(ALLOCATED(Int_Ver_Buf))Int_BufSz = Int_BufSz + SIZE( Int_Ver_Buf ) ! Ver
  IF(ALLOCATED(Re_Ver_Buf))  DEALLOCATE(Re_Ver_Buf)
  IF(ALLOCATED(Db_Ver_Buf))  DEALLOCATE(Db_Ver_Buf)
  IF(ALLOCATED(Int_Ver_Buf)) DEALLOCATE(Int_Ver_Buf)
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  CALL NWTC_Library_Packprogdesc( Re_Ver_Buf, Db_Ver_Buf, Int_Ver_Buf, InData%Ver, ErrStat, ErrMsg, OnlySize ) ! Ver 
  IF(ALLOCATED(Re_Ver_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Ver_Buf)-1 ) = Re_Ver_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_Ver_Buf)
  ENDIF
  IF(ALLOCATED(Db_Ver_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Ver_Buf)-1 ) = Db_Ver_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_Ver_Buf)
  ENDIF
  IF(ALLOCATED(Int_Ver_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Ver_Buf)-1 ) = Int_Ver_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_Ver_Buf)
  ENDIF
  IF( ALLOCATED(Re_Ver_Buf) )  DEALLOCATE(Re_Ver_Buf)
  IF( ALLOCATED(Db_Ver_Buf) )  DEALLOCATE(Db_Ver_Buf)
  IF( ALLOCATED(Int_Ver_Buf) ) DEALLOCATE(Int_Ver_Buf)
 END SUBROUTINE SD_PackInitOutput

 SUBROUTINE SD_UnPackInitOutput( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(SD_initoutputtype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_Ver_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_Ver_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_Ver_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
 ! first call NWTC_Library_Packprogdesc to get correctly sized buffers for unpacking
  CALL NWTC_Library_Packprogdesc( Re_Ver_Buf, Db_Ver_Buf, Int_Ver_Buf, OutData%Ver, ErrStat, ErrMsg, .TRUE. ) ! Ver 
  IF(ALLOCATED(Re_Ver_Buf)) THEN
    Re_Ver_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Ver_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_Ver_Buf)
  ENDIF
  IF(ALLOCATED(Db_Ver_Buf)) THEN
    Db_Ver_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Ver_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_Ver_Buf)
  ENDIF
  IF(ALLOCATED(Int_Ver_Buf)) THEN
    Int_Ver_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Ver_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_Ver_Buf)
  ENDIF
  CALL NWTC_Library_UnPackprogdesc( Re_Ver_Buf, Db_Ver_Buf, Int_Ver_Buf, OutData%Ver, ErrStat, ErrMsg ) ! Ver 
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE SD_UnPackInitOutput

 SUBROUTINE SD_Copymeshauxdatatype( SrcmeshauxdatatypeData, DstmeshauxdatatypeData, CtrlCode, ErrStat, ErrMsg )
   TYPE(meshauxdatatype), INTENT(INOUT) :: SrcmeshauxdatatypeData
   TYPE(meshauxdatatype), INTENT(INOUT) :: DstmeshauxdatatypeData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
   DstmeshauxdatatypeData%MemberID = SrcmeshauxdatatypeData%MemberID
   DstmeshauxdatatypeData%NOutCnt = SrcmeshauxdatatypeData%NOutCnt
IF (ALLOCATED(SrcmeshauxdatatypeData%NodeCnt)) THEN
   i1_l = LBOUND(SrcmeshauxdatatypeData%NodeCnt,1)
   i1_u = UBOUND(SrcmeshauxdatatypeData%NodeCnt,1)
   IF (.NOT. ALLOCATED(DstmeshauxdatatypeData%NodeCnt)) THEN 
      ALLOCATE(DstmeshauxdatatypeData%NodeCnt(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstmeshauxdatatypeData%NodeCnt.', ErrStat, ErrMsg,'SD_Copymeshauxdatatype')
         RETURN
      END IF
   END IF
   DstmeshauxdatatypeData%NodeCnt = SrcmeshauxdatatypeData%NodeCnt
ENDIF
IF (ALLOCATED(SrcmeshauxdatatypeData%NodeIDs)) THEN
   i1_l = LBOUND(SrcmeshauxdatatypeData%NodeIDs,1)
   i1_u = UBOUND(SrcmeshauxdatatypeData%NodeIDs,1)
   IF (.NOT. ALLOCATED(DstmeshauxdatatypeData%NodeIDs)) THEN 
      ALLOCATE(DstmeshauxdatatypeData%NodeIDs(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstmeshauxdatatypeData%NodeIDs.', ErrStat, ErrMsg,'SD_Copymeshauxdatatype')
         RETURN
      END IF
   END IF
   DstmeshauxdatatypeData%NodeIDs = SrcmeshauxdatatypeData%NodeIDs
ENDIF
IF (ALLOCATED(SrcmeshauxdatatypeData%ElmIDs)) THEN
   i1_l = LBOUND(SrcmeshauxdatatypeData%ElmIDs,1)
   i1_u = UBOUND(SrcmeshauxdatatypeData%ElmIDs,1)
   i2_l = LBOUND(SrcmeshauxdatatypeData%ElmIDs,2)
   i2_u = UBOUND(SrcmeshauxdatatypeData%ElmIDs,2)
   IF (.NOT. ALLOCATED(DstmeshauxdatatypeData%ElmIDs)) THEN 
      ALLOCATE(DstmeshauxdatatypeData%ElmIDs(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstmeshauxdatatypeData%ElmIDs.', ErrStat, ErrMsg,'SD_Copymeshauxdatatype')
         RETURN
      END IF
   END IF
   DstmeshauxdatatypeData%ElmIDs = SrcmeshauxdatatypeData%ElmIDs
ENDIF
IF (ALLOCATED(SrcmeshauxdatatypeData%ElmNds)) THEN
   i1_l = LBOUND(SrcmeshauxdatatypeData%ElmNds,1)
   i1_u = UBOUND(SrcmeshauxdatatypeData%ElmNds,1)
   i2_l = LBOUND(SrcmeshauxdatatypeData%ElmNds,2)
   i2_u = UBOUND(SrcmeshauxdatatypeData%ElmNds,2)
   IF (.NOT. ALLOCATED(DstmeshauxdatatypeData%ElmNds)) THEN 
      ALLOCATE(DstmeshauxdatatypeData%ElmNds(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstmeshauxdatatypeData%ElmNds.', ErrStat, ErrMsg,'SD_Copymeshauxdatatype')
         RETURN
      END IF
   END IF
   DstmeshauxdatatypeData%ElmNds = SrcmeshauxdatatypeData%ElmNds
ENDIF
   DstmeshauxdatatypeData%ElmID2s = SrcmeshauxdatatypeData%ElmID2s
   DstmeshauxdatatypeData%ElmNd2s = SrcmeshauxdatatypeData%ElmNd2s
IF (ALLOCATED(SrcmeshauxdatatypeData%Me)) THEN
   i1_l = LBOUND(SrcmeshauxdatatypeData%Me,1)
   i1_u = UBOUND(SrcmeshauxdatatypeData%Me,1)
   i2_l = LBOUND(SrcmeshauxdatatypeData%Me,2)
   i2_u = UBOUND(SrcmeshauxdatatypeData%Me,2)
   i3_l = LBOUND(SrcmeshauxdatatypeData%Me,3)
   i3_u = UBOUND(SrcmeshauxdatatypeData%Me,3)
   i4_l = LBOUND(SrcmeshauxdatatypeData%Me,4)
   i4_u = UBOUND(SrcmeshauxdatatypeData%Me,4)
   IF (.NOT. ALLOCATED(DstmeshauxdatatypeData%Me)) THEN 
      ALLOCATE(DstmeshauxdatatypeData%Me(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u,i4_l:i4_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstmeshauxdatatypeData%Me.', ErrStat, ErrMsg,'SD_Copymeshauxdatatype')
         RETURN
      END IF
   END IF
   DstmeshauxdatatypeData%Me = SrcmeshauxdatatypeData%Me
ENDIF
IF (ALLOCATED(SrcmeshauxdatatypeData%Ke)) THEN
   i1_l = LBOUND(SrcmeshauxdatatypeData%Ke,1)
   i1_u = UBOUND(SrcmeshauxdatatypeData%Ke,1)
   i2_l = LBOUND(SrcmeshauxdatatypeData%Ke,2)
   i2_u = UBOUND(SrcmeshauxdatatypeData%Ke,2)
   i3_l = LBOUND(SrcmeshauxdatatypeData%Ke,3)
   i3_u = UBOUND(SrcmeshauxdatatypeData%Ke,3)
   i4_l = LBOUND(SrcmeshauxdatatypeData%Ke,4)
   i4_u = UBOUND(SrcmeshauxdatatypeData%Ke,4)
   IF (.NOT. ALLOCATED(DstmeshauxdatatypeData%Ke)) THEN 
      ALLOCATE(DstmeshauxdatatypeData%Ke(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u,i4_l:i4_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstmeshauxdatatypeData%Ke.', ErrStat, ErrMsg,'SD_Copymeshauxdatatype')
         RETURN
      END IF
   END IF
   DstmeshauxdatatypeData%Ke = SrcmeshauxdatatypeData%Ke
ENDIF
IF (ALLOCATED(SrcmeshauxdatatypeData%Fg)) THEN
   i1_l = LBOUND(SrcmeshauxdatatypeData%Fg,1)
   i1_u = UBOUND(SrcmeshauxdatatypeData%Fg,1)
   i2_l = LBOUND(SrcmeshauxdatatypeData%Fg,2)
   i2_u = UBOUND(SrcmeshauxdatatypeData%Fg,2)
   i3_l = LBOUND(SrcmeshauxdatatypeData%Fg,3)
   i3_u = UBOUND(SrcmeshauxdatatypeData%Fg,3)
   IF (.NOT. ALLOCATED(DstmeshauxdatatypeData%Fg)) THEN 
      ALLOCATE(DstmeshauxdatatypeData%Fg(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstmeshauxdatatypeData%Fg.', ErrStat, ErrMsg,'SD_Copymeshauxdatatype')
         RETURN
      END IF
   END IF
   DstmeshauxdatatypeData%Fg = SrcmeshauxdatatypeData%Fg
ENDIF
   DstmeshauxdatatypeData%Me2 = SrcmeshauxdatatypeData%Me2
   DstmeshauxdatatypeData%Ke2 = SrcmeshauxdatatypeData%Ke2
   DstmeshauxdatatypeData%Fg2 = SrcmeshauxdatatypeData%Fg2
 END SUBROUTINE SD_Copymeshauxdatatype

 SUBROUTINE SD_Destroymeshauxdatatype( meshauxdatatypeData, ErrStat, ErrMsg )
  TYPE(meshauxdatatype), INTENT(INOUT) :: meshauxdatatypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(meshauxdatatypeData%NodeCnt)) THEN
   DEALLOCATE(meshauxdatatypeData%NodeCnt)
ENDIF
IF (ALLOCATED(meshauxdatatypeData%NodeIDs)) THEN
   DEALLOCATE(meshauxdatatypeData%NodeIDs)
ENDIF
IF (ALLOCATED(meshauxdatatypeData%ElmIDs)) THEN
   DEALLOCATE(meshauxdatatypeData%ElmIDs)
ENDIF
IF (ALLOCATED(meshauxdatatypeData%ElmNds)) THEN
   DEALLOCATE(meshauxdatatypeData%ElmNds)
ENDIF
IF (ALLOCATED(meshauxdatatypeData%Me)) THEN
   DEALLOCATE(meshauxdatatypeData%Me)
ENDIF
IF (ALLOCATED(meshauxdatatypeData%Ke)) THEN
   DEALLOCATE(meshauxdatatypeData%Ke)
ENDIF
IF (ALLOCATED(meshauxdatatypeData%Fg)) THEN
   DEALLOCATE(meshauxdatatypeData%Fg)
ENDIF
 END SUBROUTINE SD_Destroymeshauxdatatype

 SUBROUTINE SD_Packmeshauxdatatype( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(meshauxdatatype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Int_BufSz  = Int_BufSz  + 1  ! MemberID
  Int_BufSz  = Int_BufSz  + 1  ! NOutCnt
  IF ( ALLOCATED(InData%NodeCnt) )   Int_BufSz   = Int_BufSz   + SIZE( InData%NodeCnt )  ! NodeCnt 
  IF ( ALLOCATED(InData%NodeIDs) )   Int_BufSz   = Int_BufSz   + SIZE( InData%NodeIDs )  ! NodeIDs 
  IF ( ALLOCATED(InData%ElmIDs) )   Int_BufSz   = Int_BufSz   + SIZE( InData%ElmIDs )  ! ElmIDs 
  IF ( ALLOCATED(InData%ElmNds) )   Int_BufSz   = Int_BufSz   + SIZE( InData%ElmNds )  ! ElmNds 
  Int_BufSz   = Int_BufSz   + SIZE( InData%ElmID2s )  ! ElmID2s 
  Int_BufSz   = Int_BufSz   + SIZE( InData%ElmNd2s )  ! ElmNd2s 
  IF ( ALLOCATED(InData%Me) )   Re_BufSz    = Re_BufSz    + SIZE( InData%Me )  ! Me 
  IF ( ALLOCATED(InData%Ke) )   Re_BufSz    = Re_BufSz    + SIZE( InData%Ke )  ! Ke 
  IF ( ALLOCATED(InData%Fg) )   Re_BufSz    = Re_BufSz    + SIZE( InData%Fg )  ! Fg 
  Re_BufSz    = Re_BufSz    + SIZE( InData%Me2 )  ! Me2 
  Re_BufSz    = Re_BufSz    + SIZE( InData%Ke2 )  ! Ke2 
  Re_BufSz    = Re_BufSz    + SIZE( InData%Fg2 )  ! Fg2 
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%MemberID )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NOutCnt )
  Int_Xferred   = Int_Xferred   + 1
  IF ( ALLOCATED(InData%NodeCnt) ) THEN
    IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%NodeCnt))-1 ) = PACK(InData%NodeCnt ,.TRUE.)
    Int_Xferred   = Int_Xferred   + SIZE(InData%NodeCnt)
  ENDIF
  IF ( ALLOCATED(InData%NodeIDs) ) THEN
    IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%NodeIDs))-1 ) = PACK(InData%NodeIDs ,.TRUE.)
    Int_Xferred   = Int_Xferred   + SIZE(InData%NodeIDs)
  ENDIF
  IF ( ALLOCATED(InData%ElmIDs) ) THEN
    IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%ElmIDs))-1 ) = PACK(InData%ElmIDs ,.TRUE.)
    Int_Xferred   = Int_Xferred   + SIZE(InData%ElmIDs)
  ENDIF
  IF ( ALLOCATED(InData%ElmNds) ) THEN
    IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%ElmNds))-1 ) = PACK(InData%ElmNds ,.TRUE.)
    Int_Xferred   = Int_Xferred   + SIZE(InData%ElmNds)
  ENDIF
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%ElmID2s))-1 ) = PACK(InData%ElmID2s ,.TRUE.)
  Int_Xferred   = Int_Xferred   + SIZE(InData%ElmID2s)
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%ElmNd2s))-1 ) = PACK(InData%ElmNd2s ,.TRUE.)
  Int_Xferred   = Int_Xferred   + SIZE(InData%ElmNd2s)
  IF ( ALLOCATED(InData%Me) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Me))-1 ) =  PACK(InData%Me ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%Me)
  ENDIF
  IF ( ALLOCATED(InData%Ke) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Ke))-1 ) =  PACK(InData%Ke ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%Ke)
  ENDIF
  IF ( ALLOCATED(InData%Fg) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Fg))-1 ) =  PACK(InData%Fg ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%Fg)
  ENDIF
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Me2))-1 ) =  PACK(InData%Me2 ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%Me2)
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Ke2))-1 ) =  PACK(InData%Ke2 ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%Ke2)
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Fg2))-1 ) =  PACK(InData%Fg2 ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%Fg2)
 END SUBROUTINE SD_Packmeshauxdatatype

 SUBROUTINE SD_UnPackmeshauxdatatype( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(meshauxdatatype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  OutData%MemberID = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%NOutCnt = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  IF ( ALLOCATED(OutData%NodeCnt) ) THEN
  ALLOCATE(mask1(SIZE(OutData%NodeCnt,1))); mask1 = .TRUE.
    OutData%NodeCnt = UNPACK(IntKiBuf( Int_Xferred:Re_Xferred+(SIZE(OutData%NodeCnt))-1 ),mask1,OutData%NodeCnt)
  DEALLOCATE(mask1)
    Int_Xferred   = Int_Xferred   + SIZE(OutData%NodeCnt)
  ENDIF
  IF ( ALLOCATED(OutData%NodeIDs) ) THEN
  ALLOCATE(mask1(SIZE(OutData%NodeIDs,1))); mask1 = .TRUE.
    OutData%NodeIDs = UNPACK(IntKiBuf( Int_Xferred:Re_Xferred+(SIZE(OutData%NodeIDs))-1 ),mask1,OutData%NodeIDs)
  DEALLOCATE(mask1)
    Int_Xferred   = Int_Xferred   + SIZE(OutData%NodeIDs)
  ENDIF
  IF ( ALLOCATED(OutData%ElmIDs) ) THEN
  ALLOCATE(mask2(SIZE(OutData%ElmIDs,1),SIZE(OutData%ElmIDs,2))); mask2 = .TRUE.
    OutData%ElmIDs = UNPACK(IntKiBuf( Int_Xferred:Re_Xferred+(SIZE(OutData%ElmIDs))-1 ),mask2,OutData%ElmIDs)
  DEALLOCATE(mask2)
    Int_Xferred   = Int_Xferred   + SIZE(OutData%ElmIDs)
  ENDIF
  IF ( ALLOCATED(OutData%ElmNds) ) THEN
  ALLOCATE(mask2(SIZE(OutData%ElmNds,1),SIZE(OutData%ElmNds,2))); mask2 = .TRUE.
    OutData%ElmNds = UNPACK(IntKiBuf( Int_Xferred:Re_Xferred+(SIZE(OutData%ElmNds))-1 ),mask2,OutData%ElmNds)
  DEALLOCATE(mask2)
    Int_Xferred   = Int_Xferred   + SIZE(OutData%ElmNds)
  ENDIF
  ALLOCATE(mask1(SIZE(OutData%ElmID2s,1))); mask1 = .TRUE.
  OutData%ElmID2s = UNPACK(IntKiBuf( Int_Xferred:Re_Xferred+(SIZE(OutData%ElmID2s))-1 ),mask1,OutData%ElmID2s)
  DEALLOCATE(mask1)
  Int_Xferred   = Int_Xferred   + SIZE(OutData%ElmID2s)
  ALLOCATE(mask1(SIZE(OutData%ElmNd2s,1))); mask1 = .TRUE.
  OutData%ElmNd2s = UNPACK(IntKiBuf( Int_Xferred:Re_Xferred+(SIZE(OutData%ElmNd2s))-1 ),mask1,OutData%ElmNd2s)
  DEALLOCATE(mask1)
  Int_Xferred   = Int_Xferred   + SIZE(OutData%ElmNd2s)
  IF ( ALLOCATED(OutData%Me) ) THEN
  ALLOCATE(mask4(SIZE(OutData%Me,1),SIZE(OutData%Me,2),SIZE(OutData%Me,3),SIZE(OutData%Me,4))); mask4 = .TRUE.
    OutData%Me = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Me))-1 ),mask4,OutData%Me)
  DEALLOCATE(mask4)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%Me)
  ENDIF
  IF ( ALLOCATED(OutData%Ke) ) THEN
  ALLOCATE(mask4(SIZE(OutData%Ke,1),SIZE(OutData%Ke,2),SIZE(OutData%Ke,3),SIZE(OutData%Ke,4))); mask4 = .TRUE.
    OutData%Ke = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Ke))-1 ),mask4,OutData%Ke)
  DEALLOCATE(mask4)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%Ke)
  ENDIF
  IF ( ALLOCATED(OutData%Fg) ) THEN
  ALLOCATE(mask3(SIZE(OutData%Fg,1),SIZE(OutData%Fg,2),SIZE(OutData%Fg,3))); mask3 = .TRUE.
    OutData%Fg = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Fg))-1 ),mask3,OutData%Fg)
  DEALLOCATE(mask3)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%Fg)
  ENDIF
  ALLOCATE(mask3(SIZE(OutData%Me2,1),SIZE(OutData%Me2,2),SIZE(OutData%Me2,3))); mask3 = .TRUE.
  OutData%Me2 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Me2))-1 ),mask3,OutData%Me2)
  DEALLOCATE(mask3)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%Me2)
  ALLOCATE(mask3(SIZE(OutData%Ke2,1),SIZE(OutData%Ke2,2),SIZE(OutData%Ke2,3))); mask3 = .TRUE.
  OutData%Ke2 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Ke2))-1 ),mask3,OutData%Ke2)
  DEALLOCATE(mask3)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%Ke2)
  ALLOCATE(mask2(SIZE(OutData%Fg2,1),SIZE(OutData%Fg2,2))); mask2 = .TRUE.
  OutData%Fg2 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Fg2))-1 ),mask2,OutData%Fg2)
  DEALLOCATE(mask2)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%Fg2)
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE SD_UnPackmeshauxdatatype

 SUBROUTINE SD_Copycb_matarrays( Srccb_matarraysData, Dstcb_matarraysData, CtrlCode, ErrStat, ErrMsg )
   TYPE(cb_matarrays), INTENT(INOUT) :: Srccb_matarraysData
   TYPE(cb_matarrays), INTENT(INOUT) :: Dstcb_matarraysData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
   Dstcb_matarraysData%DOFM = Srccb_matarraysData%DOFM
IF (ALLOCATED(Srccb_matarraysData%TI2)) THEN
   i1_l = LBOUND(Srccb_matarraysData%TI2,1)
   i1_u = UBOUND(Srccb_matarraysData%TI2,1)
   i2_l = LBOUND(Srccb_matarraysData%TI2,2)
   i2_u = UBOUND(Srccb_matarraysData%TI2,2)
   IF (.NOT. ALLOCATED(Dstcb_matarraysData%TI2)) THEN 
      ALLOCATE(Dstcb_matarraysData%TI2(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating Dstcb_matarraysData%TI2.', ErrStat, ErrMsg,'SD_Copycb_matarrays')
         RETURN
      END IF
   END IF
   Dstcb_matarraysData%TI2 = Srccb_matarraysData%TI2
ENDIF
IF (ALLOCATED(Srccb_matarraysData%MBB)) THEN
   i1_l = LBOUND(Srccb_matarraysData%MBB,1)
   i1_u = UBOUND(Srccb_matarraysData%MBB,1)
   i2_l = LBOUND(Srccb_matarraysData%MBB,2)
   i2_u = UBOUND(Srccb_matarraysData%MBB,2)
   IF (.NOT. ALLOCATED(Dstcb_matarraysData%MBB)) THEN 
      ALLOCATE(Dstcb_matarraysData%MBB(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating Dstcb_matarraysData%MBB.', ErrStat, ErrMsg,'SD_Copycb_matarrays')
         RETURN
      END IF
   END IF
   Dstcb_matarraysData%MBB = Srccb_matarraysData%MBB
ENDIF
IF (ALLOCATED(Srccb_matarraysData%MBM)) THEN
   i1_l = LBOUND(Srccb_matarraysData%MBM,1)
   i1_u = UBOUND(Srccb_matarraysData%MBM,1)
   i2_l = LBOUND(Srccb_matarraysData%MBM,2)
   i2_u = UBOUND(Srccb_matarraysData%MBM,2)
   IF (.NOT. ALLOCATED(Dstcb_matarraysData%MBM)) THEN 
      ALLOCATE(Dstcb_matarraysData%MBM(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating Dstcb_matarraysData%MBM.', ErrStat, ErrMsg,'SD_Copycb_matarrays')
         RETURN
      END IF
   END IF
   Dstcb_matarraysData%MBM = Srccb_matarraysData%MBM
ENDIF
IF (ALLOCATED(Srccb_matarraysData%KBB)) THEN
   i1_l = LBOUND(Srccb_matarraysData%KBB,1)
   i1_u = UBOUND(Srccb_matarraysData%KBB,1)
   i2_l = LBOUND(Srccb_matarraysData%KBB,2)
   i2_u = UBOUND(Srccb_matarraysData%KBB,2)
   IF (.NOT. ALLOCATED(Dstcb_matarraysData%KBB)) THEN 
      ALLOCATE(Dstcb_matarraysData%KBB(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating Dstcb_matarraysData%KBB.', ErrStat, ErrMsg,'SD_Copycb_matarrays')
         RETURN
      END IF
   END IF
   Dstcb_matarraysData%KBB = Srccb_matarraysData%KBB
ENDIF
IF (ALLOCATED(Srccb_matarraysData%PhiL)) THEN
   i1_l = LBOUND(Srccb_matarraysData%PhiL,1)
   i1_u = UBOUND(Srccb_matarraysData%PhiL,1)
   i2_l = LBOUND(Srccb_matarraysData%PhiL,2)
   i2_u = UBOUND(Srccb_matarraysData%PhiL,2)
   IF (.NOT. ALLOCATED(Dstcb_matarraysData%PhiL)) THEN 
      ALLOCATE(Dstcb_matarraysData%PhiL(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating Dstcb_matarraysData%PhiL.', ErrStat, ErrMsg,'SD_Copycb_matarrays')
         RETURN
      END IF
   END IF
   Dstcb_matarraysData%PhiL = Srccb_matarraysData%PhiL
ENDIF
IF (ALLOCATED(Srccb_matarraysData%PhiR)) THEN
   i1_l = LBOUND(Srccb_matarraysData%PhiR,1)
   i1_u = UBOUND(Srccb_matarraysData%PhiR,1)
   i2_l = LBOUND(Srccb_matarraysData%PhiR,2)
   i2_u = UBOUND(Srccb_matarraysData%PhiR,2)
   IF (.NOT. ALLOCATED(Dstcb_matarraysData%PhiR)) THEN 
      ALLOCATE(Dstcb_matarraysData%PhiR(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating Dstcb_matarraysData%PhiR.', ErrStat, ErrMsg,'SD_Copycb_matarrays')
         RETURN
      END IF
   END IF
   Dstcb_matarraysData%PhiR = Srccb_matarraysData%PhiR
ENDIF
IF (ALLOCATED(Srccb_matarraysData%OmegaL)) THEN
   i1_l = LBOUND(Srccb_matarraysData%OmegaL,1)
   i1_u = UBOUND(Srccb_matarraysData%OmegaL,1)
   IF (.NOT. ALLOCATED(Dstcb_matarraysData%OmegaL)) THEN 
      ALLOCATE(Dstcb_matarraysData%OmegaL(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating Dstcb_matarraysData%OmegaL.', ErrStat, ErrMsg,'SD_Copycb_matarrays')
         RETURN
      END IF
   END IF
   Dstcb_matarraysData%OmegaL = Srccb_matarraysData%OmegaL
ENDIF
 END SUBROUTINE SD_Copycb_matarrays

 SUBROUTINE SD_Destroycb_matarrays( cb_matarraysData, ErrStat, ErrMsg )
  TYPE(cb_matarrays), INTENT(INOUT) :: cb_matarraysData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(cb_matarraysData%TI2)) THEN
   DEALLOCATE(cb_matarraysData%TI2)
ENDIF
IF (ALLOCATED(cb_matarraysData%MBB)) THEN
   DEALLOCATE(cb_matarraysData%MBB)
ENDIF
IF (ALLOCATED(cb_matarraysData%MBM)) THEN
   DEALLOCATE(cb_matarraysData%MBM)
ENDIF
IF (ALLOCATED(cb_matarraysData%KBB)) THEN
   DEALLOCATE(cb_matarraysData%KBB)
ENDIF
IF (ALLOCATED(cb_matarraysData%PhiL)) THEN
   DEALLOCATE(cb_matarraysData%PhiL)
ENDIF
IF (ALLOCATED(cb_matarraysData%PhiR)) THEN
   DEALLOCATE(cb_matarraysData%PhiR)
ENDIF
IF (ALLOCATED(cb_matarraysData%OmegaL)) THEN
   DEALLOCATE(cb_matarraysData%OmegaL)
ENDIF
 END SUBROUTINE SD_Destroycb_matarrays

 SUBROUTINE SD_Packcb_matarrays( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(cb_matarrays),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Int_BufSz  = Int_BufSz  + 1  ! DOFM
  IF ( ALLOCATED(InData%TI2) )   Re_BufSz    = Re_BufSz    + SIZE( InData%TI2 )  ! TI2 
  IF ( ALLOCATED(InData%MBB) )   Re_BufSz    = Re_BufSz    + SIZE( InData%MBB )  ! MBB 
  IF ( ALLOCATED(InData%MBM) )   Re_BufSz    = Re_BufSz    + SIZE( InData%MBM )  ! MBM 
  IF ( ALLOCATED(InData%KBB) )   Re_BufSz    = Re_BufSz    + SIZE( InData%KBB )  ! KBB 
  IF ( ALLOCATED(InData%PhiL) )   Re_BufSz    = Re_BufSz    + SIZE( InData%PhiL )  ! PhiL 
  IF ( ALLOCATED(InData%PhiR) )   Re_BufSz    = Re_BufSz    + SIZE( InData%PhiR )  ! PhiR 
  IF ( ALLOCATED(InData%OmegaL) )   Re_BufSz    = Re_BufSz    + SIZE( InData%OmegaL )  ! OmegaL 
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%DOFM )
  Int_Xferred   = Int_Xferred   + 1
  IF ( ALLOCATED(InData%TI2) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%TI2))-1 ) =  PACK(InData%TI2 ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%TI2)
  ENDIF
  IF ( ALLOCATED(InData%MBB) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%MBB))-1 ) =  PACK(InData%MBB ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%MBB)
  ENDIF
  IF ( ALLOCATED(InData%MBM) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%MBM))-1 ) =  PACK(InData%MBM ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%MBM)
  ENDIF
  IF ( ALLOCATED(InData%KBB) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%KBB))-1 ) =  PACK(InData%KBB ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%KBB)
  ENDIF
  IF ( ALLOCATED(InData%PhiL) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%PhiL))-1 ) =  PACK(InData%PhiL ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%PhiL)
  ENDIF
  IF ( ALLOCATED(InData%PhiR) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%PhiR))-1 ) =  PACK(InData%PhiR ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%PhiR)
  ENDIF
  IF ( ALLOCATED(InData%OmegaL) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%OmegaL))-1 ) =  PACK(InData%OmegaL ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%OmegaL)
  ENDIF
 END SUBROUTINE SD_Packcb_matarrays

 SUBROUTINE SD_UnPackcb_matarrays( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(cb_matarrays), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  OutData%DOFM = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  IF ( ALLOCATED(OutData%TI2) ) THEN
  ALLOCATE(mask2(SIZE(OutData%TI2,1),SIZE(OutData%TI2,2))); mask2 = .TRUE.
    OutData%TI2 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%TI2))-1 ),mask2,OutData%TI2)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%TI2)
  ENDIF
  IF ( ALLOCATED(OutData%MBB) ) THEN
  ALLOCATE(mask2(SIZE(OutData%MBB,1),SIZE(OutData%MBB,2))); mask2 = .TRUE.
    OutData%MBB = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%MBB))-1 ),mask2,OutData%MBB)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%MBB)
  ENDIF
  IF ( ALLOCATED(OutData%MBM) ) THEN
  ALLOCATE(mask2(SIZE(OutData%MBM,1),SIZE(OutData%MBM,2))); mask2 = .TRUE.
    OutData%MBM = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%MBM))-1 ),mask2,OutData%MBM)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%MBM)
  ENDIF
  IF ( ALLOCATED(OutData%KBB) ) THEN
  ALLOCATE(mask2(SIZE(OutData%KBB,1),SIZE(OutData%KBB,2))); mask2 = .TRUE.
    OutData%KBB = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%KBB))-1 ),mask2,OutData%KBB)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%KBB)
  ENDIF
  IF ( ALLOCATED(OutData%PhiL) ) THEN
  ALLOCATE(mask2(SIZE(OutData%PhiL,1),SIZE(OutData%PhiL,2))); mask2 = .TRUE.
    OutData%PhiL = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%PhiL))-1 ),mask2,OutData%PhiL)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%PhiL)
  ENDIF
  IF ( ALLOCATED(OutData%PhiR) ) THEN
  ALLOCATE(mask2(SIZE(OutData%PhiR,1),SIZE(OutData%PhiR,2))); mask2 = .TRUE.
    OutData%PhiR = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%PhiR))-1 ),mask2,OutData%PhiR)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%PhiR)
  ENDIF
  IF ( ALLOCATED(OutData%OmegaL) ) THEN
  ALLOCATE(mask1(SIZE(OutData%OmegaL,1))); mask1 = .TRUE.
    OutData%OmegaL = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%OmegaL))-1 ),mask1,OutData%OmegaL)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%OmegaL)
  ENDIF
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE SD_UnPackcb_matarrays

 SUBROUTINE SD_Copyfem_matarrays( Srcfem_matarraysData, Dstfem_matarraysData, CtrlCode, ErrStat, ErrMsg )
   TYPE(fem_matarrays), INTENT(INOUT) :: Srcfem_matarraysData
   TYPE(fem_matarrays), INTENT(INOUT) :: Dstfem_matarraysData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(Srcfem_matarraysData%Omega)) THEN
   i1_l = LBOUND(Srcfem_matarraysData%Omega,1)
   i1_u = UBOUND(Srcfem_matarraysData%Omega,1)
   IF (.NOT. ALLOCATED(Dstfem_matarraysData%Omega)) THEN 
      ALLOCATE(Dstfem_matarraysData%Omega(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating Dstfem_matarraysData%Omega.', ErrStat, ErrMsg,'SD_Copyfem_matarrays')
         RETURN
      END IF
   END IF
   Dstfem_matarraysData%Omega = Srcfem_matarraysData%Omega
ENDIF
   Dstfem_matarraysData%NOmega = Srcfem_matarraysData%NOmega
IF (ALLOCATED(Srcfem_matarraysData%Modes)) THEN
   i1_l = LBOUND(Srcfem_matarraysData%Modes,1)
   i1_u = UBOUND(Srcfem_matarraysData%Modes,1)
   i2_l = LBOUND(Srcfem_matarraysData%Modes,2)
   i2_u = UBOUND(Srcfem_matarraysData%Modes,2)
   IF (.NOT. ALLOCATED(Dstfem_matarraysData%Modes)) THEN 
      ALLOCATE(Dstfem_matarraysData%Modes(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating Dstfem_matarraysData%Modes.', ErrStat, ErrMsg,'SD_Copyfem_matarrays')
         RETURN
      END IF
   END IF
   Dstfem_matarraysData%Modes = Srcfem_matarraysData%Modes
ENDIF
 END SUBROUTINE SD_Copyfem_matarrays

 SUBROUTINE SD_Destroyfem_matarrays( fem_matarraysData, ErrStat, ErrMsg )
  TYPE(fem_matarrays), INTENT(INOUT) :: fem_matarraysData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(fem_matarraysData%Omega)) THEN
   DEALLOCATE(fem_matarraysData%Omega)
ENDIF
IF (ALLOCATED(fem_matarraysData%Modes)) THEN
   DEALLOCATE(fem_matarraysData%Modes)
ENDIF
 END SUBROUTINE SD_Destroyfem_matarrays

 SUBROUTINE SD_Packfem_matarrays( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(fem_matarrays),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  IF ( ALLOCATED(InData%Omega) )   Re_BufSz    = Re_BufSz    + SIZE( InData%Omega )  ! Omega 
  Int_BufSz  = Int_BufSz  + 1  ! NOmega
  IF ( ALLOCATED(InData%Modes) )   Re_BufSz    = Re_BufSz    + SIZE( InData%Modes )  ! Modes 
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( ALLOCATED(InData%Omega) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Omega))-1 ) =  PACK(InData%Omega ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%Omega)
  ENDIF
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NOmega )
  Int_Xferred   = Int_Xferred   + 1
  IF ( ALLOCATED(InData%Modes) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Modes))-1 ) =  PACK(InData%Modes ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%Modes)
  ENDIF
 END SUBROUTINE SD_Packfem_matarrays

 SUBROUTINE SD_UnPackfem_matarrays( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(fem_matarrays), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  IF ( ALLOCATED(OutData%Omega) ) THEN
  ALLOCATE(mask1(SIZE(OutData%Omega,1))); mask1 = .TRUE.
    OutData%Omega = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Omega))-1 ),mask1,OutData%Omega)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%Omega)
  ENDIF
  OutData%NOmega = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  IF ( ALLOCATED(OutData%Modes) ) THEN
  ALLOCATE(mask2(SIZE(OutData%Modes,1),SIZE(OutData%Modes,2))); mask2 = .TRUE.
    OutData%Modes = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Modes))-1 ),mask2,OutData%Modes)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%Modes)
  ENDIF
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE SD_UnPackfem_matarrays

 SUBROUTINE SD_Copyelemproptype( SrcelemproptypeData, DstelemproptypeData, CtrlCode, ErrStat, ErrMsg )
   TYPE(elemproptype), INTENT(INOUT) :: SrcelemproptypeData
   TYPE(elemproptype), INTENT(INOUT) :: DstelemproptypeData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
   DstelemproptypeData%Area = SrcelemproptypeData%Area
   DstelemproptypeData%Length = SrcelemproptypeData%Length
   DstelemproptypeData%Ixx = SrcelemproptypeData%Ixx
   DstelemproptypeData%Iyy = SrcelemproptypeData%Iyy
   DstelemproptypeData%Jzz = SrcelemproptypeData%Jzz
   DstelemproptypeData%Shear = SrcelemproptypeData%Shear
   DstelemproptypeData%Kappa = SrcelemproptypeData%Kappa
   DstelemproptypeData%YoungE = SrcelemproptypeData%YoungE
   DstelemproptypeData%ShearG = SrcelemproptypeData%ShearG
   DstelemproptypeData%Rho = SrcelemproptypeData%Rho
   DstelemproptypeData%DirCos = SrcelemproptypeData%DirCos
 END SUBROUTINE SD_Copyelemproptype

 SUBROUTINE SD_Destroyelemproptype( elemproptypeData, ErrStat, ErrMsg )
  TYPE(elemproptype), INTENT(INOUT) :: elemproptypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
 END SUBROUTINE SD_Destroyelemproptype

 SUBROUTINE SD_Packelemproptype( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(elemproptype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Re_BufSz   = Re_BufSz   + 1  ! Area
  Re_BufSz   = Re_BufSz   + 1  ! Length
  Re_BufSz   = Re_BufSz   + 1  ! Ixx
  Re_BufSz   = Re_BufSz   + 1  ! Iyy
  Re_BufSz   = Re_BufSz   + 1  ! Jzz
  Int_BufSz  = Int_BufSz  + 1  ! Shear
  Re_BufSz   = Re_BufSz   + 1  ! Kappa
  Re_BufSz   = Re_BufSz   + 1  ! YoungE
  Re_BufSz   = Re_BufSz   + 1  ! ShearG
  Re_BufSz   = Re_BufSz   + 1  ! Rho
  Re_BufSz    = Re_BufSz    + SIZE( InData%DirCos )  ! DirCos 
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%Area )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%Length )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%Ixx )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%Iyy )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%Jzz )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = TRANSFER( (InData%Shear ), IntKiBuf(1), 1)
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%Kappa )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%YoungE )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%ShearG )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%Rho )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%DirCos))-1 ) =  PACK(InData%DirCos ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%DirCos)
 END SUBROUTINE SD_Packelemproptype

 SUBROUTINE SD_UnPackelemproptype( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(elemproptype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  OutData%Area = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%Length = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%Ixx = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%Iyy = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%Jzz = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%Kappa = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%YoungE = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%ShearG = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%Rho = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  ALLOCATE(mask2(SIZE(OutData%DirCos,1),SIZE(OutData%DirCos,2))); mask2 = .TRUE.
  OutData%DirCos = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%DirCos))-1 ),mask2,OutData%DirCos)
  DEALLOCATE(mask2)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%DirCos)
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE SD_UnPackelemproptype

 SUBROUTINE SD_Copyinittype( SrcinittypeData, DstinittypeData, CtrlCode, ErrStat, ErrMsg )
   TYPE(sd_inittype), INTENT(INOUT) :: SrcinittypeData
   TYPE(sd_inittype), INTENT(INOUT) :: DstinittypeData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
   DstinittypeData%RootName = SrcinittypeData%RootName
   DstinittypeData%TP_RefPoint = SrcinittypeData%TP_RefPoint
   DstinittypeData%SubRotateZ = SrcinittypeData%SubRotateZ
   DstinittypeData%g = SrcinittypeData%g
   DstinittypeData%DT = SrcinittypeData%DT
   DstinittypeData%NJoints = SrcinittypeData%NJoints
   DstinittypeData%NPropSets = SrcinittypeData%NPropSets
   DstinittypeData%NXPropSets = SrcinittypeData%NXPropSets
   DstinittypeData%NInterf = SrcinittypeData%NInterf
   DstinittypeData%NCMass = SrcinittypeData%NCMass
   DstinittypeData%NCOSMs = SrcinittypeData%NCOSMs
   DstinittypeData%FEMMod = SrcinittypeData%FEMMod
   DstinittypeData%NDiv = SrcinittypeData%NDiv
   DstinittypeData%CBMod = SrcinittypeData%CBMod
IF (ALLOCATED(SrcinittypeData%Joints)) THEN
   i1_l = LBOUND(SrcinittypeData%Joints,1)
   i1_u = UBOUND(SrcinittypeData%Joints,1)
   i2_l = LBOUND(SrcinittypeData%Joints,2)
   i2_u = UBOUND(SrcinittypeData%Joints,2)
   IF (.NOT. ALLOCATED(DstinittypeData%Joints)) THEN 
      ALLOCATE(DstinittypeData%Joints(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstinittypeData%Joints.', ErrStat, ErrMsg,'SD_Copyinittype')
         RETURN
      END IF
   END IF
   DstinittypeData%Joints = SrcinittypeData%Joints
ENDIF
IF (ALLOCATED(SrcinittypeData%PropSets)) THEN
   i1_l = LBOUND(SrcinittypeData%PropSets,1)
   i1_u = UBOUND(SrcinittypeData%PropSets,1)
   i2_l = LBOUND(SrcinittypeData%PropSets,2)
   i2_u = UBOUND(SrcinittypeData%PropSets,2)
   IF (.NOT. ALLOCATED(DstinittypeData%PropSets)) THEN 
      ALLOCATE(DstinittypeData%PropSets(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstinittypeData%PropSets.', ErrStat, ErrMsg,'SD_Copyinittype')
         RETURN
      END IF
   END IF
   DstinittypeData%PropSets = SrcinittypeData%PropSets
ENDIF
IF (ALLOCATED(SrcinittypeData%XPropSets)) THEN
   i1_l = LBOUND(SrcinittypeData%XPropSets,1)
   i1_u = UBOUND(SrcinittypeData%XPropSets,1)
   i2_l = LBOUND(SrcinittypeData%XPropSets,2)
   i2_u = UBOUND(SrcinittypeData%XPropSets,2)
   IF (.NOT. ALLOCATED(DstinittypeData%XPropSets)) THEN 
      ALLOCATE(DstinittypeData%XPropSets(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstinittypeData%XPropSets.', ErrStat, ErrMsg,'SD_Copyinittype')
         RETURN
      END IF
   END IF
   DstinittypeData%XPropSets = SrcinittypeData%XPropSets
ENDIF
IF (ALLOCATED(SrcinittypeData%COSMs)) THEN
   i1_l = LBOUND(SrcinittypeData%COSMs,1)
   i1_u = UBOUND(SrcinittypeData%COSMs,1)
   i2_l = LBOUND(SrcinittypeData%COSMs,2)
   i2_u = UBOUND(SrcinittypeData%COSMs,2)
   IF (.NOT. ALLOCATED(DstinittypeData%COSMs)) THEN 
      ALLOCATE(DstinittypeData%COSMs(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstinittypeData%COSMs.', ErrStat, ErrMsg,'SD_Copyinittype')
         RETURN
      END IF
   END IF
   DstinittypeData%COSMs = SrcinittypeData%COSMs
ENDIF
IF (ALLOCATED(SrcinittypeData%CMass)) THEN
   i1_l = LBOUND(SrcinittypeData%CMass,1)
   i1_u = UBOUND(SrcinittypeData%CMass,1)
   i2_l = LBOUND(SrcinittypeData%CMass,2)
   i2_u = UBOUND(SrcinittypeData%CMass,2)
   IF (.NOT. ALLOCATED(DstinittypeData%CMass)) THEN 
      ALLOCATE(DstinittypeData%CMass(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstinittypeData%CMass.', ErrStat, ErrMsg,'SD_Copyinittype')
         RETURN
      END IF
   END IF
   DstinittypeData%CMass = SrcinittypeData%CMass
ENDIF
IF (ALLOCATED(SrcinittypeData%JDampings)) THEN
   i1_l = LBOUND(SrcinittypeData%JDampings,1)
   i1_u = UBOUND(SrcinittypeData%JDampings,1)
   IF (.NOT. ALLOCATED(DstinittypeData%JDampings)) THEN 
      ALLOCATE(DstinittypeData%JDampings(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstinittypeData%JDampings.', ErrStat, ErrMsg,'SD_Copyinittype')
         RETURN
      END IF
   END IF
   DstinittypeData%JDampings = SrcinittypeData%JDampings
ENDIF
IF (ALLOCATED(SrcinittypeData%Members)) THEN
   i1_l = LBOUND(SrcinittypeData%Members,1)
   i1_u = UBOUND(SrcinittypeData%Members,1)
   i2_l = LBOUND(SrcinittypeData%Members,2)
   i2_u = UBOUND(SrcinittypeData%Members,2)
   IF (.NOT. ALLOCATED(DstinittypeData%Members)) THEN 
      ALLOCATE(DstinittypeData%Members(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstinittypeData%Members.', ErrStat, ErrMsg,'SD_Copyinittype')
         RETURN
      END IF
   END IF
   DstinittypeData%Members = SrcinittypeData%Members
ENDIF
IF (ALLOCATED(SrcinittypeData%Interf)) THEN
   i1_l = LBOUND(SrcinittypeData%Interf,1)
   i1_u = UBOUND(SrcinittypeData%Interf,1)
   i2_l = LBOUND(SrcinittypeData%Interf,2)
   i2_u = UBOUND(SrcinittypeData%Interf,2)
   IF (.NOT. ALLOCATED(DstinittypeData%Interf)) THEN 
      ALLOCATE(DstinittypeData%Interf(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstinittypeData%Interf.', ErrStat, ErrMsg,'SD_Copyinittype')
         RETURN
      END IF
   END IF
   DstinittypeData%Interf = SrcinittypeData%Interf
ENDIF
IF (ALLOCATED(SrcinittypeData%SSOutList)) THEN
   i1_l = LBOUND(SrcinittypeData%SSOutList,1)
   i1_u = UBOUND(SrcinittypeData%SSOutList,1)
   IF (.NOT. ALLOCATED(DstinittypeData%SSOutList)) THEN 
      ALLOCATE(DstinittypeData%SSOutList(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstinittypeData%SSOutList.', ErrStat, ErrMsg,'SD_Copyinittype')
         RETURN
      END IF
   END IF
   DstinittypeData%SSOutList = SrcinittypeData%SSOutList
ENDIF
   DstinittypeData%OutCOSM = SrcinittypeData%OutCOSM
   DstinittypeData%TabDelim = SrcinittypeData%TabDelim
   DstinittypeData%NNode = SrcinittypeData%NNode
   DstinittypeData%NElem = SrcinittypeData%NElem
   DstinittypeData%NProp = SrcinittypeData%NProp
   DstinittypeData%TDOF = SrcinittypeData%TDOF
IF (ALLOCATED(SrcinittypeData%Nodes)) THEN
   i1_l = LBOUND(SrcinittypeData%Nodes,1)
   i1_u = UBOUND(SrcinittypeData%Nodes,1)
   i2_l = LBOUND(SrcinittypeData%Nodes,2)
   i2_u = UBOUND(SrcinittypeData%Nodes,2)
   IF (.NOT. ALLOCATED(DstinittypeData%Nodes)) THEN 
      ALLOCATE(DstinittypeData%Nodes(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstinittypeData%Nodes.', ErrStat, ErrMsg,'SD_Copyinittype')
         RETURN
      END IF
   END IF
   DstinittypeData%Nodes = SrcinittypeData%Nodes
ENDIF
IF (ALLOCATED(SrcinittypeData%Props)) THEN
   i1_l = LBOUND(SrcinittypeData%Props,1)
   i1_u = UBOUND(SrcinittypeData%Props,1)
   i2_l = LBOUND(SrcinittypeData%Props,2)
   i2_u = UBOUND(SrcinittypeData%Props,2)
   IF (.NOT. ALLOCATED(DstinittypeData%Props)) THEN 
      ALLOCATE(DstinittypeData%Props(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstinittypeData%Props.', ErrStat, ErrMsg,'SD_Copyinittype')
         RETURN
      END IF
   END IF
   DstinittypeData%Props = SrcinittypeData%Props
ENDIF
IF (ALLOCATED(SrcinittypeData%K)) THEN
   i1_l = LBOUND(SrcinittypeData%K,1)
   i1_u = UBOUND(SrcinittypeData%K,1)
   i2_l = LBOUND(SrcinittypeData%K,2)
   i2_u = UBOUND(SrcinittypeData%K,2)
   IF (.NOT. ALLOCATED(DstinittypeData%K)) THEN 
      ALLOCATE(DstinittypeData%K(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstinittypeData%K.', ErrStat, ErrMsg,'SD_Copyinittype')
         RETURN
      END IF
   END IF
   DstinittypeData%K = SrcinittypeData%K
ENDIF
IF (ALLOCATED(SrcinittypeData%M)) THEN
   i1_l = LBOUND(SrcinittypeData%M,1)
   i1_u = UBOUND(SrcinittypeData%M,1)
   i2_l = LBOUND(SrcinittypeData%M,2)
   i2_u = UBOUND(SrcinittypeData%M,2)
   IF (.NOT. ALLOCATED(DstinittypeData%M)) THEN 
      ALLOCATE(DstinittypeData%M(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstinittypeData%M.', ErrStat, ErrMsg,'SD_Copyinittype')
         RETURN
      END IF
   END IF
   DstinittypeData%M = SrcinittypeData%M
ENDIF
IF (ALLOCATED(SrcinittypeData%F)) THEN
   i1_l = LBOUND(SrcinittypeData%F,1)
   i1_u = UBOUND(SrcinittypeData%F,1)
   IF (.NOT. ALLOCATED(DstinittypeData%F)) THEN 
      ALLOCATE(DstinittypeData%F(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstinittypeData%F.', ErrStat, ErrMsg,'SD_Copyinittype')
         RETURN
      END IF
   END IF
   DstinittypeData%F = SrcinittypeData%F
ENDIF
IF (ALLOCATED(SrcinittypeData%FG)) THEN
   i1_l = LBOUND(SrcinittypeData%FG,1)
   i1_u = UBOUND(SrcinittypeData%FG,1)
   IF (.NOT. ALLOCATED(DstinittypeData%FG)) THEN 
      ALLOCATE(DstinittypeData%FG(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstinittypeData%FG.', ErrStat, ErrMsg,'SD_Copyinittype')
         RETURN
      END IF
   END IF
   DstinittypeData%FG = SrcinittypeData%FG
ENDIF
IF (ALLOCATED(SrcinittypeData%ElemProps)) THEN
   i1_l = LBOUND(SrcinittypeData%ElemProps,1)
   i1_u = UBOUND(SrcinittypeData%ElemProps,1)
   i2_l = LBOUND(SrcinittypeData%ElemProps,2)
   i2_u = UBOUND(SrcinittypeData%ElemProps,2)
   IF (.NOT. ALLOCATED(DstinittypeData%ElemProps)) THEN 
      ALLOCATE(DstinittypeData%ElemProps(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstinittypeData%ElemProps.', ErrStat, ErrMsg,'SD_Copyinittype')
         RETURN
      END IF
   END IF
   DstinittypeData%ElemProps = SrcinittypeData%ElemProps
ENDIF
IF (ALLOCATED(SrcinittypeData%BCs)) THEN
   i1_l = LBOUND(SrcinittypeData%BCs,1)
   i1_u = UBOUND(SrcinittypeData%BCs,1)
   i2_l = LBOUND(SrcinittypeData%BCs,2)
   i2_u = UBOUND(SrcinittypeData%BCs,2)
   IF (.NOT. ALLOCATED(DstinittypeData%BCs)) THEN 
      ALLOCATE(DstinittypeData%BCs(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstinittypeData%BCs.', ErrStat, ErrMsg,'SD_Copyinittype')
         RETURN
      END IF
   END IF
   DstinittypeData%BCs = SrcinittypeData%BCs
ENDIF
IF (ALLOCATED(SrcinittypeData%IntFc)) THEN
   i1_l = LBOUND(SrcinittypeData%IntFc,1)
   i1_u = UBOUND(SrcinittypeData%IntFc,1)
   i2_l = LBOUND(SrcinittypeData%IntFc,2)
   i2_u = UBOUND(SrcinittypeData%IntFc,2)
   IF (.NOT. ALLOCATED(DstinittypeData%IntFc)) THEN 
      ALLOCATE(DstinittypeData%IntFc(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstinittypeData%IntFc.', ErrStat, ErrMsg,'SD_Copyinittype')
         RETURN
      END IF
   END IF
   DstinittypeData%IntFc = SrcinittypeData%IntFc
ENDIF
IF (ALLOCATED(SrcinittypeData%MemberNodes)) THEN
   i1_l = LBOUND(SrcinittypeData%MemberNodes,1)
   i1_u = UBOUND(SrcinittypeData%MemberNodes,1)
   i2_l = LBOUND(SrcinittypeData%MemberNodes,2)
   i2_u = UBOUND(SrcinittypeData%MemberNodes,2)
   IF (.NOT. ALLOCATED(DstinittypeData%MemberNodes)) THEN 
      ALLOCATE(DstinittypeData%MemberNodes(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstinittypeData%MemberNodes.', ErrStat, ErrMsg,'SD_Copyinittype')
         RETURN
      END IF
   END IF
   DstinittypeData%MemberNodes = SrcinittypeData%MemberNodes
ENDIF
IF (ALLOCATED(SrcinittypeData%NodesConnN)) THEN
   i1_l = LBOUND(SrcinittypeData%NodesConnN,1)
   i1_u = UBOUND(SrcinittypeData%NodesConnN,1)
   i2_l = LBOUND(SrcinittypeData%NodesConnN,2)
   i2_u = UBOUND(SrcinittypeData%NodesConnN,2)
   IF (.NOT. ALLOCATED(DstinittypeData%NodesConnN)) THEN 
      ALLOCATE(DstinittypeData%NodesConnN(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstinittypeData%NodesConnN.', ErrStat, ErrMsg,'SD_Copyinittype')
         RETURN
      END IF
   END IF
   DstinittypeData%NodesConnN = SrcinittypeData%NodesConnN
ENDIF
IF (ALLOCATED(SrcinittypeData%NodesConnE)) THEN
   i1_l = LBOUND(SrcinittypeData%NodesConnE,1)
   i1_u = UBOUND(SrcinittypeData%NodesConnE,1)
   i2_l = LBOUND(SrcinittypeData%NodesConnE,2)
   i2_u = UBOUND(SrcinittypeData%NodesConnE,2)
   IF (.NOT. ALLOCATED(DstinittypeData%NodesConnE)) THEN 
      ALLOCATE(DstinittypeData%NodesConnE(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstinittypeData%NodesConnE.', ErrStat, ErrMsg,'SD_Copyinittype')
         RETURN
      END IF
   END IF
   DstinittypeData%NodesConnE = SrcinittypeData%NodesConnE
ENDIF
   DstinittypeData%SSSum = SrcinittypeData%SSSum
 END SUBROUTINE SD_Copyinittype

 SUBROUTINE SD_Destroyinittype( inittypeData, ErrStat, ErrMsg )
  TYPE(sd_inittype), INTENT(INOUT) :: inittypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(inittypeData%Joints)) THEN
   DEALLOCATE(inittypeData%Joints)
ENDIF
IF (ALLOCATED(inittypeData%PropSets)) THEN
   DEALLOCATE(inittypeData%PropSets)
ENDIF
IF (ALLOCATED(inittypeData%XPropSets)) THEN
   DEALLOCATE(inittypeData%XPropSets)
ENDIF
IF (ALLOCATED(inittypeData%COSMs)) THEN
   DEALLOCATE(inittypeData%COSMs)
ENDIF
IF (ALLOCATED(inittypeData%CMass)) THEN
   DEALLOCATE(inittypeData%CMass)
ENDIF
IF (ALLOCATED(inittypeData%JDampings)) THEN
   DEALLOCATE(inittypeData%JDampings)
ENDIF
IF (ALLOCATED(inittypeData%Members)) THEN
   DEALLOCATE(inittypeData%Members)
ENDIF
IF (ALLOCATED(inittypeData%Interf)) THEN
   DEALLOCATE(inittypeData%Interf)
ENDIF
IF (ALLOCATED(inittypeData%SSOutList)) THEN
   DEALLOCATE(inittypeData%SSOutList)
ENDIF
IF (ALLOCATED(inittypeData%Nodes)) THEN
   DEALLOCATE(inittypeData%Nodes)
ENDIF
IF (ALLOCATED(inittypeData%Props)) THEN
   DEALLOCATE(inittypeData%Props)
ENDIF
IF (ALLOCATED(inittypeData%K)) THEN
   DEALLOCATE(inittypeData%K)
ENDIF
IF (ALLOCATED(inittypeData%M)) THEN
   DEALLOCATE(inittypeData%M)
ENDIF
IF (ALLOCATED(inittypeData%F)) THEN
   DEALLOCATE(inittypeData%F)
ENDIF
IF (ALLOCATED(inittypeData%FG)) THEN
   DEALLOCATE(inittypeData%FG)
ENDIF
IF (ALLOCATED(inittypeData%ElemProps)) THEN
   DEALLOCATE(inittypeData%ElemProps)
ENDIF
IF (ALLOCATED(inittypeData%BCs)) THEN
   DEALLOCATE(inittypeData%BCs)
ENDIF
IF (ALLOCATED(inittypeData%IntFc)) THEN
   DEALLOCATE(inittypeData%IntFc)
ENDIF
IF (ALLOCATED(inittypeData%MemberNodes)) THEN
   DEALLOCATE(inittypeData%MemberNodes)
ENDIF
IF (ALLOCATED(inittypeData%NodesConnN)) THEN
   DEALLOCATE(inittypeData%NodesConnN)
ENDIF
IF (ALLOCATED(inittypeData%NodesConnE)) THEN
   DEALLOCATE(inittypeData%NodesConnE)
ENDIF
 END SUBROUTINE SD_Destroyinittype

 SUBROUTINE SD_Packinittype( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(sd_inittype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
!  missing buffer for RootName
  Re_BufSz    = Re_BufSz    + SIZE( InData%TP_RefPoint )  ! TP_RefPoint 
  Re_BufSz   = Re_BufSz   + 1  ! SubRotateZ
  Re_BufSz   = Re_BufSz   + 1  ! g
  Db_BufSz   = Db_BufSz   + 1  ! DT
  Int_BufSz  = Int_BufSz  + 1  ! NJoints
  Int_BufSz  = Int_BufSz  + 1  ! NPropSets
  Int_BufSz  = Int_BufSz  + 1  ! NXPropSets
  Int_BufSz  = Int_BufSz  + 1  ! NInterf
  Int_BufSz  = Int_BufSz  + 1  ! NCMass
  Int_BufSz  = Int_BufSz  + 1  ! NCOSMs
  Int_BufSz  = Int_BufSz  + 1  ! FEMMod
  Int_BufSz  = Int_BufSz  + 1  ! NDiv
  Int_BufSz  = Int_BufSz  + 1  ! CBMod
  IF ( ALLOCATED(InData%Joints) )   Re_BufSz    = Re_BufSz    + SIZE( InData%Joints )  ! Joints 
  IF ( ALLOCATED(InData%PropSets) )   Re_BufSz    = Re_BufSz    + SIZE( InData%PropSets )  ! PropSets 
  IF ( ALLOCATED(InData%XPropSets) )   Re_BufSz    = Re_BufSz    + SIZE( InData%XPropSets )  ! XPropSets 
  IF ( ALLOCATED(InData%COSMs) )   Re_BufSz    = Re_BufSz    + SIZE( InData%COSMs )  ! COSMs 
  IF ( ALLOCATED(InData%CMass) )   Re_BufSz    = Re_BufSz    + SIZE( InData%CMass )  ! CMass 
  IF ( ALLOCATED(InData%JDampings) )   Re_BufSz    = Re_BufSz    + SIZE( InData%JDampings )  ! JDampings 
  IF ( ALLOCATED(InData%Members) )   Int_BufSz   = Int_BufSz   + SIZE( InData%Members )  ! Members 
  IF ( ALLOCATED(InData%Interf) )   Int_BufSz   = Int_BufSz   + SIZE( InData%Interf )  ! Interf 
!  missing buffer for SSOutList
  Int_BufSz  = Int_BufSz  + 1  ! OutCOSM
  Int_BufSz  = Int_BufSz  + 1  ! TabDelim
  Int_BufSz  = Int_BufSz  + 1  ! NNode
  Int_BufSz  = Int_BufSz  + 1  ! NElem
  Int_BufSz  = Int_BufSz  + 1  ! NProp
  Int_BufSz  = Int_BufSz  + 1  ! TDOF
  IF ( ALLOCATED(InData%Nodes) )   Re_BufSz    = Re_BufSz    + SIZE( InData%Nodes )  ! Nodes 
  IF ( ALLOCATED(InData%Props) )   Re_BufSz    = Re_BufSz    + SIZE( InData%Props )  ! Props 
  IF ( ALLOCATED(InData%K) )   Re_BufSz    = Re_BufSz    + SIZE( InData%K )  ! K 
  IF ( ALLOCATED(InData%M) )   Re_BufSz    = Re_BufSz    + SIZE( InData%M )  ! M 
  IF ( ALLOCATED(InData%F) )   Re_BufSz    = Re_BufSz    + SIZE( InData%F )  ! F 
  IF ( ALLOCATED(InData%FG) )   Re_BufSz    = Re_BufSz    + SIZE( InData%FG )  ! FG 
  IF ( ALLOCATED(InData%ElemProps) )   Re_BufSz    = Re_BufSz    + SIZE( InData%ElemProps )  ! ElemProps 
  IF ( ALLOCATED(InData%BCs) )   Int_BufSz   = Int_BufSz   + SIZE( InData%BCs )  ! BCs 
  IF ( ALLOCATED(InData%IntFc) )   Int_BufSz   = Int_BufSz   + SIZE( InData%IntFc )  ! IntFc 
  IF ( ALLOCATED(InData%MemberNodes) )   Int_BufSz   = Int_BufSz   + SIZE( InData%MemberNodes )  ! MemberNodes 
  IF ( ALLOCATED(InData%NodesConnN) )   Int_BufSz   = Int_BufSz   + SIZE( InData%NodesConnN )  ! NodesConnN 
  IF ( ALLOCATED(InData%NodesConnE) )   Int_BufSz   = Int_BufSz   + SIZE( InData%NodesConnE )  ! NodesConnE 
  Int_BufSz  = Int_BufSz  + 1  ! SSSum
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%TP_RefPoint))-1 ) =  PACK(InData%TP_RefPoint ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%TP_RefPoint)
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%SubRotateZ )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%g )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(1)-1 ) =  (InData%DT )
  Db_Xferred   = Db_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NJoints )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NPropSets )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NXPropSets )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NInterf )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NCMass )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NCOSMs )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%FEMMod )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NDiv )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = TRANSFER( (InData%CBMod ), IntKiBuf(1), 1)
  Int_Xferred   = Int_Xferred   + 1
  IF ( ALLOCATED(InData%Joints) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Joints))-1 ) =  PACK(InData%Joints ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%Joints)
  ENDIF
  IF ( ALLOCATED(InData%PropSets) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%PropSets))-1 ) =  PACK(InData%PropSets ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%PropSets)
  ENDIF
  IF ( ALLOCATED(InData%XPropSets) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%XPropSets))-1 ) =  PACK(InData%XPropSets ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%XPropSets)
  ENDIF
  IF ( ALLOCATED(InData%COSMs) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%COSMs))-1 ) =  PACK(InData%COSMs ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%COSMs)
  ENDIF
  IF ( ALLOCATED(InData%CMass) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%CMass))-1 ) =  PACK(InData%CMass ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%CMass)
  ENDIF
  IF ( ALLOCATED(InData%JDampings) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%JDampings))-1 ) =  PACK(InData%JDampings ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%JDampings)
  ENDIF
  IF ( ALLOCATED(InData%Members) ) THEN
    IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%Members))-1 ) = PACK(InData%Members ,.TRUE.)
    Int_Xferred   = Int_Xferred   + SIZE(InData%Members)
  ENDIF
  IF ( ALLOCATED(InData%Interf) ) THEN
    IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%Interf))-1 ) = PACK(InData%Interf ,.TRUE.)
    Int_Xferred   = Int_Xferred   + SIZE(InData%Interf)
  ENDIF
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = TRANSFER( (InData%OutCOSM ), IntKiBuf(1), 1)
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = TRANSFER( (InData%TabDelim ), IntKiBuf(1), 1)
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NNode )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NElem )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NProp )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%TDOF )
  Int_Xferred   = Int_Xferred   + 1
  IF ( ALLOCATED(InData%Nodes) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Nodes))-1 ) =  PACK(InData%Nodes ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%Nodes)
  ENDIF
  IF ( ALLOCATED(InData%Props) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Props))-1 ) =  PACK(InData%Props ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%Props)
  ENDIF
  IF ( ALLOCATED(InData%K) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%K))-1 ) =  PACK(InData%K ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%K)
  ENDIF
  IF ( ALLOCATED(InData%M) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%M))-1 ) =  PACK(InData%M ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%M)
  ENDIF
  IF ( ALLOCATED(InData%F) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%F))-1 ) =  PACK(InData%F ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%F)
  ENDIF
  IF ( ALLOCATED(InData%FG) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%FG))-1 ) =  PACK(InData%FG ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%FG)
  ENDIF
  IF ( ALLOCATED(InData%ElemProps) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%ElemProps))-1 ) =  PACK(InData%ElemProps ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%ElemProps)
  ENDIF
  IF ( ALLOCATED(InData%BCs) ) THEN
    IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%BCs))-1 ) = PACK(InData%BCs ,.TRUE.)
    Int_Xferred   = Int_Xferred   + SIZE(InData%BCs)
  ENDIF
  IF ( ALLOCATED(InData%IntFc) ) THEN
    IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%IntFc))-1 ) = PACK(InData%IntFc ,.TRUE.)
    Int_Xferred   = Int_Xferred   + SIZE(InData%IntFc)
  ENDIF
  IF ( ALLOCATED(InData%MemberNodes) ) THEN
    IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%MemberNodes))-1 ) = PACK(InData%MemberNodes ,.TRUE.)
    Int_Xferred   = Int_Xferred   + SIZE(InData%MemberNodes)
  ENDIF
  IF ( ALLOCATED(InData%NodesConnN) ) THEN
    IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%NodesConnN))-1 ) = PACK(InData%NodesConnN ,.TRUE.)
    Int_Xferred   = Int_Xferred   + SIZE(InData%NodesConnN)
  ENDIF
  IF ( ALLOCATED(InData%NodesConnE) ) THEN
    IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%NodesConnE))-1 ) = PACK(InData%NodesConnE ,.TRUE.)
    Int_Xferred   = Int_Xferred   + SIZE(InData%NodesConnE)
  ENDIF
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = TRANSFER( (InData%SSSum ), IntKiBuf(1), 1)
  Int_Xferred   = Int_Xferred   + 1
 END SUBROUTINE SD_Packinittype

 SUBROUTINE SD_UnPackinittype( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(sd_inittype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  ALLOCATE(mask1(SIZE(OutData%TP_RefPoint,1))); mask1 = .TRUE.
  OutData%TP_RefPoint = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%TP_RefPoint))-1 ),mask1,OutData%TP_RefPoint)
  DEALLOCATE(mask1)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%TP_RefPoint)
  OutData%SubRotateZ = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%g = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%DT = DbKiBuf ( Db_Xferred )
  Db_Xferred   = Db_Xferred   + 1
  OutData%NJoints = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%NPropSets = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%NXPropSets = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%NInterf = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%NCMass = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%NCOSMs = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%FEMMod = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%NDiv = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  IF ( ALLOCATED(OutData%Joints) ) THEN
  ALLOCATE(mask2(SIZE(OutData%Joints,1),SIZE(OutData%Joints,2))); mask2 = .TRUE.
    OutData%Joints = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Joints))-1 ),mask2,OutData%Joints)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%Joints)
  ENDIF
  IF ( ALLOCATED(OutData%PropSets) ) THEN
  ALLOCATE(mask2(SIZE(OutData%PropSets,1),SIZE(OutData%PropSets,2))); mask2 = .TRUE.
    OutData%PropSets = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%PropSets))-1 ),mask2,OutData%PropSets)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%PropSets)
  ENDIF
  IF ( ALLOCATED(OutData%XPropSets) ) THEN
  ALLOCATE(mask2(SIZE(OutData%XPropSets,1),SIZE(OutData%XPropSets,2))); mask2 = .TRUE.
    OutData%XPropSets = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%XPropSets))-1 ),mask2,OutData%XPropSets)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%XPropSets)
  ENDIF
  IF ( ALLOCATED(OutData%COSMs) ) THEN
  ALLOCATE(mask2(SIZE(OutData%COSMs,1),SIZE(OutData%COSMs,2))); mask2 = .TRUE.
    OutData%COSMs = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%COSMs))-1 ),mask2,OutData%COSMs)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%COSMs)
  ENDIF
  IF ( ALLOCATED(OutData%CMass) ) THEN
  ALLOCATE(mask2(SIZE(OutData%CMass,1),SIZE(OutData%CMass,2))); mask2 = .TRUE.
    OutData%CMass = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%CMass))-1 ),mask2,OutData%CMass)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%CMass)
  ENDIF
  IF ( ALLOCATED(OutData%JDampings) ) THEN
  ALLOCATE(mask1(SIZE(OutData%JDampings,1))); mask1 = .TRUE.
    OutData%JDampings = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%JDampings))-1 ),mask1,OutData%JDampings)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%JDampings)
  ENDIF
  IF ( ALLOCATED(OutData%Members) ) THEN
  ALLOCATE(mask2(SIZE(OutData%Members,1),SIZE(OutData%Members,2))); mask2 = .TRUE.
    OutData%Members = UNPACK(IntKiBuf( Int_Xferred:Re_Xferred+(SIZE(OutData%Members))-1 ),mask2,OutData%Members)
  DEALLOCATE(mask2)
    Int_Xferred   = Int_Xferred   + SIZE(OutData%Members)
  ENDIF
  IF ( ALLOCATED(OutData%Interf) ) THEN
  ALLOCATE(mask2(SIZE(OutData%Interf,1),SIZE(OutData%Interf,2))); mask2 = .TRUE.
    OutData%Interf = UNPACK(IntKiBuf( Int_Xferred:Re_Xferred+(SIZE(OutData%Interf))-1 ),mask2,OutData%Interf)
  DEALLOCATE(mask2)
    Int_Xferred   = Int_Xferred   + SIZE(OutData%Interf)
  ENDIF
  OutData%NNode = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%NElem = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%NProp = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%TDOF = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  IF ( ALLOCATED(OutData%Nodes) ) THEN
  ALLOCATE(mask2(SIZE(OutData%Nodes,1),SIZE(OutData%Nodes,2))); mask2 = .TRUE.
    OutData%Nodes = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Nodes))-1 ),mask2,OutData%Nodes)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%Nodes)
  ENDIF
  IF ( ALLOCATED(OutData%Props) ) THEN
  ALLOCATE(mask2(SIZE(OutData%Props,1),SIZE(OutData%Props,2))); mask2 = .TRUE.
    OutData%Props = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Props))-1 ),mask2,OutData%Props)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%Props)
  ENDIF
  IF ( ALLOCATED(OutData%K) ) THEN
  ALLOCATE(mask2(SIZE(OutData%K,1),SIZE(OutData%K,2))); mask2 = .TRUE.
    OutData%K = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%K))-1 ),mask2,OutData%K)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%K)
  ENDIF
  IF ( ALLOCATED(OutData%M) ) THEN
  ALLOCATE(mask2(SIZE(OutData%M,1),SIZE(OutData%M,2))); mask2 = .TRUE.
    OutData%M = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%M))-1 ),mask2,OutData%M)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%M)
  ENDIF
  IF ( ALLOCATED(OutData%F) ) THEN
  ALLOCATE(mask1(SIZE(OutData%F,1))); mask1 = .TRUE.
    OutData%F = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%F))-1 ),mask1,OutData%F)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%F)
  ENDIF
  IF ( ALLOCATED(OutData%FG) ) THEN
  ALLOCATE(mask1(SIZE(OutData%FG,1))); mask1 = .TRUE.
    OutData%FG = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%FG))-1 ),mask1,OutData%FG)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%FG)
  ENDIF
  IF ( ALLOCATED(OutData%ElemProps) ) THEN
  ALLOCATE(mask2(SIZE(OutData%ElemProps,1),SIZE(OutData%ElemProps,2))); mask2 = .TRUE.
    OutData%ElemProps = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%ElemProps))-1 ),mask2,OutData%ElemProps)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%ElemProps)
  ENDIF
  IF ( ALLOCATED(OutData%BCs) ) THEN
  ALLOCATE(mask2(SIZE(OutData%BCs,1),SIZE(OutData%BCs,2))); mask2 = .TRUE.
    OutData%BCs = UNPACK(IntKiBuf( Int_Xferred:Re_Xferred+(SIZE(OutData%BCs))-1 ),mask2,OutData%BCs)
  DEALLOCATE(mask2)
    Int_Xferred   = Int_Xferred   + SIZE(OutData%BCs)
  ENDIF
  IF ( ALLOCATED(OutData%IntFc) ) THEN
  ALLOCATE(mask2(SIZE(OutData%IntFc,1),SIZE(OutData%IntFc,2))); mask2 = .TRUE.
    OutData%IntFc = UNPACK(IntKiBuf( Int_Xferred:Re_Xferred+(SIZE(OutData%IntFc))-1 ),mask2,OutData%IntFc)
  DEALLOCATE(mask2)
    Int_Xferred   = Int_Xferred   + SIZE(OutData%IntFc)
  ENDIF
  IF ( ALLOCATED(OutData%MemberNodes) ) THEN
  ALLOCATE(mask2(SIZE(OutData%MemberNodes,1),SIZE(OutData%MemberNodes,2))); mask2 = .TRUE.
    OutData%MemberNodes = UNPACK(IntKiBuf( Int_Xferred:Re_Xferred+(SIZE(OutData%MemberNodes))-1 ),mask2,OutData%MemberNodes)
  DEALLOCATE(mask2)
    Int_Xferred   = Int_Xferred   + SIZE(OutData%MemberNodes)
  ENDIF
  IF ( ALLOCATED(OutData%NodesConnN) ) THEN
  ALLOCATE(mask2(SIZE(OutData%NodesConnN,1),SIZE(OutData%NodesConnN,2))); mask2 = .TRUE.
    OutData%NodesConnN = UNPACK(IntKiBuf( Int_Xferred:Re_Xferred+(SIZE(OutData%NodesConnN))-1 ),mask2,OutData%NodesConnN)
  DEALLOCATE(mask2)
    Int_Xferred   = Int_Xferred   + SIZE(OutData%NodesConnN)
  ENDIF
  IF ( ALLOCATED(OutData%NodesConnE) ) THEN
  ALLOCATE(mask2(SIZE(OutData%NodesConnE,1),SIZE(OutData%NodesConnE,2))); mask2 = .TRUE.
    OutData%NodesConnE = UNPACK(IntKiBuf( Int_Xferred:Re_Xferred+(SIZE(OutData%NodesConnE))-1 ),mask2,OutData%NodesConnE)
  DEALLOCATE(mask2)
    Int_Xferred   = Int_Xferred   + SIZE(OutData%NodesConnE)
  ENDIF
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE SD_UnPackinittype

 SUBROUTINE SD_CopyContState( SrcContStateData, DstContStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(SD_continuousstatetype), INTENT(INOUT) :: SrcContStateData
   TYPE(SD_continuousstatetype), INTENT(INOUT) :: DstContStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcContStateData%qm)) THEN
   i1_l = LBOUND(SrcContStateData%qm,1)
   i1_u = UBOUND(SrcContStateData%qm,1)
   IF (.NOT. ALLOCATED(DstContStateData%qm)) THEN 
      ALLOCATE(DstContStateData%qm(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstContStateData%qm.', ErrStat, ErrMsg,'SD_CopyContState')
         RETURN
      END IF
   END IF
   DstContStateData%qm = SrcContStateData%qm
ENDIF
IF (ALLOCATED(SrcContStateData%qmdot)) THEN
   i1_l = LBOUND(SrcContStateData%qmdot,1)
   i1_u = UBOUND(SrcContStateData%qmdot,1)
   IF (.NOT. ALLOCATED(DstContStateData%qmdot)) THEN 
      ALLOCATE(DstContStateData%qmdot(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstContStateData%qmdot.', ErrStat, ErrMsg,'SD_CopyContState')
         RETURN
      END IF
   END IF
   DstContStateData%qmdot = SrcContStateData%qmdot
ENDIF
 END SUBROUTINE SD_CopyContState

 SUBROUTINE SD_DestroyContState( ContStateData, ErrStat, ErrMsg )
  TYPE(SD_continuousstatetype), INTENT(INOUT) :: ContStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(ContStateData%qm)) THEN
   DEALLOCATE(ContStateData%qm)
ENDIF
IF (ALLOCATED(ContStateData%qmdot)) THEN
   DEALLOCATE(ContStateData%qmdot)
ENDIF
 END SUBROUTINE SD_DestroyContState

 SUBROUTINE SD_PackContState( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(SD_continuousstatetype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  IF ( ALLOCATED(InData%qm) )   Re_BufSz    = Re_BufSz    + SIZE( InData%qm )  ! qm 
  IF ( ALLOCATED(InData%qmdot) )   Re_BufSz    = Re_BufSz    + SIZE( InData%qmdot )  ! qmdot 
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( ALLOCATED(InData%qm) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%qm))-1 ) =  PACK(InData%qm ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%qm)
  ENDIF
  IF ( ALLOCATED(InData%qmdot) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%qmdot))-1 ) =  PACK(InData%qmdot ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%qmdot)
  ENDIF
 END SUBROUTINE SD_PackContState

 SUBROUTINE SD_UnPackContState( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(SD_continuousstatetype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  IF ( ALLOCATED(OutData%qm) ) THEN
  ALLOCATE(mask1(SIZE(OutData%qm,1))); mask1 = .TRUE.
    OutData%qm = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%qm))-1 ),mask1,OutData%qm)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%qm)
  ENDIF
  IF ( ALLOCATED(OutData%qmdot) ) THEN
  ALLOCATE(mask1(SIZE(OutData%qmdot,1))); mask1 = .TRUE.
    OutData%qmdot = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%qmdot))-1 ),mask1,OutData%qmdot)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%qmdot)
  ENDIF
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE SD_UnPackContState

 SUBROUTINE SD_CopyDiscState( SrcDiscStateData, DstDiscStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(SD_discretestatetype), INTENT(INOUT) :: SrcDiscStateData
   TYPE(SD_discretestatetype), INTENT(INOUT) :: DstDiscStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
   DstDiscStateData%DummyDiscState = SrcDiscStateData%DummyDiscState
 END SUBROUTINE SD_CopyDiscState

 SUBROUTINE SD_DestroyDiscState( DiscStateData, ErrStat, ErrMsg )
  TYPE(SD_discretestatetype), INTENT(INOUT) :: DiscStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
 END SUBROUTINE SD_DestroyDiscState

 SUBROUTINE SD_PackDiscState( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(SD_discretestatetype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Re_BufSz   = Re_BufSz   + 1  ! DummyDiscState
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%DummyDiscState )
  Re_Xferred   = Re_Xferred   + 1
 END SUBROUTINE SD_PackDiscState

 SUBROUTINE SD_UnPackDiscState( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(SD_discretestatetype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  OutData%DummyDiscState = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE SD_UnPackDiscState

 SUBROUTINE SD_CopyConstrState( SrcConstrStateData, DstConstrStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(SD_constraintstatetype), INTENT(INOUT) :: SrcConstrStateData
   TYPE(SD_constraintstatetype), INTENT(INOUT) :: DstConstrStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
   DstConstrStateData%DummyConstrState = SrcConstrStateData%DummyConstrState
 END SUBROUTINE SD_CopyConstrState

 SUBROUTINE SD_DestroyConstrState( ConstrStateData, ErrStat, ErrMsg )
  TYPE(SD_constraintstatetype), INTENT(INOUT) :: ConstrStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
 END SUBROUTINE SD_DestroyConstrState

 SUBROUTINE SD_PackConstrState( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(SD_constraintstatetype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Re_BufSz   = Re_BufSz   + 1  ! DummyConstrState
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%DummyConstrState )
  Re_Xferred   = Re_Xferred   + 1
 END SUBROUTINE SD_PackConstrState

 SUBROUTINE SD_UnPackConstrState( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(SD_constraintstatetype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  OutData%DummyConstrState = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE SD_UnPackConstrState

 SUBROUTINE SD_CopyOtherState( SrcOtherStateData, DstOtherStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(SD_otherstatetype), INTENT(INOUT) :: SrcOtherStateData
   TYPE(SD_otherstatetype), INTENT(INOUT) :: DstOtherStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcOtherStateData%xdot)) THEN
   i1_l = LBOUND(SrcOtherStateData%xdot,1)
   i1_u = UBOUND(SrcOtherStateData%xdot,1)
   IF (.NOT. ALLOCATED(DstOtherStateData%xdot)) THEN 
      ALLOCATE(DstOtherStateData%xdot(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOtherStateData%xdot.', ErrStat, ErrMsg,'SD_CopyOtherState')
         RETURN
      END IF
   END IF
   DO i1 = LBOUND(SrcOtherStateData%xdot,1), UBOUND(SrcOtherStateData%xdot,1)
      CALL SD_CopyContState( SrcOtherStateData%xdot(i1), DstOtherStateData%xdot(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'SD_CopyOtherState:xdot(i1)')
         IF (ErrStat>=AbortErrLev) RETURN
   ENDDO
ENDIF
   DstOtherStateData%n = SrcOtherStateData%n
IF (ALLOCATED(SrcOtherStateData%SDWrOutput)) THEN
   i1_l = LBOUND(SrcOtherStateData%SDWrOutput,1)
   i1_u = UBOUND(SrcOtherStateData%SDWrOutput,1)
   IF (.NOT. ALLOCATED(DstOtherStateData%SDWrOutput)) THEN 
      ALLOCATE(DstOtherStateData%SDWrOutput(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOtherStateData%SDWrOutput.', ErrStat, ErrMsg,'SD_CopyOtherState')
         RETURN
      END IF
   END IF
   DstOtherStateData%SDWrOutput = SrcOtherStateData%SDWrOutput
ENDIF
   DstOtherStateData%LastOutTime = SrcOtherStateData%LastOutTime
   DstOtherStateData%Decimat = SrcOtherStateData%Decimat
IF (ALLOCATED(SrcOtherStateData%qmdotdot)) THEN
   i1_l = LBOUND(SrcOtherStateData%qmdotdot,1)
   i1_u = UBOUND(SrcOtherStateData%qmdotdot,1)
   IF (.NOT. ALLOCATED(DstOtherStateData%qmdotdot)) THEN 
      ALLOCATE(DstOtherStateData%qmdotdot(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOtherStateData%qmdotdot.', ErrStat, ErrMsg,'SD_CopyOtherState')
         RETURN
      END IF
   END IF
   DstOtherStateData%qmdotdot = SrcOtherStateData%qmdotdot
ENDIF
   DstOtherStateData%u_TP = SrcOtherStateData%u_TP
   DstOtherStateData%udot_TP = SrcOtherStateData%udot_TP
   DstOtherStateData%udotdot_TP = SrcOtherStateData%udotdot_TP
IF (ALLOCATED(SrcOtherStateData%UFL)) THEN
   i1_l = LBOUND(SrcOtherStateData%UFL,1)
   i1_u = UBOUND(SrcOtherStateData%UFL,1)
   IF (.NOT. ALLOCATED(DstOtherStateData%UFL)) THEN 
      ALLOCATE(DstOtherStateData%UFL(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOtherStateData%UFL.', ErrStat, ErrMsg,'SD_CopyOtherState')
         RETURN
      END IF
   END IF
   DstOtherStateData%UFL = SrcOtherStateData%UFL
ENDIF
IF (ALLOCATED(SrcOtherStateData%UR_bar)) THEN
   i1_l = LBOUND(SrcOtherStateData%UR_bar,1)
   i1_u = UBOUND(SrcOtherStateData%UR_bar,1)
   IF (.NOT. ALLOCATED(DstOtherStateData%UR_bar)) THEN 
      ALLOCATE(DstOtherStateData%UR_bar(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOtherStateData%UR_bar.', ErrStat, ErrMsg,'SD_CopyOtherState')
         RETURN
      END IF
   END IF
   DstOtherStateData%UR_bar = SrcOtherStateData%UR_bar
ENDIF
IF (ALLOCATED(SrcOtherStateData%UR_bar_dot)) THEN
   i1_l = LBOUND(SrcOtherStateData%UR_bar_dot,1)
   i1_u = UBOUND(SrcOtherStateData%UR_bar_dot,1)
   IF (.NOT. ALLOCATED(DstOtherStateData%UR_bar_dot)) THEN 
      ALLOCATE(DstOtherStateData%UR_bar_dot(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOtherStateData%UR_bar_dot.', ErrStat, ErrMsg,'SD_CopyOtherState')
         RETURN
      END IF
   END IF
   DstOtherStateData%UR_bar_dot = SrcOtherStateData%UR_bar_dot
ENDIF
IF (ALLOCATED(SrcOtherStateData%UR_bar_dotdot)) THEN
   i1_l = LBOUND(SrcOtherStateData%UR_bar_dotdot,1)
   i1_u = UBOUND(SrcOtherStateData%UR_bar_dotdot,1)
   IF (.NOT. ALLOCATED(DstOtherStateData%UR_bar_dotdot)) THEN 
      ALLOCATE(DstOtherStateData%UR_bar_dotdot(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOtherStateData%UR_bar_dotdot.', ErrStat, ErrMsg,'SD_CopyOtherState')
         RETURN
      END IF
   END IF
   DstOtherStateData%UR_bar_dotdot = SrcOtherStateData%UR_bar_dotdot
ENDIF
IF (ALLOCATED(SrcOtherStateData%UL)) THEN
   i1_l = LBOUND(SrcOtherStateData%UL,1)
   i1_u = UBOUND(SrcOtherStateData%UL,1)
   IF (.NOT. ALLOCATED(DstOtherStateData%UL)) THEN 
      ALLOCATE(DstOtherStateData%UL(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOtherStateData%UL.', ErrStat, ErrMsg,'SD_CopyOtherState')
         RETURN
      END IF
   END IF
   DstOtherStateData%UL = SrcOtherStateData%UL
ENDIF
IF (ALLOCATED(SrcOtherStateData%UL_dot)) THEN
   i1_l = LBOUND(SrcOtherStateData%UL_dot,1)
   i1_u = UBOUND(SrcOtherStateData%UL_dot,1)
   IF (.NOT. ALLOCATED(DstOtherStateData%UL_dot)) THEN 
      ALLOCATE(DstOtherStateData%UL_dot(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOtherStateData%UL_dot.', ErrStat, ErrMsg,'SD_CopyOtherState')
         RETURN
      END IF
   END IF
   DstOtherStateData%UL_dot = SrcOtherStateData%UL_dot
ENDIF
IF (ALLOCATED(SrcOtherStateData%UL_dotdot)) THEN
   i1_l = LBOUND(SrcOtherStateData%UL_dotdot,1)
   i1_u = UBOUND(SrcOtherStateData%UL_dotdot,1)
   IF (.NOT. ALLOCATED(DstOtherStateData%UL_dotdot)) THEN 
      ALLOCATE(DstOtherStateData%UL_dotdot(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOtherStateData%UL_dotdot.', ErrStat, ErrMsg,'SD_CopyOtherState')
         RETURN
      END IF
   END IF
   DstOtherStateData%UL_dotdot = SrcOtherStateData%UL_dotdot
ENDIF
 END SUBROUTINE SD_CopyOtherState

 SUBROUTINE SD_DestroyOtherState( OtherStateData, ErrStat, ErrMsg )
  TYPE(SD_otherstatetype), INTENT(INOUT) :: OtherStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(OtherStateData%xdot)) THEN
DO i1 = LBOUND(OtherStateData%xdot,1), UBOUND(OtherStateData%xdot,1)
  CALL SD_DestroyContState( OtherStateData%xdot(i1), ErrStat, ErrMsg )
ENDDO
   DEALLOCATE(OtherStateData%xdot)
ENDIF
IF (ALLOCATED(OtherStateData%SDWrOutput)) THEN
   DEALLOCATE(OtherStateData%SDWrOutput)
ENDIF
IF (ALLOCATED(OtherStateData%qmdotdot)) THEN
   DEALLOCATE(OtherStateData%qmdotdot)
ENDIF
IF (ALLOCATED(OtherStateData%UFL)) THEN
   DEALLOCATE(OtherStateData%UFL)
ENDIF
IF (ALLOCATED(OtherStateData%UR_bar)) THEN
   DEALLOCATE(OtherStateData%UR_bar)
ENDIF
IF (ALLOCATED(OtherStateData%UR_bar_dot)) THEN
   DEALLOCATE(OtherStateData%UR_bar_dot)
ENDIF
IF (ALLOCATED(OtherStateData%UR_bar_dotdot)) THEN
   DEALLOCATE(OtherStateData%UR_bar_dotdot)
ENDIF
IF (ALLOCATED(OtherStateData%UL)) THEN
   DEALLOCATE(OtherStateData%UL)
ENDIF
IF (ALLOCATED(OtherStateData%UL_dot)) THEN
   DEALLOCATE(OtherStateData%UL_dot)
ENDIF
IF (ALLOCATED(OtherStateData%UL_dotdot)) THEN
   DEALLOCATE(OtherStateData%UL_dotdot)
ENDIF
 END SUBROUTINE SD_DestroyOtherState

 SUBROUTINE SD_PackOtherState( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(SD_otherstatetype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_xdot_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_xdot_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_xdot_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
DO i1 = LBOUND(InData%xdot,1), UBOUND(InData%xdot,1)
  CALL SD_PackContState( Re_xdot_Buf, Db_xdot_Buf, Int_xdot_Buf, InData%xdot(i1), ErrStat, ErrMsg, .TRUE. ) ! xdot 
  IF(ALLOCATED(Re_xdot_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_xdot_Buf  ) ! xdot
  IF(ALLOCATED(Db_xdot_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_xdot_Buf  ) ! xdot
  IF(ALLOCATED(Int_xdot_Buf))Int_BufSz = Int_BufSz + SIZE( Int_xdot_Buf ) ! xdot
  IF(ALLOCATED(Re_xdot_Buf))  DEALLOCATE(Re_xdot_Buf)
  IF(ALLOCATED(Db_xdot_Buf))  DEALLOCATE(Db_xdot_Buf)
  IF(ALLOCATED(Int_xdot_Buf)) DEALLOCATE(Int_xdot_Buf)
ENDDO
  Int_BufSz  = Int_BufSz  + 1  ! n
  IF ( ALLOCATED(InData%SDWrOutput) )   Re_BufSz    = Re_BufSz    + SIZE( InData%SDWrOutput )  ! SDWrOutput 
  Db_BufSz   = Db_BufSz   + 1  ! LastOutTime
  Int_BufSz  = Int_BufSz  + 1  ! Decimat
  IF ( ALLOCATED(InData%qmdotdot) )   Re_BufSz    = Re_BufSz    + SIZE( InData%qmdotdot )  ! qmdotdot 
  Re_BufSz    = Re_BufSz    + SIZE( InData%u_TP )  ! u_TP 
  Re_BufSz    = Re_BufSz    + SIZE( InData%udot_TP )  ! udot_TP 
  Re_BufSz    = Re_BufSz    + SIZE( InData%udotdot_TP )  ! udotdot_TP 
  IF ( ALLOCATED(InData%UFL) )   Re_BufSz    = Re_BufSz    + SIZE( InData%UFL )  ! UFL 
  IF ( ALLOCATED(InData%UR_bar) )   Re_BufSz    = Re_BufSz    + SIZE( InData%UR_bar )  ! UR_bar 
  IF ( ALLOCATED(InData%UR_bar_dot) )   Re_BufSz    = Re_BufSz    + SIZE( InData%UR_bar_dot )  ! UR_bar_dot 
  IF ( ALLOCATED(InData%UR_bar_dotdot) )   Re_BufSz    = Re_BufSz    + SIZE( InData%UR_bar_dotdot )  ! UR_bar_dotdot 
  IF ( ALLOCATED(InData%UL) )   Re_BufSz    = Re_BufSz    + SIZE( InData%UL )  ! UL 
  IF ( ALLOCATED(InData%UL_dot) )   Re_BufSz    = Re_BufSz    + SIZE( InData%UL_dot )  ! UL_dot 
  IF ( ALLOCATED(InData%UL_dotdot) )   Re_BufSz    = Re_BufSz    + SIZE( InData%UL_dotdot )  ! UL_dotdot 
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
DO i1 = LBOUND(InData%xdot,1), UBOUND(InData%xdot,1)
  CALL SD_PackContState( Re_xdot_Buf, Db_xdot_Buf, Int_xdot_Buf, InData%xdot(i1), ErrStat, ErrMsg, OnlySize ) ! xdot 
  IF(ALLOCATED(Re_xdot_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_xdot_Buf)-1 ) = Re_xdot_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_xdot_Buf)
  ENDIF
  IF(ALLOCATED(Db_xdot_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_xdot_Buf)-1 ) = Db_xdot_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_xdot_Buf)
  ENDIF
  IF(ALLOCATED(Int_xdot_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_xdot_Buf)-1 ) = Int_xdot_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_xdot_Buf)
  ENDIF
  IF( ALLOCATED(Re_xdot_Buf) )  DEALLOCATE(Re_xdot_Buf)
  IF( ALLOCATED(Db_xdot_Buf) )  DEALLOCATE(Db_xdot_Buf)
  IF( ALLOCATED(Int_xdot_Buf) ) DEALLOCATE(Int_xdot_Buf)
ENDDO
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%n )
  Int_Xferred   = Int_Xferred   + 1
  IF ( ALLOCATED(InData%SDWrOutput) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%SDWrOutput))-1 ) =  PACK(InData%SDWrOutput ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%SDWrOutput)
  ENDIF
  IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(1)-1 ) =  (InData%LastOutTime )
  Db_Xferred   = Db_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%Decimat )
  Int_Xferred   = Int_Xferred   + 1
  IF ( ALLOCATED(InData%qmdotdot) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%qmdotdot))-1 ) =  PACK(InData%qmdotdot ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%qmdotdot)
  ENDIF
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%u_TP))-1 ) =  PACK(InData%u_TP ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%u_TP)
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%udot_TP))-1 ) =  PACK(InData%udot_TP ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%udot_TP)
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%udotdot_TP))-1 ) =  PACK(InData%udotdot_TP ,.TRUE.)
  Re_Xferred   = Re_Xferred   + SIZE(InData%udotdot_TP)
  IF ( ALLOCATED(InData%UFL) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%UFL))-1 ) =  PACK(InData%UFL ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%UFL)
  ENDIF
  IF ( ALLOCATED(InData%UR_bar) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%UR_bar))-1 ) =  PACK(InData%UR_bar ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%UR_bar)
  ENDIF
  IF ( ALLOCATED(InData%UR_bar_dot) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%UR_bar_dot))-1 ) =  PACK(InData%UR_bar_dot ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%UR_bar_dot)
  ENDIF
  IF ( ALLOCATED(InData%UR_bar_dotdot) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%UR_bar_dotdot))-1 ) =  PACK(InData%UR_bar_dotdot ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%UR_bar_dotdot)
  ENDIF
  IF ( ALLOCATED(InData%UL) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%UL))-1 ) =  PACK(InData%UL ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%UL)
  ENDIF
  IF ( ALLOCATED(InData%UL_dot) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%UL_dot))-1 ) =  PACK(InData%UL_dot ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%UL_dot)
  ENDIF
  IF ( ALLOCATED(InData%UL_dotdot) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%UL_dotdot))-1 ) =  PACK(InData%UL_dotdot ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%UL_dotdot)
  ENDIF
 END SUBROUTINE SD_PackOtherState

 SUBROUTINE SD_UnPackOtherState( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(SD_otherstatetype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_xdot_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_xdot_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_xdot_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
DO i1 = LBOUND(OutData%xdot,1), UBOUND(OutData%xdot,1)
 ! first call SD_PackContState to get correctly sized buffers for unpacking
  CALL SD_PackContState( Re_xdot_Buf, Db_xdot_Buf, Int_xdot_Buf, OutData%xdot(i1), ErrStat, ErrMsg, .TRUE. ) ! xdot 
  IF(ALLOCATED(Re_xdot_Buf)) THEN
    Re_xdot_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_xdot_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_xdot_Buf)
  ENDIF
  IF(ALLOCATED(Db_xdot_Buf)) THEN
    Db_xdot_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_xdot_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_xdot_Buf)
  ENDIF
  IF(ALLOCATED(Int_xdot_Buf)) THEN
    Int_xdot_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_xdot_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_xdot_Buf)
  ENDIF
  CALL SD_UnPackContState( Re_xdot_Buf, Db_xdot_Buf, Int_xdot_Buf, OutData%xdot(i1), ErrStat, ErrMsg ) ! xdot 
ENDDO
  OutData%n = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  IF ( ALLOCATED(OutData%SDWrOutput) ) THEN
  ALLOCATE(mask1(SIZE(OutData%SDWrOutput,1))); mask1 = .TRUE.
    OutData%SDWrOutput = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%SDWrOutput))-1 ),mask1,OutData%SDWrOutput)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%SDWrOutput)
  ENDIF
  OutData%LastOutTime = DbKiBuf ( Db_Xferred )
  Db_Xferred   = Db_Xferred   + 1
  OutData%Decimat = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  IF ( ALLOCATED(OutData%qmdotdot) ) THEN
  ALLOCATE(mask1(SIZE(OutData%qmdotdot,1))); mask1 = .TRUE.
    OutData%qmdotdot = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%qmdotdot))-1 ),mask1,OutData%qmdotdot)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%qmdotdot)
  ENDIF
  ALLOCATE(mask1(SIZE(OutData%u_TP,1))); mask1 = .TRUE.
  OutData%u_TP = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%u_TP))-1 ),mask1,OutData%u_TP)
  DEALLOCATE(mask1)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%u_TP)
  ALLOCATE(mask1(SIZE(OutData%udot_TP,1))); mask1 = .TRUE.
  OutData%udot_TP = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%udot_TP))-1 ),mask1,OutData%udot_TP)
  DEALLOCATE(mask1)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%udot_TP)
  ALLOCATE(mask1(SIZE(OutData%udotdot_TP,1))); mask1 = .TRUE.
  OutData%udotdot_TP = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%udotdot_TP))-1 ),mask1,OutData%udotdot_TP)
  DEALLOCATE(mask1)
  Re_Xferred   = Re_Xferred   + SIZE(OutData%udotdot_TP)
  IF ( ALLOCATED(OutData%UFL) ) THEN
  ALLOCATE(mask1(SIZE(OutData%UFL,1))); mask1 = .TRUE.
    OutData%UFL = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%UFL))-1 ),mask1,OutData%UFL)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%UFL)
  ENDIF
  IF ( ALLOCATED(OutData%UR_bar) ) THEN
  ALLOCATE(mask1(SIZE(OutData%UR_bar,1))); mask1 = .TRUE.
    OutData%UR_bar = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%UR_bar))-1 ),mask1,OutData%UR_bar)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%UR_bar)
  ENDIF
  IF ( ALLOCATED(OutData%UR_bar_dot) ) THEN
  ALLOCATE(mask1(SIZE(OutData%UR_bar_dot,1))); mask1 = .TRUE.
    OutData%UR_bar_dot = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%UR_bar_dot))-1 ),mask1,OutData%UR_bar_dot)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%UR_bar_dot)
  ENDIF
  IF ( ALLOCATED(OutData%UR_bar_dotdot) ) THEN
  ALLOCATE(mask1(SIZE(OutData%UR_bar_dotdot,1))); mask1 = .TRUE.
    OutData%UR_bar_dotdot = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%UR_bar_dotdot))-1 ),mask1,OutData%UR_bar_dotdot)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%UR_bar_dotdot)
  ENDIF
  IF ( ALLOCATED(OutData%UL) ) THEN
  ALLOCATE(mask1(SIZE(OutData%UL,1))); mask1 = .TRUE.
    OutData%UL = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%UL))-1 ),mask1,OutData%UL)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%UL)
  ENDIF
  IF ( ALLOCATED(OutData%UL_dot) ) THEN
  ALLOCATE(mask1(SIZE(OutData%UL_dot,1))); mask1 = .TRUE.
    OutData%UL_dot = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%UL_dot))-1 ),mask1,OutData%UL_dot)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%UL_dot)
  ENDIF
  IF ( ALLOCATED(OutData%UL_dotdot) ) THEN
  ALLOCATE(mask1(SIZE(OutData%UL_dotdot,1))); mask1 = .TRUE.
    OutData%UL_dotdot = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%UL_dotdot))-1 ),mask1,OutData%UL_dotdot)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%UL_dotdot)
  ENDIF
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE SD_UnPackOtherState

 SUBROUTINE SD_CopyParam( SrcParamData, DstParamData, CtrlCode, ErrStat, ErrMsg )
   TYPE(SD_parametertype), INTENT(INOUT) :: SrcParamData
   TYPE(SD_parametertype), INTENT(INOUT) :: DstParamData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
   DstParamData%SDDeltaT = SrcParamData%SDDeltaT
   DstParamData%SttcSolve = SrcParamData%SttcSolve
IF (ALLOCATED(SrcParamData%NOmegaM2)) THEN
   i1_l = LBOUND(SrcParamData%NOmegaM2,1)
   i1_u = UBOUND(SrcParamData%NOmegaM2,1)
   IF (.NOT. ALLOCATED(DstParamData%NOmegaM2)) THEN 
      ALLOCATE(DstParamData%NOmegaM2(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%NOmegaM2.', ErrStat, ErrMsg,'SD_CopyParam')
         RETURN
      END IF
   END IF
   DstParamData%NOmegaM2 = SrcParamData%NOmegaM2
ENDIF
IF (ALLOCATED(SrcParamData%N2OmegaMJDamp)) THEN
   i1_l = LBOUND(SrcParamData%N2OmegaMJDamp,1)
   i1_u = UBOUND(SrcParamData%N2OmegaMJDamp,1)
   IF (.NOT. ALLOCATED(DstParamData%N2OmegaMJDamp)) THEN 
      ALLOCATE(DstParamData%N2OmegaMJDamp(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%N2OmegaMJDamp.', ErrStat, ErrMsg,'SD_CopyParam')
         RETURN
      END IF
   END IF
   DstParamData%N2OmegaMJDamp = SrcParamData%N2OmegaMJDamp
ENDIF
IF (ALLOCATED(SrcParamData%MMB)) THEN
   i1_l = LBOUND(SrcParamData%MMB,1)
   i1_u = UBOUND(SrcParamData%MMB,1)
   i2_l = LBOUND(SrcParamData%MMB,2)
   i2_u = UBOUND(SrcParamData%MMB,2)
   IF (.NOT. ALLOCATED(DstParamData%MMB)) THEN 
      ALLOCATE(DstParamData%MMB(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%MMB.', ErrStat, ErrMsg,'SD_CopyParam')
         RETURN
      END IF
   END IF
   DstParamData%MMB = SrcParamData%MMB
ENDIF
IF (ALLOCATED(SrcParamData%PhiM_T)) THEN
   i1_l = LBOUND(SrcParamData%PhiM_T,1)
   i1_u = UBOUND(SrcParamData%PhiM_T,1)
   i2_l = LBOUND(SrcParamData%PhiM_T,2)
   i2_u = UBOUND(SrcParamData%PhiM_T,2)
   IF (.NOT. ALLOCATED(DstParamData%PhiM_T)) THEN 
      ALLOCATE(DstParamData%PhiM_T(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%PhiM_T.', ErrStat, ErrMsg,'SD_CopyParam')
         RETURN
      END IF
   END IF
   DstParamData%PhiM_T = SrcParamData%PhiM_T
ENDIF
IF (ALLOCATED(SrcParamData%FX)) THEN
   i1_l = LBOUND(SrcParamData%FX,1)
   i1_u = UBOUND(SrcParamData%FX,1)
   IF (.NOT. ALLOCATED(DstParamData%FX)) THEN 
      ALLOCATE(DstParamData%FX(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%FX.', ErrStat, ErrMsg,'SD_CopyParam')
         RETURN
      END IF
   END IF
   DstParamData%FX = SrcParamData%FX
ENDIF
IF (ALLOCATED(SrcParamData%C1_11)) THEN
   i1_l = LBOUND(SrcParamData%C1_11,1)
   i1_u = UBOUND(SrcParamData%C1_11,1)
   i2_l = LBOUND(SrcParamData%C1_11,2)
   i2_u = UBOUND(SrcParamData%C1_11,2)
   IF (.NOT. ALLOCATED(DstParamData%C1_11)) THEN 
      ALLOCATE(DstParamData%C1_11(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%C1_11.', ErrStat, ErrMsg,'SD_CopyParam')
         RETURN
      END IF
   END IF
   DstParamData%C1_11 = SrcParamData%C1_11
ENDIF
IF (ALLOCATED(SrcParamData%C1_12)) THEN
   i1_l = LBOUND(SrcParamData%C1_12,1)
   i1_u = UBOUND(SrcParamData%C1_12,1)
   i2_l = LBOUND(SrcParamData%C1_12,2)
   i2_u = UBOUND(SrcParamData%C1_12,2)
   IF (.NOT. ALLOCATED(DstParamData%C1_12)) THEN 
      ALLOCATE(DstParamData%C1_12(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%C1_12.', ErrStat, ErrMsg,'SD_CopyParam')
         RETURN
      END IF
   END IF
   DstParamData%C1_12 = SrcParamData%C1_12
ENDIF
IF (ALLOCATED(SrcParamData%D1_13)) THEN
   i1_l = LBOUND(SrcParamData%D1_13,1)
   i1_u = UBOUND(SrcParamData%D1_13,1)
   i2_l = LBOUND(SrcParamData%D1_13,2)
   i2_u = UBOUND(SrcParamData%D1_13,2)
   IF (.NOT. ALLOCATED(DstParamData%D1_13)) THEN 
      ALLOCATE(DstParamData%D1_13(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%D1_13.', ErrStat, ErrMsg,'SD_CopyParam')
         RETURN
      END IF
   END IF
   DstParamData%D1_13 = SrcParamData%D1_13
ENDIF
IF (ALLOCATED(SrcParamData%D1_14)) THEN
   i1_l = LBOUND(SrcParamData%D1_14,1)
   i1_u = UBOUND(SrcParamData%D1_14,1)
   i2_l = LBOUND(SrcParamData%D1_14,2)
   i2_u = UBOUND(SrcParamData%D1_14,2)
   IF (.NOT. ALLOCATED(DstParamData%D1_14)) THEN 
      ALLOCATE(DstParamData%D1_14(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%D1_14.', ErrStat, ErrMsg,'SD_CopyParam')
         RETURN
      END IF
   END IF
   DstParamData%D1_14 = SrcParamData%D1_14
ENDIF
IF (ALLOCATED(SrcParamData%D1_15)) THEN
   i1_l = LBOUND(SrcParamData%D1_15,1)
   i1_u = UBOUND(SrcParamData%D1_15,1)
   i2_l = LBOUND(SrcParamData%D1_15,2)
   i2_u = UBOUND(SrcParamData%D1_15,2)
   IF (.NOT. ALLOCATED(DstParamData%D1_15)) THEN 
      ALLOCATE(DstParamData%D1_15(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%D1_15.', ErrStat, ErrMsg,'SD_CopyParam')
         RETURN
      END IF
   END IF
   DstParamData%D1_15 = SrcParamData%D1_15
ENDIF
IF (ALLOCATED(SrcParamData%FY)) THEN
   i1_l = LBOUND(SrcParamData%FY,1)
   i1_u = UBOUND(SrcParamData%FY,1)
   IF (.NOT. ALLOCATED(DstParamData%FY)) THEN 
      ALLOCATE(DstParamData%FY(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%FY.', ErrStat, ErrMsg,'SD_CopyParam')
         RETURN
      END IF
   END IF
   DstParamData%FY = SrcParamData%FY
ENDIF
IF (ALLOCATED(SrcParamData%PhiM)) THEN
   i1_l = LBOUND(SrcParamData%PhiM,1)
   i1_u = UBOUND(SrcParamData%PhiM,1)
   i2_l = LBOUND(SrcParamData%PhiM,2)
   i2_u = UBOUND(SrcParamData%PhiM,2)
   IF (.NOT. ALLOCATED(DstParamData%PhiM)) THEN 
      ALLOCATE(DstParamData%PhiM(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%PhiM.', ErrStat, ErrMsg,'SD_CopyParam')
         RETURN
      END IF
   END IF
   DstParamData%PhiM = SrcParamData%PhiM
ENDIF
IF (ALLOCATED(SrcParamData%C2_61)) THEN
   i1_l = LBOUND(SrcParamData%C2_61,1)
   i1_u = UBOUND(SrcParamData%C2_61,1)
   i2_l = LBOUND(SrcParamData%C2_61,2)
   i2_u = UBOUND(SrcParamData%C2_61,2)
   IF (.NOT. ALLOCATED(DstParamData%C2_61)) THEN 
      ALLOCATE(DstParamData%C2_61(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%C2_61.', ErrStat, ErrMsg,'SD_CopyParam')
         RETURN
      END IF
   END IF
   DstParamData%C2_61 = SrcParamData%C2_61
ENDIF
IF (ALLOCATED(SrcParamData%C2_62)) THEN
   i1_l = LBOUND(SrcParamData%C2_62,1)
   i1_u = UBOUND(SrcParamData%C2_62,1)
   i2_l = LBOUND(SrcParamData%C2_62,2)
   i2_u = UBOUND(SrcParamData%C2_62,2)
   IF (.NOT. ALLOCATED(DstParamData%C2_62)) THEN 
      ALLOCATE(DstParamData%C2_62(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%C2_62.', ErrStat, ErrMsg,'SD_CopyParam')
         RETURN
      END IF
   END IF
   DstParamData%C2_62 = SrcParamData%C2_62
ENDIF
IF (ALLOCATED(SrcParamData%PhiRb_TI)) THEN
   i1_l = LBOUND(SrcParamData%PhiRb_TI,1)
   i1_u = UBOUND(SrcParamData%PhiRb_TI,1)
   i2_l = LBOUND(SrcParamData%PhiRb_TI,2)
   i2_u = UBOUND(SrcParamData%PhiRb_TI,2)
   IF (.NOT. ALLOCATED(DstParamData%PhiRb_TI)) THEN 
      ALLOCATE(DstParamData%PhiRb_TI(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%PhiRb_TI.', ErrStat, ErrMsg,'SD_CopyParam')
         RETURN
      END IF
   END IF
   DstParamData%PhiRb_TI = SrcParamData%PhiRb_TI
ENDIF
IF (ALLOCATED(SrcParamData%D2_63)) THEN
   i1_l = LBOUND(SrcParamData%D2_63,1)
   i1_u = UBOUND(SrcParamData%D2_63,1)
   i2_l = LBOUND(SrcParamData%D2_63,2)
   i2_u = UBOUND(SrcParamData%D2_63,2)
   IF (.NOT. ALLOCATED(DstParamData%D2_63)) THEN 
      ALLOCATE(DstParamData%D2_63(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%D2_63.', ErrStat, ErrMsg,'SD_CopyParam')
         RETURN
      END IF
   END IF
   DstParamData%D2_63 = SrcParamData%D2_63
ENDIF
IF (ALLOCATED(SrcParamData%D2_64)) THEN
   i1_l = LBOUND(SrcParamData%D2_64,1)
   i1_u = UBOUND(SrcParamData%D2_64,1)
   i2_l = LBOUND(SrcParamData%D2_64,2)
   i2_u = UBOUND(SrcParamData%D2_64,2)
   IF (.NOT. ALLOCATED(DstParamData%D2_64)) THEN 
      ALLOCATE(DstParamData%D2_64(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%D2_64.', ErrStat, ErrMsg,'SD_CopyParam')
         RETURN
      END IF
   END IF
   DstParamData%D2_64 = SrcParamData%D2_64
ENDIF
IF (ALLOCATED(SrcParamData%F2_61)) THEN
   i1_l = LBOUND(SrcParamData%F2_61,1)
   i1_u = UBOUND(SrcParamData%F2_61,1)
   IF (.NOT. ALLOCATED(DstParamData%F2_61)) THEN 
      ALLOCATE(DstParamData%F2_61(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%F2_61.', ErrStat, ErrMsg,'SD_CopyParam')
         RETURN
      END IF
   END IF
   DstParamData%F2_61 = SrcParamData%F2_61
ENDIF
IF (ALLOCATED(SrcParamData%MBB)) THEN
   i1_l = LBOUND(SrcParamData%MBB,1)
   i1_u = UBOUND(SrcParamData%MBB,1)
   i2_l = LBOUND(SrcParamData%MBB,2)
   i2_u = UBOUND(SrcParamData%MBB,2)
   IF (.NOT. ALLOCATED(DstParamData%MBB)) THEN 
      ALLOCATE(DstParamData%MBB(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%MBB.', ErrStat, ErrMsg,'SD_CopyParam')
         RETURN
      END IF
   END IF
   DstParamData%MBB = SrcParamData%MBB
ENDIF
IF (ALLOCATED(SrcParamData%KBB)) THEN
   i1_l = LBOUND(SrcParamData%KBB,1)
   i1_u = UBOUND(SrcParamData%KBB,1)
   i2_l = LBOUND(SrcParamData%KBB,2)
   i2_u = UBOUND(SrcParamData%KBB,2)
   IF (.NOT. ALLOCATED(DstParamData%KBB)) THEN 
      ALLOCATE(DstParamData%KBB(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%KBB.', ErrStat, ErrMsg,'SD_CopyParam')
         RETURN
      END IF
   END IF
   DstParamData%KBB = SrcParamData%KBB
ENDIF
IF (ALLOCATED(SrcParamData%MBM)) THEN
   i1_l = LBOUND(SrcParamData%MBM,1)
   i1_u = UBOUND(SrcParamData%MBM,1)
   i2_l = LBOUND(SrcParamData%MBM,2)
   i2_u = UBOUND(SrcParamData%MBM,2)
   IF (.NOT. ALLOCATED(DstParamData%MBM)) THEN 
      ALLOCATE(DstParamData%MBM(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%MBM.', ErrStat, ErrMsg,'SD_CopyParam')
         RETURN
      END IF
   END IF
   DstParamData%MBM = SrcParamData%MBM
ENDIF
IF (ALLOCATED(SrcParamData%PhiL_T)) THEN
   i1_l = LBOUND(SrcParamData%PhiL_T,1)
   i1_u = UBOUND(SrcParamData%PhiL_T,1)
   i2_l = LBOUND(SrcParamData%PhiL_T,2)
   i2_u = UBOUND(SrcParamData%PhiL_T,2)
   IF (.NOT. ALLOCATED(DstParamData%PhiL_T)) THEN 
      ALLOCATE(DstParamData%PhiL_T(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%PhiL_T.', ErrStat, ErrMsg,'SD_CopyParam')
         RETURN
      END IF
   END IF
   DstParamData%PhiL_T = SrcParamData%PhiL_T
ENDIF
IF (ALLOCATED(SrcParamData%PhiLInvOmgL2)) THEN
   i1_l = LBOUND(SrcParamData%PhiLInvOmgL2,1)
   i1_u = UBOUND(SrcParamData%PhiLInvOmgL2,1)
   i2_l = LBOUND(SrcParamData%PhiLInvOmgL2,2)
   i2_u = UBOUND(SrcParamData%PhiLInvOmgL2,2)
   IF (.NOT. ALLOCATED(DstParamData%PhiLInvOmgL2)) THEN 
      ALLOCATE(DstParamData%PhiLInvOmgL2(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%PhiLInvOmgL2.', ErrStat, ErrMsg,'SD_CopyParam')
         RETURN
      END IF
   END IF
   DstParamData%PhiLInvOmgL2 = SrcParamData%PhiLInvOmgL2
ENDIF
IF (ALLOCATED(SrcParamData%FGL)) THEN
   i1_l = LBOUND(SrcParamData%FGL,1)
   i1_u = UBOUND(SrcParamData%FGL,1)
   IF (.NOT. ALLOCATED(DstParamData%FGL)) THEN 
      ALLOCATE(DstParamData%FGL(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%FGL.', ErrStat, ErrMsg,'SD_CopyParam')
         RETURN
      END IF
   END IF
   DstParamData%FGL = SrcParamData%FGL
ENDIF
IF (ALLOCATED(SrcParamData%AM2Jac)) THEN
   i1_l = LBOUND(SrcParamData%AM2Jac,1)
   i1_u = UBOUND(SrcParamData%AM2Jac,1)
   i2_l = LBOUND(SrcParamData%AM2Jac,2)
   i2_u = UBOUND(SrcParamData%AM2Jac,2)
   IF (.NOT. ALLOCATED(DstParamData%AM2Jac)) THEN 
      ALLOCATE(DstParamData%AM2Jac(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%AM2Jac.', ErrStat, ErrMsg,'SD_CopyParam')
         RETURN
      END IF
   END IF
   DstParamData%AM2Jac = SrcParamData%AM2Jac
ENDIF
IF (ALLOCATED(SrcParamData%AM2JacPiv)) THEN
   i1_l = LBOUND(SrcParamData%AM2JacPiv,1)
   i1_u = UBOUND(SrcParamData%AM2JacPiv,1)
   IF (.NOT. ALLOCATED(DstParamData%AM2JacPiv)) THEN 
      ALLOCATE(DstParamData%AM2JacPiv(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%AM2JacPiv.', ErrStat, ErrMsg,'SD_CopyParam')
         RETURN
      END IF
   END IF
   DstParamData%AM2JacPiv = SrcParamData%AM2JacPiv
ENDIF
IF (ALLOCATED(SrcParamData%TI)) THEN
   i1_l = LBOUND(SrcParamData%TI,1)
   i1_u = UBOUND(SrcParamData%TI,1)
   i2_l = LBOUND(SrcParamData%TI,2)
   i2_u = UBOUND(SrcParamData%TI,2)
   IF (.NOT. ALLOCATED(DstParamData%TI)) THEN 
      ALLOCATE(DstParamData%TI(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%TI.', ErrStat, ErrMsg,'SD_CopyParam')
         RETURN
      END IF
   END IF
   DstParamData%TI = SrcParamData%TI
ENDIF
IF (ALLOCATED(SrcParamData%TIreact)) THEN
   i1_l = LBOUND(SrcParamData%TIreact,1)
   i1_u = UBOUND(SrcParamData%TIreact,1)
   i2_l = LBOUND(SrcParamData%TIreact,2)
   i2_u = UBOUND(SrcParamData%TIreact,2)
   IF (.NOT. ALLOCATED(DstParamData%TIreact)) THEN 
      ALLOCATE(DstParamData%TIreact(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%TIreact.', ErrStat, ErrMsg,'SD_CopyParam')
         RETURN
      END IF
   END IF
   DstParamData%TIreact = SrcParamData%TIreact
ENDIF
   DstParamData%NModes = SrcParamData%NModes
IF (ALLOCATED(SrcParamData%Elems)) THEN
   i1_l = LBOUND(SrcParamData%Elems,1)
   i1_u = UBOUND(SrcParamData%Elems,1)
   i2_l = LBOUND(SrcParamData%Elems,2)
   i2_u = UBOUND(SrcParamData%Elems,2)
   IF (.NOT. ALLOCATED(DstParamData%Elems)) THEN 
      ALLOCATE(DstParamData%Elems(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%Elems.', ErrStat, ErrMsg,'SD_CopyParam')
         RETURN
      END IF
   END IF
   DstParamData%Elems = SrcParamData%Elems
ENDIF
   DstParamData%qmL = SrcParamData%qmL
   DstParamData%DofL = SrcParamData%DofL
   DstParamData%NNodes_I = SrcParamData%NNodes_I
   DstParamData%NNodes_L = SrcParamData%NNodes_L
   DstParamData%NNodes_RbarL = SrcParamData%NNodes_RbarL
   DstParamData%DofI = SrcParamData%DofI
   DstParamData%DofR = SrcParamData%DofR
   DstParamData%DofC = SrcParamData%DofC
   DstParamData%NReact = SrcParamData%NReact
IF (ALLOCATED(SrcParamData%Reacts)) THEN
   i1_l = LBOUND(SrcParamData%Reacts,1)
   i1_u = UBOUND(SrcParamData%Reacts,1)
   i2_l = LBOUND(SrcParamData%Reacts,2)
   i2_u = UBOUND(SrcParamData%Reacts,2)
   IF (.NOT. ALLOCATED(DstParamData%Reacts)) THEN 
      ALLOCATE(DstParamData%Reacts(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%Reacts.', ErrStat, ErrMsg,'SD_CopyParam')
         RETURN
      END IF
   END IF
   DstParamData%Reacts = SrcParamData%Reacts
ENDIF
   DstParamData%Nmembers = SrcParamData%Nmembers
   DstParamData%URbarL = SrcParamData%URbarL
   DstParamData%IntMethod = SrcParamData%IntMethod
   DstParamData%NAvgEls = SrcParamData%NAvgEls
IF (ALLOCATED(SrcParamData%IDI)) THEN
   i1_l = LBOUND(SrcParamData%IDI,1)
   i1_u = UBOUND(SrcParamData%IDI,1)
   IF (.NOT. ALLOCATED(DstParamData%IDI)) THEN 
      ALLOCATE(DstParamData%IDI(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%IDI.', ErrStat, ErrMsg,'SD_CopyParam')
         RETURN
      END IF
   END IF
   DstParamData%IDI = SrcParamData%IDI
ENDIF
IF (ALLOCATED(SrcParamData%IDR)) THEN
   i1_l = LBOUND(SrcParamData%IDR,1)
   i1_u = UBOUND(SrcParamData%IDR,1)
   IF (.NOT. ALLOCATED(DstParamData%IDR)) THEN 
      ALLOCATE(DstParamData%IDR(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%IDR.', ErrStat, ErrMsg,'SD_CopyParam')
         RETURN
      END IF
   END IF
   DstParamData%IDR = SrcParamData%IDR
ENDIF
IF (ALLOCATED(SrcParamData%IDL)) THEN
   i1_l = LBOUND(SrcParamData%IDL,1)
   i1_u = UBOUND(SrcParamData%IDL,1)
   IF (.NOT. ALLOCATED(DstParamData%IDL)) THEN 
      ALLOCATE(DstParamData%IDL(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%IDL.', ErrStat, ErrMsg,'SD_CopyParam')
         RETURN
      END IF
   END IF
   DstParamData%IDL = SrcParamData%IDL
ENDIF
IF (ALLOCATED(SrcParamData%IDC)) THEN
   i1_l = LBOUND(SrcParamData%IDC,1)
   i1_u = UBOUND(SrcParamData%IDC,1)
   IF (.NOT. ALLOCATED(DstParamData%IDC)) THEN 
      ALLOCATE(DstParamData%IDC(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%IDC.', ErrStat, ErrMsg,'SD_CopyParam')
         RETURN
      END IF
   END IF
   DstParamData%IDC = SrcParamData%IDC
ENDIF
IF (ALLOCATED(SrcParamData%IDY)) THEN
   i1_l = LBOUND(SrcParamData%IDY,1)
   i1_u = UBOUND(SrcParamData%IDY,1)
   IF (.NOT. ALLOCATED(DstParamData%IDY)) THEN 
      ALLOCATE(DstParamData%IDY(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%IDY.', ErrStat, ErrMsg,'SD_CopyParam')
         RETURN
      END IF
   END IF
   DstParamData%IDY = SrcParamData%IDY
ENDIF
   DstParamData%NMOutputs = SrcParamData%NMOutputs
   DstParamData%NumOuts = SrcParamData%NumOuts
   DstParamData%OutSwtch = SrcParamData%OutSwtch
   DstParamData%UnJckF = SrcParamData%UnJckF
   DstParamData%Delim = SrcParamData%Delim
   DstParamData%OutFmt = SrcParamData%OutFmt
   DstParamData%OutSFmt = SrcParamData%OutSFmt
IF (ALLOCATED(SrcParamData%MoutLst)) THEN
   i1_l = LBOUND(SrcParamData%MoutLst,1)
   i1_u = UBOUND(SrcParamData%MoutLst,1)
   IF (.NOT. ALLOCATED(DstParamData%MoutLst)) THEN 
      ALLOCATE(DstParamData%MoutLst(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%MoutLst.', ErrStat, ErrMsg,'SD_CopyParam')
         RETURN
      END IF
   END IF
   DO i1 = LBOUND(SrcParamData%MoutLst,1), UBOUND(SrcParamData%MoutLst,1)
      CALL SD_Copymeshauxdatatype( SrcParamData%MoutLst(i1), DstParamData%MoutLst(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'SD_CopyParam:MoutLst(i1)')
         IF (ErrStat>=AbortErrLev) RETURN
   ENDDO
ENDIF
IF (ALLOCATED(SrcParamData%MoutLst2)) THEN
   i1_l = LBOUND(SrcParamData%MoutLst2,1)
   i1_u = UBOUND(SrcParamData%MoutLst2,1)
   IF (.NOT. ALLOCATED(DstParamData%MoutLst2)) THEN 
      ALLOCATE(DstParamData%MoutLst2(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%MoutLst2.', ErrStat, ErrMsg,'SD_CopyParam')
         RETURN
      END IF
   END IF
   DO i1 = LBOUND(SrcParamData%MoutLst2,1), UBOUND(SrcParamData%MoutLst2,1)
      CALL SD_Copymeshauxdatatype( SrcParamData%MoutLst2(i1), DstParamData%MoutLst2(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'SD_CopyParam:MoutLst2(i1)')
         IF (ErrStat>=AbortErrLev) RETURN
   ENDDO
ENDIF
IF (ALLOCATED(SrcParamData%MoutLst3)) THEN
   i1_l = LBOUND(SrcParamData%MoutLst3,1)
   i1_u = UBOUND(SrcParamData%MoutLst3,1)
   IF (.NOT. ALLOCATED(DstParamData%MoutLst3)) THEN 
      ALLOCATE(DstParamData%MoutLst3(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%MoutLst3.', ErrStat, ErrMsg,'SD_CopyParam')
         RETURN
      END IF
   END IF
   DO i1 = LBOUND(SrcParamData%MoutLst3,1), UBOUND(SrcParamData%MoutLst3,1)
      CALL SD_Copymeshauxdatatype( SrcParamData%MoutLst3(i1), DstParamData%MoutLst3(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'SD_CopyParam:MoutLst3(i1)')
         IF (ErrStat>=AbortErrLev) RETURN
   ENDDO
ENDIF
IF (ALLOCATED(SrcParamData%ElemProps)) THEN
   i1_l = LBOUND(SrcParamData%ElemProps,1)
   i1_u = UBOUND(SrcParamData%ElemProps,1)
   IF (.NOT. ALLOCATED(DstParamData%ElemProps)) THEN 
      ALLOCATE(DstParamData%ElemProps(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%ElemProps.', ErrStat, ErrMsg,'SD_CopyParam')
         RETURN
      END IF
   END IF
   DO i1 = LBOUND(SrcParamData%ElemProps,1), UBOUND(SrcParamData%ElemProps,1)
      CALL SD_Copyelemproptype( SrcParamData%ElemProps(i1), DstParamData%ElemProps(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'SD_CopyParam:ElemProps(i1)')
         IF (ErrStat>=AbortErrLev) RETURN
   ENDDO
ENDIF
IF (ALLOCATED(SrcParamData%OutParam)) THEN
   i1_l = LBOUND(SrcParamData%OutParam,1)
   i1_u = UBOUND(SrcParamData%OutParam,1)
   IF (.NOT. ALLOCATED(DstParamData%OutParam)) THEN 
      ALLOCATE(DstParamData%OutParam(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%OutParam.', ErrStat, ErrMsg,'SD_CopyParam')
         RETURN
      END IF
   END IF
   DO i1 = LBOUND(SrcParamData%OutParam,1), UBOUND(SrcParamData%OutParam,1)
      CALL NWTC_Library_Copyoutparmtype( SrcParamData%OutParam(i1), DstParamData%OutParam(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'SD_CopyParam:OutParam(i1)')
         IF (ErrStat>=AbortErrLev) RETURN
   ENDDO
ENDIF
   DstParamData%OutAll = SrcParamData%OutAll
   DstParamData%OutReact = SrcParamData%OutReact
   DstParamData%OutAllInt = SrcParamData%OutAllInt
   DstParamData%OutAllDims = SrcParamData%OutAllDims
   DstParamData%OutDec = SrcParamData%OutDec
 END SUBROUTINE SD_CopyParam

 SUBROUTINE SD_DestroyParam( ParamData, ErrStat, ErrMsg )
  TYPE(SD_parametertype), INTENT(INOUT) :: ParamData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(ParamData%NOmegaM2)) THEN
   DEALLOCATE(ParamData%NOmegaM2)
ENDIF
IF (ALLOCATED(ParamData%N2OmegaMJDamp)) THEN
   DEALLOCATE(ParamData%N2OmegaMJDamp)
ENDIF
IF (ALLOCATED(ParamData%MMB)) THEN
   DEALLOCATE(ParamData%MMB)
ENDIF
IF (ALLOCATED(ParamData%PhiM_T)) THEN
   DEALLOCATE(ParamData%PhiM_T)
ENDIF
IF (ALLOCATED(ParamData%FX)) THEN
   DEALLOCATE(ParamData%FX)
ENDIF
IF (ALLOCATED(ParamData%C1_11)) THEN
   DEALLOCATE(ParamData%C1_11)
ENDIF
IF (ALLOCATED(ParamData%C1_12)) THEN
   DEALLOCATE(ParamData%C1_12)
ENDIF
IF (ALLOCATED(ParamData%D1_13)) THEN
   DEALLOCATE(ParamData%D1_13)
ENDIF
IF (ALLOCATED(ParamData%D1_14)) THEN
   DEALLOCATE(ParamData%D1_14)
ENDIF
IF (ALLOCATED(ParamData%D1_15)) THEN
   DEALLOCATE(ParamData%D1_15)
ENDIF
IF (ALLOCATED(ParamData%FY)) THEN
   DEALLOCATE(ParamData%FY)
ENDIF
IF (ALLOCATED(ParamData%PhiM)) THEN
   DEALLOCATE(ParamData%PhiM)
ENDIF
IF (ALLOCATED(ParamData%C2_61)) THEN
   DEALLOCATE(ParamData%C2_61)
ENDIF
IF (ALLOCATED(ParamData%C2_62)) THEN
   DEALLOCATE(ParamData%C2_62)
ENDIF
IF (ALLOCATED(ParamData%PhiRb_TI)) THEN
   DEALLOCATE(ParamData%PhiRb_TI)
ENDIF
IF (ALLOCATED(ParamData%D2_63)) THEN
   DEALLOCATE(ParamData%D2_63)
ENDIF
IF (ALLOCATED(ParamData%D2_64)) THEN
   DEALLOCATE(ParamData%D2_64)
ENDIF
IF (ALLOCATED(ParamData%F2_61)) THEN
   DEALLOCATE(ParamData%F2_61)
ENDIF
IF (ALLOCATED(ParamData%MBB)) THEN
   DEALLOCATE(ParamData%MBB)
ENDIF
IF (ALLOCATED(ParamData%KBB)) THEN
   DEALLOCATE(ParamData%KBB)
ENDIF
IF (ALLOCATED(ParamData%MBM)) THEN
   DEALLOCATE(ParamData%MBM)
ENDIF
IF (ALLOCATED(ParamData%PhiL_T)) THEN
   DEALLOCATE(ParamData%PhiL_T)
ENDIF
IF (ALLOCATED(ParamData%PhiLInvOmgL2)) THEN
   DEALLOCATE(ParamData%PhiLInvOmgL2)
ENDIF
IF (ALLOCATED(ParamData%FGL)) THEN
   DEALLOCATE(ParamData%FGL)
ENDIF
IF (ALLOCATED(ParamData%AM2Jac)) THEN
   DEALLOCATE(ParamData%AM2Jac)
ENDIF
IF (ALLOCATED(ParamData%AM2JacPiv)) THEN
   DEALLOCATE(ParamData%AM2JacPiv)
ENDIF
IF (ALLOCATED(ParamData%TI)) THEN
   DEALLOCATE(ParamData%TI)
ENDIF
IF (ALLOCATED(ParamData%TIreact)) THEN
   DEALLOCATE(ParamData%TIreact)
ENDIF
IF (ALLOCATED(ParamData%Elems)) THEN
   DEALLOCATE(ParamData%Elems)
ENDIF
IF (ALLOCATED(ParamData%Reacts)) THEN
   DEALLOCATE(ParamData%Reacts)
ENDIF
IF (ALLOCATED(ParamData%IDI)) THEN
   DEALLOCATE(ParamData%IDI)
ENDIF
IF (ALLOCATED(ParamData%IDR)) THEN
   DEALLOCATE(ParamData%IDR)
ENDIF
IF (ALLOCATED(ParamData%IDL)) THEN
   DEALLOCATE(ParamData%IDL)
ENDIF
IF (ALLOCATED(ParamData%IDC)) THEN
   DEALLOCATE(ParamData%IDC)
ENDIF
IF (ALLOCATED(ParamData%IDY)) THEN
   DEALLOCATE(ParamData%IDY)
ENDIF
IF (ALLOCATED(ParamData%MoutLst)) THEN
DO i1 = LBOUND(ParamData%MoutLst,1), UBOUND(ParamData%MoutLst,1)
  CALL SD_Destroymeshauxdatatype( ParamData%MoutLst(i1), ErrStat, ErrMsg )
ENDDO
   DEALLOCATE(ParamData%MoutLst)
ENDIF
IF (ALLOCATED(ParamData%MoutLst2)) THEN
DO i1 = LBOUND(ParamData%MoutLst2,1), UBOUND(ParamData%MoutLst2,1)
  CALL SD_Destroymeshauxdatatype( ParamData%MoutLst2(i1), ErrStat, ErrMsg )
ENDDO
   DEALLOCATE(ParamData%MoutLst2)
ENDIF
IF (ALLOCATED(ParamData%MoutLst3)) THEN
DO i1 = LBOUND(ParamData%MoutLst3,1), UBOUND(ParamData%MoutLst3,1)
  CALL SD_Destroymeshauxdatatype( ParamData%MoutLst3(i1), ErrStat, ErrMsg )
ENDDO
   DEALLOCATE(ParamData%MoutLst3)
ENDIF
IF (ALLOCATED(ParamData%ElemProps)) THEN
DO i1 = LBOUND(ParamData%ElemProps,1), UBOUND(ParamData%ElemProps,1)
  CALL SD_Destroyelemproptype( ParamData%ElemProps(i1), ErrStat, ErrMsg )
ENDDO
   DEALLOCATE(ParamData%ElemProps)
ENDIF
IF (ALLOCATED(ParamData%OutParam)) THEN
DO i1 = LBOUND(ParamData%OutParam,1), UBOUND(ParamData%OutParam,1)
  CALL NWTC_Library_Destroyoutparmtype( ParamData%OutParam(i1), ErrStat, ErrMsg )
ENDDO
   DEALLOCATE(ParamData%OutParam)
ENDIF
 END SUBROUTINE SD_DestroyParam

 SUBROUTINE SD_PackParam( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(SD_parametertype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_MoutLst_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_MoutLst_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_MoutLst_Buf(:)
  REAL(ReKi),     ALLOCATABLE :: Re_MoutLst2_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_MoutLst2_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_MoutLst2_Buf(:)
  REAL(ReKi),     ALLOCATABLE :: Re_MoutLst3_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_MoutLst3_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_MoutLst3_Buf(:)
  REAL(ReKi),     ALLOCATABLE :: Re_ElemProps_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_ElemProps_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_ElemProps_Buf(:)
  REAL(ReKi),     ALLOCATABLE :: Re_OutParam_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_OutParam_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_OutParam_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Db_BufSz   = Db_BufSz   + 1  ! SDDeltaT
  Int_BufSz  = Int_BufSz  + 1  ! SttcSolve
  IF ( ALLOCATED(InData%NOmegaM2) )   Re_BufSz    = Re_BufSz    + SIZE( InData%NOmegaM2 )  ! NOmegaM2 
  IF ( ALLOCATED(InData%N2OmegaMJDamp) )   Re_BufSz    = Re_BufSz    + SIZE( InData%N2OmegaMJDamp )  ! N2OmegaMJDamp 
  IF ( ALLOCATED(InData%MMB) )   Re_BufSz    = Re_BufSz    + SIZE( InData%MMB )  ! MMB 
  IF ( ALLOCATED(InData%PhiM_T) )   Re_BufSz    = Re_BufSz    + SIZE( InData%PhiM_T )  ! PhiM_T 
  IF ( ALLOCATED(InData%FX) )   Re_BufSz    = Re_BufSz    + SIZE( InData%FX )  ! FX 
  IF ( ALLOCATED(InData%C1_11) )   Re_BufSz    = Re_BufSz    + SIZE( InData%C1_11 )  ! C1_11 
  IF ( ALLOCATED(InData%C1_12) )   Re_BufSz    = Re_BufSz    + SIZE( InData%C1_12 )  ! C1_12 
  IF ( ALLOCATED(InData%D1_13) )   Re_BufSz    = Re_BufSz    + SIZE( InData%D1_13 )  ! D1_13 
  IF ( ALLOCATED(InData%D1_14) )   Re_BufSz    = Re_BufSz    + SIZE( InData%D1_14 )  ! D1_14 
  IF ( ALLOCATED(InData%D1_15) )   Re_BufSz    = Re_BufSz    + SIZE( InData%D1_15 )  ! D1_15 
  IF ( ALLOCATED(InData%FY) )   Re_BufSz    = Re_BufSz    + SIZE( InData%FY )  ! FY 
  IF ( ALLOCATED(InData%PhiM) )   Re_BufSz    = Re_BufSz    + SIZE( InData%PhiM )  ! PhiM 
  IF ( ALLOCATED(InData%C2_61) )   Re_BufSz    = Re_BufSz    + SIZE( InData%C2_61 )  ! C2_61 
  IF ( ALLOCATED(InData%C2_62) )   Re_BufSz    = Re_BufSz    + SIZE( InData%C2_62 )  ! C2_62 
  IF ( ALLOCATED(InData%PhiRb_TI) )   Re_BufSz    = Re_BufSz    + SIZE( InData%PhiRb_TI )  ! PhiRb_TI 
  IF ( ALLOCATED(InData%D2_63) )   Re_BufSz    = Re_BufSz    + SIZE( InData%D2_63 )  ! D2_63 
  IF ( ALLOCATED(InData%D2_64) )   Re_BufSz    = Re_BufSz    + SIZE( InData%D2_64 )  ! D2_64 
  IF ( ALLOCATED(InData%F2_61) )   Re_BufSz    = Re_BufSz    + SIZE( InData%F2_61 )  ! F2_61 
  IF ( ALLOCATED(InData%MBB) )   Re_BufSz    = Re_BufSz    + SIZE( InData%MBB )  ! MBB 
  IF ( ALLOCATED(InData%KBB) )   Re_BufSz    = Re_BufSz    + SIZE( InData%KBB )  ! KBB 
  IF ( ALLOCATED(InData%MBM) )   Re_BufSz    = Re_BufSz    + SIZE( InData%MBM )  ! MBM 
  IF ( ALLOCATED(InData%PhiL_T) )   Re_BufSz    = Re_BufSz    + SIZE( InData%PhiL_T )  ! PhiL_T 
  IF ( ALLOCATED(InData%PhiLInvOmgL2) )   Re_BufSz    = Re_BufSz    + SIZE( InData%PhiLInvOmgL2 )  ! PhiLInvOmgL2 
  IF ( ALLOCATED(InData%FGL) )   Re_BufSz    = Re_BufSz    + SIZE( InData%FGL )  ! FGL 
  IF ( ALLOCATED(InData%AM2Jac) )   Re_BufSz    = Re_BufSz    + SIZE( InData%AM2Jac )  ! AM2Jac 
  IF ( ALLOCATED(InData%AM2JacPiv) )   Int_BufSz   = Int_BufSz   + SIZE( InData%AM2JacPiv )  ! AM2JacPiv 
  IF ( ALLOCATED(InData%TI) )   Re_BufSz    = Re_BufSz    + SIZE( InData%TI )  ! TI 
  IF ( ALLOCATED(InData%TIreact) )   Re_BufSz    = Re_BufSz    + SIZE( InData%TIreact )  ! TIreact 
  Int_BufSz  = Int_BufSz  + 1  ! NModes
  IF ( ALLOCATED(InData%Elems) )   Int_BufSz   = Int_BufSz   + SIZE( InData%Elems )  ! Elems 
  Int_BufSz  = Int_BufSz  + 1  ! qmL
  Int_BufSz  = Int_BufSz  + 1  ! DofL
  Int_BufSz  = Int_BufSz  + 1  ! NNodes_I
  Int_BufSz  = Int_BufSz  + 1  ! NNodes_L
  Int_BufSz  = Int_BufSz  + 1  ! NNodes_RbarL
  Int_BufSz  = Int_BufSz  + 1  ! DofI
  Int_BufSz  = Int_BufSz  + 1  ! DofR
  Int_BufSz  = Int_BufSz  + 1  ! DofC
  Int_BufSz  = Int_BufSz  + 1  ! NReact
  IF ( ALLOCATED(InData%Reacts) )   Int_BufSz   = Int_BufSz   + SIZE( InData%Reacts )  ! Reacts 
  Int_BufSz  = Int_BufSz  + 1  ! Nmembers
  Int_BufSz  = Int_BufSz  + 1  ! URbarL
  Int_BufSz  = Int_BufSz  + 1  ! IntMethod
  Int_BufSz  = Int_BufSz  + 1  ! NAvgEls
  IF ( ALLOCATED(InData%IDI) )   Int_BufSz   = Int_BufSz   + SIZE( InData%IDI )  ! IDI 
  IF ( ALLOCATED(InData%IDR) )   Int_BufSz   = Int_BufSz   + SIZE( InData%IDR )  ! IDR 
  IF ( ALLOCATED(InData%IDL) )   Int_BufSz   = Int_BufSz   + SIZE( InData%IDL )  ! IDL 
  IF ( ALLOCATED(InData%IDC) )   Int_BufSz   = Int_BufSz   + SIZE( InData%IDC )  ! IDC 
  IF ( ALLOCATED(InData%IDY) )   Int_BufSz   = Int_BufSz   + SIZE( InData%IDY )  ! IDY 
  Int_BufSz  = Int_BufSz  + 1  ! NMOutputs
  Int_BufSz  = Int_BufSz  + 1  ! NumOuts
  Int_BufSz  = Int_BufSz  + 1  ! OutSwtch
  Int_BufSz  = Int_BufSz  + 1  ! UnJckF
!  missing buffer for Delim
!  missing buffer for OutFmt
!  missing buffer for OutSFmt
DO i1 = LBOUND(InData%MoutLst,1), UBOUND(InData%MoutLst,1)
  CALL SD_Packmeshauxdatatype( Re_MoutLst_Buf, Db_MoutLst_Buf, Int_MoutLst_Buf, InData%MoutLst(i1), ErrStat, ErrMsg, .TRUE. ) ! MoutLst 
  IF(ALLOCATED(Re_MoutLst_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_MoutLst_Buf  ) ! MoutLst
  IF(ALLOCATED(Db_MoutLst_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_MoutLst_Buf  ) ! MoutLst
  IF(ALLOCATED(Int_MoutLst_Buf))Int_BufSz = Int_BufSz + SIZE( Int_MoutLst_Buf ) ! MoutLst
  IF(ALLOCATED(Re_MoutLst_Buf))  DEALLOCATE(Re_MoutLst_Buf)
  IF(ALLOCATED(Db_MoutLst_Buf))  DEALLOCATE(Db_MoutLst_Buf)
  IF(ALLOCATED(Int_MoutLst_Buf)) DEALLOCATE(Int_MoutLst_Buf)
ENDDO
DO i1 = LBOUND(InData%MoutLst2,1), UBOUND(InData%MoutLst2,1)
  CALL SD_Packmeshauxdatatype( Re_MoutLst2_Buf, Db_MoutLst2_Buf, Int_MoutLst2_Buf, InData%MoutLst2(i1), ErrStat, ErrMsg, .TRUE. ) ! MoutLst2 
  IF(ALLOCATED(Re_MoutLst2_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_MoutLst2_Buf  ) ! MoutLst2
  IF(ALLOCATED(Db_MoutLst2_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_MoutLst2_Buf  ) ! MoutLst2
  IF(ALLOCATED(Int_MoutLst2_Buf))Int_BufSz = Int_BufSz + SIZE( Int_MoutLst2_Buf ) ! MoutLst2
  IF(ALLOCATED(Re_MoutLst2_Buf))  DEALLOCATE(Re_MoutLst2_Buf)
  IF(ALLOCATED(Db_MoutLst2_Buf))  DEALLOCATE(Db_MoutLst2_Buf)
  IF(ALLOCATED(Int_MoutLst2_Buf)) DEALLOCATE(Int_MoutLst2_Buf)
ENDDO
DO i1 = LBOUND(InData%MoutLst3,1), UBOUND(InData%MoutLst3,1)
  CALL SD_Packmeshauxdatatype( Re_MoutLst3_Buf, Db_MoutLst3_Buf, Int_MoutLst3_Buf, InData%MoutLst3(i1), ErrStat, ErrMsg, .TRUE. ) ! MoutLst3 
  IF(ALLOCATED(Re_MoutLst3_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_MoutLst3_Buf  ) ! MoutLst3
  IF(ALLOCATED(Db_MoutLst3_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_MoutLst3_Buf  ) ! MoutLst3
  IF(ALLOCATED(Int_MoutLst3_Buf))Int_BufSz = Int_BufSz + SIZE( Int_MoutLst3_Buf ) ! MoutLst3
  IF(ALLOCATED(Re_MoutLst3_Buf))  DEALLOCATE(Re_MoutLst3_Buf)
  IF(ALLOCATED(Db_MoutLst3_Buf))  DEALLOCATE(Db_MoutLst3_Buf)
  IF(ALLOCATED(Int_MoutLst3_Buf)) DEALLOCATE(Int_MoutLst3_Buf)
ENDDO
DO i1 = LBOUND(InData%ElemProps,1), UBOUND(InData%ElemProps,1)
  CALL SD_Packelemproptype( Re_ElemProps_Buf, Db_ElemProps_Buf, Int_ElemProps_Buf, InData%ElemProps(i1), ErrStat, ErrMsg, .TRUE. ) ! ElemProps 
  IF(ALLOCATED(Re_ElemProps_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_ElemProps_Buf  ) ! ElemProps
  IF(ALLOCATED(Db_ElemProps_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_ElemProps_Buf  ) ! ElemProps
  IF(ALLOCATED(Int_ElemProps_Buf))Int_BufSz = Int_BufSz + SIZE( Int_ElemProps_Buf ) ! ElemProps
  IF(ALLOCATED(Re_ElemProps_Buf))  DEALLOCATE(Re_ElemProps_Buf)
  IF(ALLOCATED(Db_ElemProps_Buf))  DEALLOCATE(Db_ElemProps_Buf)
  IF(ALLOCATED(Int_ElemProps_Buf)) DEALLOCATE(Int_ElemProps_Buf)
ENDDO
DO i1 = LBOUND(InData%OutParam,1), UBOUND(InData%OutParam,1)
  CALL NWTC_Library_Packoutparmtype( Re_OutParam_Buf, Db_OutParam_Buf, Int_OutParam_Buf, InData%OutParam(i1), ErrStat, ErrMsg, .TRUE. ) ! OutParam 
  IF(ALLOCATED(Re_OutParam_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_OutParam_Buf  ) ! OutParam
  IF(ALLOCATED(Db_OutParam_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_OutParam_Buf  ) ! OutParam
  IF(ALLOCATED(Int_OutParam_Buf))Int_BufSz = Int_BufSz + SIZE( Int_OutParam_Buf ) ! OutParam
  IF(ALLOCATED(Re_OutParam_Buf))  DEALLOCATE(Re_OutParam_Buf)
  IF(ALLOCATED(Db_OutParam_Buf))  DEALLOCATE(Db_OutParam_Buf)
  IF(ALLOCATED(Int_OutParam_Buf)) DEALLOCATE(Int_OutParam_Buf)
ENDDO
  Int_BufSz  = Int_BufSz  + 1  ! OutAll
  Int_BufSz  = Int_BufSz  + 1  ! OutReact
  Int_BufSz  = Int_BufSz  + 1  ! OutAllInt
  Int_BufSz  = Int_BufSz  + 1  ! OutAllDims
  Int_BufSz  = Int_BufSz  + 1  ! OutDec
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(1)-1 ) =  (InData%SDDeltaT )
  Db_Xferred   = Db_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = TRANSFER( (InData%SttcSolve ), IntKiBuf(1), 1)
  Int_Xferred   = Int_Xferred   + 1
  IF ( ALLOCATED(InData%NOmegaM2) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%NOmegaM2))-1 ) =  PACK(InData%NOmegaM2 ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%NOmegaM2)
  ENDIF
  IF ( ALLOCATED(InData%N2OmegaMJDamp) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%N2OmegaMJDamp))-1 ) =  PACK(InData%N2OmegaMJDamp ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%N2OmegaMJDamp)
  ENDIF
  IF ( ALLOCATED(InData%MMB) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%MMB))-1 ) =  PACK(InData%MMB ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%MMB)
  ENDIF
  IF ( ALLOCATED(InData%PhiM_T) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%PhiM_T))-1 ) =  PACK(InData%PhiM_T ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%PhiM_T)
  ENDIF
  IF ( ALLOCATED(InData%FX) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%FX))-1 ) =  PACK(InData%FX ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%FX)
  ENDIF
  IF ( ALLOCATED(InData%C1_11) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%C1_11))-1 ) =  PACK(InData%C1_11 ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%C1_11)
  ENDIF
  IF ( ALLOCATED(InData%C1_12) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%C1_12))-1 ) =  PACK(InData%C1_12 ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%C1_12)
  ENDIF
  IF ( ALLOCATED(InData%D1_13) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%D1_13))-1 ) =  PACK(InData%D1_13 ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%D1_13)
  ENDIF
  IF ( ALLOCATED(InData%D1_14) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%D1_14))-1 ) =  PACK(InData%D1_14 ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%D1_14)
  ENDIF
  IF ( ALLOCATED(InData%D1_15) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%D1_15))-1 ) =  PACK(InData%D1_15 ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%D1_15)
  ENDIF
  IF ( ALLOCATED(InData%FY) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%FY))-1 ) =  PACK(InData%FY ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%FY)
  ENDIF
  IF ( ALLOCATED(InData%PhiM) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%PhiM))-1 ) =  PACK(InData%PhiM ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%PhiM)
  ENDIF
  IF ( ALLOCATED(InData%C2_61) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%C2_61))-1 ) =  PACK(InData%C2_61 ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%C2_61)
  ENDIF
  IF ( ALLOCATED(InData%C2_62) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%C2_62))-1 ) =  PACK(InData%C2_62 ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%C2_62)
  ENDIF
  IF ( ALLOCATED(InData%PhiRb_TI) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%PhiRb_TI))-1 ) =  PACK(InData%PhiRb_TI ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%PhiRb_TI)
  ENDIF
  IF ( ALLOCATED(InData%D2_63) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%D2_63))-1 ) =  PACK(InData%D2_63 ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%D2_63)
  ENDIF
  IF ( ALLOCATED(InData%D2_64) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%D2_64))-1 ) =  PACK(InData%D2_64 ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%D2_64)
  ENDIF
  IF ( ALLOCATED(InData%F2_61) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%F2_61))-1 ) =  PACK(InData%F2_61 ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%F2_61)
  ENDIF
  IF ( ALLOCATED(InData%MBB) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%MBB))-1 ) =  PACK(InData%MBB ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%MBB)
  ENDIF
  IF ( ALLOCATED(InData%KBB) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%KBB))-1 ) =  PACK(InData%KBB ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%KBB)
  ENDIF
  IF ( ALLOCATED(InData%MBM) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%MBM))-1 ) =  PACK(InData%MBM ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%MBM)
  ENDIF
  IF ( ALLOCATED(InData%PhiL_T) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%PhiL_T))-1 ) =  PACK(InData%PhiL_T ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%PhiL_T)
  ENDIF
  IF ( ALLOCATED(InData%PhiLInvOmgL2) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%PhiLInvOmgL2))-1 ) =  PACK(InData%PhiLInvOmgL2 ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%PhiLInvOmgL2)
  ENDIF
  IF ( ALLOCATED(InData%FGL) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%FGL))-1 ) =  PACK(InData%FGL ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%FGL)
  ENDIF
  IF ( ALLOCATED(InData%AM2Jac) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%AM2Jac))-1 ) =  PACK(InData%AM2Jac ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%AM2Jac)
  ENDIF
  IF ( ALLOCATED(InData%AM2JacPiv) ) THEN
    IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%AM2JacPiv))-1 ) = PACK(InData%AM2JacPiv ,.TRUE.)
    Int_Xferred   = Int_Xferred   + SIZE(InData%AM2JacPiv)
  ENDIF
  IF ( ALLOCATED(InData%TI) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%TI))-1 ) =  PACK(InData%TI ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%TI)
  ENDIF
  IF ( ALLOCATED(InData%TIreact) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%TIreact))-1 ) =  PACK(InData%TIreact ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%TIreact)
  ENDIF
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NModes )
  Int_Xferred   = Int_Xferred   + 1
  IF ( ALLOCATED(InData%Elems) ) THEN
    IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%Elems))-1 ) = PACK(InData%Elems ,.TRUE.)
    Int_Xferred   = Int_Xferred   + SIZE(InData%Elems)
  ENDIF
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%qmL )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%DofL )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NNodes_I )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NNodes_L )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NNodes_RbarL )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%DofI )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%DofR )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%DofC )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NReact )
  Int_Xferred   = Int_Xferred   + 1
  IF ( ALLOCATED(InData%Reacts) ) THEN
    IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%Reacts))-1 ) = PACK(InData%Reacts ,.TRUE.)
    Int_Xferred   = Int_Xferred   + SIZE(InData%Reacts)
  ENDIF
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%Nmembers )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%URbarL )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%IntMethod )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NAvgEls )
  Int_Xferred   = Int_Xferred   + 1
  IF ( ALLOCATED(InData%IDI) ) THEN
    IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%IDI))-1 ) = PACK(InData%IDI ,.TRUE.)
    Int_Xferred   = Int_Xferred   + SIZE(InData%IDI)
  ENDIF
  IF ( ALLOCATED(InData%IDR) ) THEN
    IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%IDR))-1 ) = PACK(InData%IDR ,.TRUE.)
    Int_Xferred   = Int_Xferred   + SIZE(InData%IDR)
  ENDIF
  IF ( ALLOCATED(InData%IDL) ) THEN
    IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%IDL))-1 ) = PACK(InData%IDL ,.TRUE.)
    Int_Xferred   = Int_Xferred   + SIZE(InData%IDL)
  ENDIF
  IF ( ALLOCATED(InData%IDC) ) THEN
    IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%IDC))-1 ) = PACK(InData%IDC ,.TRUE.)
    Int_Xferred   = Int_Xferred   + SIZE(InData%IDC)
  ENDIF
  IF ( ALLOCATED(InData%IDY) ) THEN
    IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%IDY))-1 ) = PACK(InData%IDY ,.TRUE.)
    Int_Xferred   = Int_Xferred   + SIZE(InData%IDY)
  ENDIF
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NMOutputs )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NumOuts )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%OutSwtch )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%UnJckF )
  Int_Xferred   = Int_Xferred   + 1
DO i1 = LBOUND(InData%MoutLst,1), UBOUND(InData%MoutLst,1)
  CALL SD_Packmeshauxdatatype( Re_MoutLst_Buf, Db_MoutLst_Buf, Int_MoutLst_Buf, InData%MoutLst(i1), ErrStat, ErrMsg, OnlySize ) ! MoutLst 
  IF(ALLOCATED(Re_MoutLst_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_MoutLst_Buf)-1 ) = Re_MoutLst_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_MoutLst_Buf)
  ENDIF
  IF(ALLOCATED(Db_MoutLst_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_MoutLst_Buf)-1 ) = Db_MoutLst_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_MoutLst_Buf)
  ENDIF
  IF(ALLOCATED(Int_MoutLst_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_MoutLst_Buf)-1 ) = Int_MoutLst_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_MoutLst_Buf)
  ENDIF
  IF( ALLOCATED(Re_MoutLst_Buf) )  DEALLOCATE(Re_MoutLst_Buf)
  IF( ALLOCATED(Db_MoutLst_Buf) )  DEALLOCATE(Db_MoutLst_Buf)
  IF( ALLOCATED(Int_MoutLst_Buf) ) DEALLOCATE(Int_MoutLst_Buf)
ENDDO
DO i1 = LBOUND(InData%MoutLst2,1), UBOUND(InData%MoutLst2,1)
  CALL SD_Packmeshauxdatatype( Re_MoutLst2_Buf, Db_MoutLst2_Buf, Int_MoutLst2_Buf, InData%MoutLst2(i1), ErrStat, ErrMsg, OnlySize ) ! MoutLst2 
  IF(ALLOCATED(Re_MoutLst2_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_MoutLst2_Buf)-1 ) = Re_MoutLst2_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_MoutLst2_Buf)
  ENDIF
  IF(ALLOCATED(Db_MoutLst2_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_MoutLst2_Buf)-1 ) = Db_MoutLst2_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_MoutLst2_Buf)
  ENDIF
  IF(ALLOCATED(Int_MoutLst2_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_MoutLst2_Buf)-1 ) = Int_MoutLst2_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_MoutLst2_Buf)
  ENDIF
  IF( ALLOCATED(Re_MoutLst2_Buf) )  DEALLOCATE(Re_MoutLst2_Buf)
  IF( ALLOCATED(Db_MoutLst2_Buf) )  DEALLOCATE(Db_MoutLst2_Buf)
  IF( ALLOCATED(Int_MoutLst2_Buf) ) DEALLOCATE(Int_MoutLst2_Buf)
ENDDO
DO i1 = LBOUND(InData%MoutLst3,1), UBOUND(InData%MoutLst3,1)
  CALL SD_Packmeshauxdatatype( Re_MoutLst3_Buf, Db_MoutLst3_Buf, Int_MoutLst3_Buf, InData%MoutLst3(i1), ErrStat, ErrMsg, OnlySize ) ! MoutLst3 
  IF(ALLOCATED(Re_MoutLst3_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_MoutLst3_Buf)-1 ) = Re_MoutLst3_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_MoutLst3_Buf)
  ENDIF
  IF(ALLOCATED(Db_MoutLst3_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_MoutLst3_Buf)-1 ) = Db_MoutLst3_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_MoutLst3_Buf)
  ENDIF
  IF(ALLOCATED(Int_MoutLst3_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_MoutLst3_Buf)-1 ) = Int_MoutLst3_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_MoutLst3_Buf)
  ENDIF
  IF( ALLOCATED(Re_MoutLst3_Buf) )  DEALLOCATE(Re_MoutLst3_Buf)
  IF( ALLOCATED(Db_MoutLst3_Buf) )  DEALLOCATE(Db_MoutLst3_Buf)
  IF( ALLOCATED(Int_MoutLst3_Buf) ) DEALLOCATE(Int_MoutLst3_Buf)
ENDDO
DO i1 = LBOUND(InData%ElemProps,1), UBOUND(InData%ElemProps,1)
  CALL SD_Packelemproptype( Re_ElemProps_Buf, Db_ElemProps_Buf, Int_ElemProps_Buf, InData%ElemProps(i1), ErrStat, ErrMsg, OnlySize ) ! ElemProps 
  IF(ALLOCATED(Re_ElemProps_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_ElemProps_Buf)-1 ) = Re_ElemProps_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_ElemProps_Buf)
  ENDIF
  IF(ALLOCATED(Db_ElemProps_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_ElemProps_Buf)-1 ) = Db_ElemProps_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_ElemProps_Buf)
  ENDIF
  IF(ALLOCATED(Int_ElemProps_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_ElemProps_Buf)-1 ) = Int_ElemProps_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_ElemProps_Buf)
  ENDIF
  IF( ALLOCATED(Re_ElemProps_Buf) )  DEALLOCATE(Re_ElemProps_Buf)
  IF( ALLOCATED(Db_ElemProps_Buf) )  DEALLOCATE(Db_ElemProps_Buf)
  IF( ALLOCATED(Int_ElemProps_Buf) ) DEALLOCATE(Int_ElemProps_Buf)
ENDDO
DO i1 = LBOUND(InData%OutParam,1), UBOUND(InData%OutParam,1)
  CALL NWTC_Library_Packoutparmtype( Re_OutParam_Buf, Db_OutParam_Buf, Int_OutParam_Buf, InData%OutParam(i1), ErrStat, ErrMsg, OnlySize ) ! OutParam 
  IF(ALLOCATED(Re_OutParam_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_OutParam_Buf)-1 ) = Re_OutParam_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_OutParam_Buf)
  ENDIF
  IF(ALLOCATED(Db_OutParam_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_OutParam_Buf)-1 ) = Db_OutParam_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_OutParam_Buf)
  ENDIF
  IF(ALLOCATED(Int_OutParam_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_OutParam_Buf)-1 ) = Int_OutParam_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_OutParam_Buf)
  ENDIF
  IF( ALLOCATED(Re_OutParam_Buf) )  DEALLOCATE(Re_OutParam_Buf)
  IF( ALLOCATED(Db_OutParam_Buf) )  DEALLOCATE(Db_OutParam_Buf)
  IF( ALLOCATED(Int_OutParam_Buf) ) DEALLOCATE(Int_OutParam_Buf)
ENDDO
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = TRANSFER( (InData%OutAll ), IntKiBuf(1), 1)
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = TRANSFER( (InData%OutReact ), IntKiBuf(1), 1)
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%OutAllInt )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%OutAllDims )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%OutDec )
  Int_Xferred   = Int_Xferred   + 1
 END SUBROUTINE SD_PackParam

 SUBROUTINE SD_UnPackParam( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(SD_parametertype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_MoutLst_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_MoutLst_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_MoutLst_Buf(:)
  REAL(ReKi),    ALLOCATABLE :: Re_MoutLst2_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_MoutLst2_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_MoutLst2_Buf(:)
  REAL(ReKi),    ALLOCATABLE :: Re_MoutLst3_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_MoutLst3_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_MoutLst3_Buf(:)
  REAL(ReKi),    ALLOCATABLE :: Re_ElemProps_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_ElemProps_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_ElemProps_Buf(:)
  REAL(ReKi),    ALLOCATABLE :: Re_OutParam_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_OutParam_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_OutParam_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  OutData%SDDeltaT = DbKiBuf ( Db_Xferred )
  Db_Xferred   = Db_Xferred   + 1
  IF ( ALLOCATED(OutData%NOmegaM2) ) THEN
  ALLOCATE(mask1(SIZE(OutData%NOmegaM2,1))); mask1 = .TRUE.
    OutData%NOmegaM2 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%NOmegaM2))-1 ),mask1,OutData%NOmegaM2)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%NOmegaM2)
  ENDIF
  IF ( ALLOCATED(OutData%N2OmegaMJDamp) ) THEN
  ALLOCATE(mask1(SIZE(OutData%N2OmegaMJDamp,1))); mask1 = .TRUE.
    OutData%N2OmegaMJDamp = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%N2OmegaMJDamp))-1 ),mask1,OutData%N2OmegaMJDamp)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%N2OmegaMJDamp)
  ENDIF
  IF ( ALLOCATED(OutData%MMB) ) THEN
  ALLOCATE(mask2(SIZE(OutData%MMB,1),SIZE(OutData%MMB,2))); mask2 = .TRUE.
    OutData%MMB = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%MMB))-1 ),mask2,OutData%MMB)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%MMB)
  ENDIF
  IF ( ALLOCATED(OutData%PhiM_T) ) THEN
  ALLOCATE(mask2(SIZE(OutData%PhiM_T,1),SIZE(OutData%PhiM_T,2))); mask2 = .TRUE.
    OutData%PhiM_T = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%PhiM_T))-1 ),mask2,OutData%PhiM_T)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%PhiM_T)
  ENDIF
  IF ( ALLOCATED(OutData%FX) ) THEN
  ALLOCATE(mask1(SIZE(OutData%FX,1))); mask1 = .TRUE.
    OutData%FX = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%FX))-1 ),mask1,OutData%FX)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%FX)
  ENDIF
  IF ( ALLOCATED(OutData%C1_11) ) THEN
  ALLOCATE(mask2(SIZE(OutData%C1_11,1),SIZE(OutData%C1_11,2))); mask2 = .TRUE.
    OutData%C1_11 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%C1_11))-1 ),mask2,OutData%C1_11)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%C1_11)
  ENDIF
  IF ( ALLOCATED(OutData%C1_12) ) THEN
  ALLOCATE(mask2(SIZE(OutData%C1_12,1),SIZE(OutData%C1_12,2))); mask2 = .TRUE.
    OutData%C1_12 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%C1_12))-1 ),mask2,OutData%C1_12)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%C1_12)
  ENDIF
  IF ( ALLOCATED(OutData%D1_13) ) THEN
  ALLOCATE(mask2(SIZE(OutData%D1_13,1),SIZE(OutData%D1_13,2))); mask2 = .TRUE.
    OutData%D1_13 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%D1_13))-1 ),mask2,OutData%D1_13)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%D1_13)
  ENDIF
  IF ( ALLOCATED(OutData%D1_14) ) THEN
  ALLOCATE(mask2(SIZE(OutData%D1_14,1),SIZE(OutData%D1_14,2))); mask2 = .TRUE.
    OutData%D1_14 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%D1_14))-1 ),mask2,OutData%D1_14)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%D1_14)
  ENDIF
  IF ( ALLOCATED(OutData%D1_15) ) THEN
  ALLOCATE(mask2(SIZE(OutData%D1_15,1),SIZE(OutData%D1_15,2))); mask2 = .TRUE.
    OutData%D1_15 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%D1_15))-1 ),mask2,OutData%D1_15)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%D1_15)
  ENDIF
  IF ( ALLOCATED(OutData%FY) ) THEN
  ALLOCATE(mask1(SIZE(OutData%FY,1))); mask1 = .TRUE.
    OutData%FY = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%FY))-1 ),mask1,OutData%FY)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%FY)
  ENDIF
  IF ( ALLOCATED(OutData%PhiM) ) THEN
  ALLOCATE(mask2(SIZE(OutData%PhiM,1),SIZE(OutData%PhiM,2))); mask2 = .TRUE.
    OutData%PhiM = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%PhiM))-1 ),mask2,OutData%PhiM)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%PhiM)
  ENDIF
  IF ( ALLOCATED(OutData%C2_61) ) THEN
  ALLOCATE(mask2(SIZE(OutData%C2_61,1),SIZE(OutData%C2_61,2))); mask2 = .TRUE.
    OutData%C2_61 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%C2_61))-1 ),mask2,OutData%C2_61)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%C2_61)
  ENDIF
  IF ( ALLOCATED(OutData%C2_62) ) THEN
  ALLOCATE(mask2(SIZE(OutData%C2_62,1),SIZE(OutData%C2_62,2))); mask2 = .TRUE.
    OutData%C2_62 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%C2_62))-1 ),mask2,OutData%C2_62)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%C2_62)
  ENDIF
  IF ( ALLOCATED(OutData%PhiRb_TI) ) THEN
  ALLOCATE(mask2(SIZE(OutData%PhiRb_TI,1),SIZE(OutData%PhiRb_TI,2))); mask2 = .TRUE.
    OutData%PhiRb_TI = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%PhiRb_TI))-1 ),mask2,OutData%PhiRb_TI)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%PhiRb_TI)
  ENDIF
  IF ( ALLOCATED(OutData%D2_63) ) THEN
  ALLOCATE(mask2(SIZE(OutData%D2_63,1),SIZE(OutData%D2_63,2))); mask2 = .TRUE.
    OutData%D2_63 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%D2_63))-1 ),mask2,OutData%D2_63)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%D2_63)
  ENDIF
  IF ( ALLOCATED(OutData%D2_64) ) THEN
  ALLOCATE(mask2(SIZE(OutData%D2_64,1),SIZE(OutData%D2_64,2))); mask2 = .TRUE.
    OutData%D2_64 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%D2_64))-1 ),mask2,OutData%D2_64)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%D2_64)
  ENDIF
  IF ( ALLOCATED(OutData%F2_61) ) THEN
  ALLOCATE(mask1(SIZE(OutData%F2_61,1))); mask1 = .TRUE.
    OutData%F2_61 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%F2_61))-1 ),mask1,OutData%F2_61)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%F2_61)
  ENDIF
  IF ( ALLOCATED(OutData%MBB) ) THEN
  ALLOCATE(mask2(SIZE(OutData%MBB,1),SIZE(OutData%MBB,2))); mask2 = .TRUE.
    OutData%MBB = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%MBB))-1 ),mask2,OutData%MBB)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%MBB)
  ENDIF
  IF ( ALLOCATED(OutData%KBB) ) THEN
  ALLOCATE(mask2(SIZE(OutData%KBB,1),SIZE(OutData%KBB,2))); mask2 = .TRUE.
    OutData%KBB = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%KBB))-1 ),mask2,OutData%KBB)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%KBB)
  ENDIF
  IF ( ALLOCATED(OutData%MBM) ) THEN
  ALLOCATE(mask2(SIZE(OutData%MBM,1),SIZE(OutData%MBM,2))); mask2 = .TRUE.
    OutData%MBM = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%MBM))-1 ),mask2,OutData%MBM)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%MBM)
  ENDIF
  IF ( ALLOCATED(OutData%PhiL_T) ) THEN
  ALLOCATE(mask2(SIZE(OutData%PhiL_T,1),SIZE(OutData%PhiL_T,2))); mask2 = .TRUE.
    OutData%PhiL_T = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%PhiL_T))-1 ),mask2,OutData%PhiL_T)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%PhiL_T)
  ENDIF
  IF ( ALLOCATED(OutData%PhiLInvOmgL2) ) THEN
  ALLOCATE(mask2(SIZE(OutData%PhiLInvOmgL2,1),SIZE(OutData%PhiLInvOmgL2,2))); mask2 = .TRUE.
    OutData%PhiLInvOmgL2 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%PhiLInvOmgL2))-1 ),mask2,OutData%PhiLInvOmgL2)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%PhiLInvOmgL2)
  ENDIF
  IF ( ALLOCATED(OutData%FGL) ) THEN
  ALLOCATE(mask1(SIZE(OutData%FGL,1))); mask1 = .TRUE.
    OutData%FGL = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%FGL))-1 ),mask1,OutData%FGL)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%FGL)
  ENDIF
  IF ( ALLOCATED(OutData%AM2Jac) ) THEN
  ALLOCATE(mask2(SIZE(OutData%AM2Jac,1),SIZE(OutData%AM2Jac,2))); mask2 = .TRUE.
    OutData%AM2Jac = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%AM2Jac))-1 ),mask2,OutData%AM2Jac)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%AM2Jac)
  ENDIF
  IF ( ALLOCATED(OutData%AM2JacPiv) ) THEN
  ALLOCATE(mask1(SIZE(OutData%AM2JacPiv,1))); mask1 = .TRUE.
    OutData%AM2JacPiv = UNPACK(IntKiBuf( Int_Xferred:Re_Xferred+(SIZE(OutData%AM2JacPiv))-1 ),mask1,OutData%AM2JacPiv)
  DEALLOCATE(mask1)
    Int_Xferred   = Int_Xferred   + SIZE(OutData%AM2JacPiv)
  ENDIF
  IF ( ALLOCATED(OutData%TI) ) THEN
  ALLOCATE(mask2(SIZE(OutData%TI,1),SIZE(OutData%TI,2))); mask2 = .TRUE.
    OutData%TI = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%TI))-1 ),mask2,OutData%TI)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%TI)
  ENDIF
  IF ( ALLOCATED(OutData%TIreact) ) THEN
  ALLOCATE(mask2(SIZE(OutData%TIreact,1),SIZE(OutData%TIreact,2))); mask2 = .TRUE.
    OutData%TIreact = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%TIreact))-1 ),mask2,OutData%TIreact)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%TIreact)
  ENDIF
  OutData%NModes = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  IF ( ALLOCATED(OutData%Elems) ) THEN
  ALLOCATE(mask2(SIZE(OutData%Elems,1),SIZE(OutData%Elems,2))); mask2 = .TRUE.
    OutData%Elems = UNPACK(IntKiBuf( Int_Xferred:Re_Xferred+(SIZE(OutData%Elems))-1 ),mask2,OutData%Elems)
  DEALLOCATE(mask2)
    Int_Xferred   = Int_Xferred   + SIZE(OutData%Elems)
  ENDIF
  OutData%qmL = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%DofL = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%NNodes_I = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%NNodes_L = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%NNodes_RbarL = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%DofI = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%DofR = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%DofC = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%NReact = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  IF ( ALLOCATED(OutData%Reacts) ) THEN
  ALLOCATE(mask2(SIZE(OutData%Reacts,1),SIZE(OutData%Reacts,2))); mask2 = .TRUE.
    OutData%Reacts = UNPACK(IntKiBuf( Int_Xferred:Re_Xferred+(SIZE(OutData%Reacts))-1 ),mask2,OutData%Reacts)
  DEALLOCATE(mask2)
    Int_Xferred   = Int_Xferred   + SIZE(OutData%Reacts)
  ENDIF
  OutData%Nmembers = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%URbarL = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%IntMethod = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%NAvgEls = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  IF ( ALLOCATED(OutData%IDI) ) THEN
  ALLOCATE(mask1(SIZE(OutData%IDI,1))); mask1 = .TRUE.
    OutData%IDI = UNPACK(IntKiBuf( Int_Xferred:Re_Xferred+(SIZE(OutData%IDI))-1 ),mask1,OutData%IDI)
  DEALLOCATE(mask1)
    Int_Xferred   = Int_Xferred   + SIZE(OutData%IDI)
  ENDIF
  IF ( ALLOCATED(OutData%IDR) ) THEN
  ALLOCATE(mask1(SIZE(OutData%IDR,1))); mask1 = .TRUE.
    OutData%IDR = UNPACK(IntKiBuf( Int_Xferred:Re_Xferred+(SIZE(OutData%IDR))-1 ),mask1,OutData%IDR)
  DEALLOCATE(mask1)
    Int_Xferred   = Int_Xferred   + SIZE(OutData%IDR)
  ENDIF
  IF ( ALLOCATED(OutData%IDL) ) THEN
  ALLOCATE(mask1(SIZE(OutData%IDL,1))); mask1 = .TRUE.
    OutData%IDL = UNPACK(IntKiBuf( Int_Xferred:Re_Xferred+(SIZE(OutData%IDL))-1 ),mask1,OutData%IDL)
  DEALLOCATE(mask1)
    Int_Xferred   = Int_Xferred   + SIZE(OutData%IDL)
  ENDIF
  IF ( ALLOCATED(OutData%IDC) ) THEN
  ALLOCATE(mask1(SIZE(OutData%IDC,1))); mask1 = .TRUE.
    OutData%IDC = UNPACK(IntKiBuf( Int_Xferred:Re_Xferred+(SIZE(OutData%IDC))-1 ),mask1,OutData%IDC)
  DEALLOCATE(mask1)
    Int_Xferred   = Int_Xferred   + SIZE(OutData%IDC)
  ENDIF
  IF ( ALLOCATED(OutData%IDY) ) THEN
  ALLOCATE(mask1(SIZE(OutData%IDY,1))); mask1 = .TRUE.
    OutData%IDY = UNPACK(IntKiBuf( Int_Xferred:Re_Xferred+(SIZE(OutData%IDY))-1 ),mask1,OutData%IDY)
  DEALLOCATE(mask1)
    Int_Xferred   = Int_Xferred   + SIZE(OutData%IDY)
  ENDIF
  OutData%NMOutputs = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%NumOuts = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%OutSwtch = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%UnJckF = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
DO i1 = LBOUND(OutData%MoutLst,1), UBOUND(OutData%MoutLst,1)
 ! first call SD_Packmeshauxdatatype to get correctly sized buffers for unpacking
  CALL SD_Packmeshauxdatatype( Re_MoutLst_Buf, Db_MoutLst_Buf, Int_MoutLst_Buf, OutData%MoutLst(i1), ErrStat, ErrMsg, .TRUE. ) ! MoutLst 
  IF(ALLOCATED(Re_MoutLst_Buf)) THEN
    Re_MoutLst_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_MoutLst_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_MoutLst_Buf)
  ENDIF
  IF(ALLOCATED(Db_MoutLst_Buf)) THEN
    Db_MoutLst_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_MoutLst_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_MoutLst_Buf)
  ENDIF
  IF(ALLOCATED(Int_MoutLst_Buf)) THEN
    Int_MoutLst_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_MoutLst_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_MoutLst_Buf)
  ENDIF
  CALL SD_UnPackmeshauxdatatype( Re_MoutLst_Buf, Db_MoutLst_Buf, Int_MoutLst_Buf, OutData%MoutLst(i1), ErrStat, ErrMsg ) ! MoutLst 
ENDDO
DO i1 = LBOUND(OutData%MoutLst2,1), UBOUND(OutData%MoutLst2,1)
 ! first call SD_Packmeshauxdatatype to get correctly sized buffers for unpacking
  CALL SD_Packmeshauxdatatype( Re_MoutLst2_Buf, Db_MoutLst2_Buf, Int_MoutLst2_Buf, OutData%MoutLst2(i1), ErrStat, ErrMsg, .TRUE. ) ! MoutLst2 
  IF(ALLOCATED(Re_MoutLst2_Buf)) THEN
    Re_MoutLst2_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_MoutLst2_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_MoutLst2_Buf)
  ENDIF
  IF(ALLOCATED(Db_MoutLst2_Buf)) THEN
    Db_MoutLst2_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_MoutLst2_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_MoutLst2_Buf)
  ENDIF
  IF(ALLOCATED(Int_MoutLst2_Buf)) THEN
    Int_MoutLst2_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_MoutLst2_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_MoutLst2_Buf)
  ENDIF
  CALL SD_UnPackmeshauxdatatype( Re_MoutLst2_Buf, Db_MoutLst2_Buf, Int_MoutLst2_Buf, OutData%MoutLst2(i1), ErrStat, ErrMsg ) ! MoutLst2 
ENDDO
DO i1 = LBOUND(OutData%MoutLst3,1), UBOUND(OutData%MoutLst3,1)
 ! first call SD_Packmeshauxdatatype to get correctly sized buffers for unpacking
  CALL SD_Packmeshauxdatatype( Re_MoutLst3_Buf, Db_MoutLst3_Buf, Int_MoutLst3_Buf, OutData%MoutLst3(i1), ErrStat, ErrMsg, .TRUE. ) ! MoutLst3 
  IF(ALLOCATED(Re_MoutLst3_Buf)) THEN
    Re_MoutLst3_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_MoutLst3_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_MoutLst3_Buf)
  ENDIF
  IF(ALLOCATED(Db_MoutLst3_Buf)) THEN
    Db_MoutLst3_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_MoutLst3_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_MoutLst3_Buf)
  ENDIF
  IF(ALLOCATED(Int_MoutLst3_Buf)) THEN
    Int_MoutLst3_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_MoutLst3_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_MoutLst3_Buf)
  ENDIF
  CALL SD_UnPackmeshauxdatatype( Re_MoutLst3_Buf, Db_MoutLst3_Buf, Int_MoutLst3_Buf, OutData%MoutLst3(i1), ErrStat, ErrMsg ) ! MoutLst3 
ENDDO
DO i1 = LBOUND(OutData%ElemProps,1), UBOUND(OutData%ElemProps,1)
 ! first call SD_Packelemproptype to get correctly sized buffers for unpacking
  CALL SD_Packelemproptype( Re_ElemProps_Buf, Db_ElemProps_Buf, Int_ElemProps_Buf, OutData%ElemProps(i1), ErrStat, ErrMsg, .TRUE. ) ! ElemProps 
  IF(ALLOCATED(Re_ElemProps_Buf)) THEN
    Re_ElemProps_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_ElemProps_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_ElemProps_Buf)
  ENDIF
  IF(ALLOCATED(Db_ElemProps_Buf)) THEN
    Db_ElemProps_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_ElemProps_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_ElemProps_Buf)
  ENDIF
  IF(ALLOCATED(Int_ElemProps_Buf)) THEN
    Int_ElemProps_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_ElemProps_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_ElemProps_Buf)
  ENDIF
  CALL SD_UnPackelemproptype( Re_ElemProps_Buf, Db_ElemProps_Buf, Int_ElemProps_Buf, OutData%ElemProps(i1), ErrStat, ErrMsg ) ! ElemProps 
ENDDO
DO i1 = LBOUND(OutData%OutParam,1), UBOUND(OutData%OutParam,1)
 ! first call NWTC_Library_Packoutparmtype to get correctly sized buffers for unpacking
  CALL NWTC_Library_Packoutparmtype( Re_OutParam_Buf, Db_OutParam_Buf, Int_OutParam_Buf, OutData%OutParam(i1), ErrStat, ErrMsg, .TRUE. ) ! OutParam 
  IF(ALLOCATED(Re_OutParam_Buf)) THEN
    Re_OutParam_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_OutParam_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_OutParam_Buf)
  ENDIF
  IF(ALLOCATED(Db_OutParam_Buf)) THEN
    Db_OutParam_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_OutParam_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_OutParam_Buf)
  ENDIF
  IF(ALLOCATED(Int_OutParam_Buf)) THEN
    Int_OutParam_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_OutParam_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_OutParam_Buf)
  ENDIF
  CALL NWTC_Library_UnPackoutparmtype( Re_OutParam_Buf, Db_OutParam_Buf, Int_OutParam_Buf, OutData%OutParam(i1), ErrStat, ErrMsg ) ! OutParam 
ENDDO
  OutData%OutAllInt = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%OutAllDims = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%OutDec = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE SD_UnPackParam

 SUBROUTINE SD_CopyInput( SrcInputData, DstInputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(SD_inputtype), INTENT(INOUT) :: SrcInputData
   TYPE(SD_inputtype), INTENT(INOUT) :: DstInputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
     CALL MeshCopy( SrcInputData%TPMesh, DstInputData%TPMesh, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'SD_CopyInput:TPMesh')
         IF (ErrStat>=AbortErrLev) RETURN
     CALL MeshCopy( SrcInputData%LMesh, DstInputData%LMesh, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'SD_CopyInput:LMesh')
         IF (ErrStat>=AbortErrLev) RETURN
 END SUBROUTINE SD_CopyInput

 SUBROUTINE SD_DestroyInput( InputData, ErrStat, ErrMsg )
  TYPE(SD_inputtype), INTENT(INOUT) :: InputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  CALL MeshDestroy( InputData%TPMesh, ErrStat, ErrMsg )
  CALL MeshDestroy( InputData%LMesh, ErrStat, ErrMsg )
 END SUBROUTINE SD_DestroyInput

 SUBROUTINE SD_PackInput( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(SD_inputtype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_TPMesh_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_TPMesh_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_TPMesh_Buf(:)
  REAL(ReKi),     ALLOCATABLE :: Re_LMesh_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_LMesh_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_LMesh_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
 ! Allocate mesh buffers, if any (we'll also get sizes from these) 
  CALL MeshPack( InData%TPMesh, Re_TPMesh_Buf, Db_TPMesh_Buf, Int_TPMesh_Buf, ErrStat, ErrMsg, .TRUE. ) ! TPMesh 
  IF(ALLOCATED(Re_TPMesh_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_TPMesh_Buf  ) ! TPMesh
  IF(ALLOCATED(Db_TPMesh_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_TPMesh_Buf  ) ! TPMesh
  IF(ALLOCATED(Int_TPMesh_Buf))Int_BufSz = Int_BufSz + SIZE( Int_TPMesh_Buf ) ! TPMesh
  IF(ALLOCATED(Re_TPMesh_Buf))  DEALLOCATE(Re_TPMesh_Buf)
  IF(ALLOCATED(Db_TPMesh_Buf))  DEALLOCATE(Db_TPMesh_Buf)
  IF(ALLOCATED(Int_TPMesh_Buf)) DEALLOCATE(Int_TPMesh_Buf)
  CALL MeshPack( InData%LMesh, Re_LMesh_Buf, Db_LMesh_Buf, Int_LMesh_Buf, ErrStat, ErrMsg, .TRUE. ) ! LMesh 
  IF(ALLOCATED(Re_LMesh_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_LMesh_Buf  ) ! LMesh
  IF(ALLOCATED(Db_LMesh_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_LMesh_Buf  ) ! LMesh
  IF(ALLOCATED(Int_LMesh_Buf))Int_BufSz = Int_BufSz + SIZE( Int_LMesh_Buf ) ! LMesh
  IF(ALLOCATED(Re_LMesh_Buf))  DEALLOCATE(Re_LMesh_Buf)
  IF(ALLOCATED(Db_LMesh_Buf))  DEALLOCATE(Db_LMesh_Buf)
  IF(ALLOCATED(Int_LMesh_Buf)) DEALLOCATE(Int_LMesh_Buf)
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  CALL MeshPack( InData%TPMesh, Re_TPMesh_Buf, Db_TPMesh_Buf, Int_TPMesh_Buf, ErrStat, ErrMsg, OnlySize ) ! TPMesh 
  IF(ALLOCATED(Re_TPMesh_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_TPMesh_Buf)-1 ) = Re_TPMesh_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_TPMesh_Buf)
  ENDIF
  IF(ALLOCATED(Db_TPMesh_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_TPMesh_Buf)-1 ) = Db_TPMesh_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_TPMesh_Buf)
  ENDIF
  IF(ALLOCATED(Int_TPMesh_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_TPMesh_Buf)-1 ) = Int_TPMesh_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_TPMesh_Buf)
  ENDIF
  IF( ALLOCATED(Re_TPMesh_Buf) )  DEALLOCATE(Re_TPMesh_Buf)
  IF( ALLOCATED(Db_TPMesh_Buf) )  DEALLOCATE(Db_TPMesh_Buf)
  IF( ALLOCATED(Int_TPMesh_Buf) ) DEALLOCATE(Int_TPMesh_Buf)
  CALL MeshPack( InData%LMesh, Re_LMesh_Buf, Db_LMesh_Buf, Int_LMesh_Buf, ErrStat, ErrMsg, OnlySize ) ! LMesh 
  IF(ALLOCATED(Re_LMesh_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_LMesh_Buf)-1 ) = Re_LMesh_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_LMesh_Buf)
  ENDIF
  IF(ALLOCATED(Db_LMesh_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_LMesh_Buf)-1 ) = Db_LMesh_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_LMesh_Buf)
  ENDIF
  IF(ALLOCATED(Int_LMesh_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_LMesh_Buf)-1 ) = Int_LMesh_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_LMesh_Buf)
  ENDIF
  IF( ALLOCATED(Re_LMesh_Buf) )  DEALLOCATE(Re_LMesh_Buf)
  IF( ALLOCATED(Db_LMesh_Buf) )  DEALLOCATE(Db_LMesh_Buf)
  IF( ALLOCATED(Int_LMesh_Buf) ) DEALLOCATE(Int_LMesh_Buf)
 END SUBROUTINE SD_PackInput

 SUBROUTINE SD_UnPackInput( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(SD_inputtype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_TPMesh_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_TPMesh_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_TPMesh_Buf(:)
  REAL(ReKi),    ALLOCATABLE :: Re_LMesh_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_LMesh_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_LMesh_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
 ! first call MeshPack to get correctly sized buffers for unpacking
  CALL MeshPack( OutData%TPMesh, Re_TPMesh_Buf, Db_TPMesh_Buf, Int_TPMesh_Buf, ErrStat, ErrMsg , .TRUE. ) ! TPMesh 
  IF(ALLOCATED(Re_TPMesh_Buf)) THEN
    Re_TPMesh_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_TPMesh_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_TPMesh_Buf)
  ENDIF
  IF(ALLOCATED(Db_TPMesh_Buf)) THEN
    Db_TPMesh_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_TPMesh_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_TPMesh_Buf)
  ENDIF
  IF(ALLOCATED(Int_TPMesh_Buf)) THEN
    Int_TPMesh_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_TPMesh_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_TPMesh_Buf)
  ENDIF
  CALL MeshUnPack( OutData%TPMesh, Re_TPMesh_Buf, Db_TPMesh_Buf, Int_TPMesh_Buf, ErrStat, ErrMsg ) ! TPMesh 
  IF( ALLOCATED(Re_TPMesh_Buf) )  DEALLOCATE(Re_TPMesh_Buf)
  IF( ALLOCATED(Db_TPMesh_Buf) )  DEALLOCATE(Db_TPMesh_Buf)
  IF( ALLOCATED(Int_TPMesh_Buf) ) DEALLOCATE(Int_TPMesh_Buf)
  CALL MeshPack( OutData%LMesh, Re_LMesh_Buf, Db_LMesh_Buf, Int_LMesh_Buf, ErrStat, ErrMsg , .TRUE. ) ! LMesh 
  IF(ALLOCATED(Re_LMesh_Buf)) THEN
    Re_LMesh_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_LMesh_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_LMesh_Buf)
  ENDIF
  IF(ALLOCATED(Db_LMesh_Buf)) THEN
    Db_LMesh_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_LMesh_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_LMesh_Buf)
  ENDIF
  IF(ALLOCATED(Int_LMesh_Buf)) THEN
    Int_LMesh_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_LMesh_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_LMesh_Buf)
  ENDIF
  CALL MeshUnPack( OutData%LMesh, Re_LMesh_Buf, Db_LMesh_Buf, Int_LMesh_Buf, ErrStat, ErrMsg ) ! LMesh 
  IF( ALLOCATED(Re_LMesh_Buf) )  DEALLOCATE(Re_LMesh_Buf)
  IF( ALLOCATED(Db_LMesh_Buf) )  DEALLOCATE(Db_LMesh_Buf)
  IF( ALLOCATED(Int_LMesh_Buf) ) DEALLOCATE(Int_LMesh_Buf)
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE SD_UnPackInput

 SUBROUTINE SD_CopyOutput( SrcOutputData, DstOutputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(SD_outputtype), INTENT(INOUT) :: SrcOutputData
   TYPE(SD_outputtype), INTENT(INOUT) :: DstOutputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
     CALL MeshCopy( SrcOutputData%Y1Mesh, DstOutputData%Y1Mesh, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'SD_CopyOutput:Y1Mesh')
         IF (ErrStat>=AbortErrLev) RETURN
     CALL MeshCopy( SrcOutputData%Y2Mesh, DstOutputData%Y2Mesh, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'SD_CopyOutput:Y2Mesh')
         IF (ErrStat>=AbortErrLev) RETURN
IF (ALLOCATED(SrcOutputData%WriteOutput)) THEN
   i1_l = LBOUND(SrcOutputData%WriteOutput,1)
   i1_u = UBOUND(SrcOutputData%WriteOutput,1)
   IF (.NOT. ALLOCATED(DstOutputData%WriteOutput)) THEN 
      ALLOCATE(DstOutputData%WriteOutput(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOutputData%WriteOutput.', ErrStat, ErrMsg,'SD_CopyOutput')
         RETURN
      END IF
   END IF
   DstOutputData%WriteOutput = SrcOutputData%WriteOutput
ENDIF
 END SUBROUTINE SD_CopyOutput

 SUBROUTINE SD_DestroyOutput( OutputData, ErrStat, ErrMsg )
  TYPE(SD_outputtype), INTENT(INOUT) :: OutputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  CALL MeshDestroy( OutputData%Y1Mesh, ErrStat, ErrMsg )
  CALL MeshDestroy( OutputData%Y2Mesh, ErrStat, ErrMsg )
IF (ALLOCATED(OutputData%WriteOutput)) THEN
   DEALLOCATE(OutputData%WriteOutput)
ENDIF
 END SUBROUTINE SD_DestroyOutput

 SUBROUTINE SD_PackOutput( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(SD_outputtype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_Y1Mesh_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_Y1Mesh_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_Y1Mesh_Buf(:)
  REAL(ReKi),     ALLOCATABLE :: Re_Y2Mesh_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_Y2Mesh_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_Y2Mesh_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
 ! Allocate mesh buffers, if any (we'll also get sizes from these) 
  CALL MeshPack( InData%Y1Mesh, Re_Y1Mesh_Buf, Db_Y1Mesh_Buf, Int_Y1Mesh_Buf, ErrStat, ErrMsg, .TRUE. ) ! Y1Mesh 
  IF(ALLOCATED(Re_Y1Mesh_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_Y1Mesh_Buf  ) ! Y1Mesh
  IF(ALLOCATED(Db_Y1Mesh_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_Y1Mesh_Buf  ) ! Y1Mesh
  IF(ALLOCATED(Int_Y1Mesh_Buf))Int_BufSz = Int_BufSz + SIZE( Int_Y1Mesh_Buf ) ! Y1Mesh
  IF(ALLOCATED(Re_Y1Mesh_Buf))  DEALLOCATE(Re_Y1Mesh_Buf)
  IF(ALLOCATED(Db_Y1Mesh_Buf))  DEALLOCATE(Db_Y1Mesh_Buf)
  IF(ALLOCATED(Int_Y1Mesh_Buf)) DEALLOCATE(Int_Y1Mesh_Buf)
  CALL MeshPack( InData%Y2Mesh, Re_Y2Mesh_Buf, Db_Y2Mesh_Buf, Int_Y2Mesh_Buf, ErrStat, ErrMsg, .TRUE. ) ! Y2Mesh 
  IF(ALLOCATED(Re_Y2Mesh_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_Y2Mesh_Buf  ) ! Y2Mesh
  IF(ALLOCATED(Db_Y2Mesh_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_Y2Mesh_Buf  ) ! Y2Mesh
  IF(ALLOCATED(Int_Y2Mesh_Buf))Int_BufSz = Int_BufSz + SIZE( Int_Y2Mesh_Buf ) ! Y2Mesh
  IF(ALLOCATED(Re_Y2Mesh_Buf))  DEALLOCATE(Re_Y2Mesh_Buf)
  IF(ALLOCATED(Db_Y2Mesh_Buf))  DEALLOCATE(Db_Y2Mesh_Buf)
  IF(ALLOCATED(Int_Y2Mesh_Buf)) DEALLOCATE(Int_Y2Mesh_Buf)
  IF ( ALLOCATED(InData%WriteOutput) )   Re_BufSz    = Re_BufSz    + SIZE( InData%WriteOutput )  ! WriteOutput 
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  CALL MeshPack( InData%Y1Mesh, Re_Y1Mesh_Buf, Db_Y1Mesh_Buf, Int_Y1Mesh_Buf, ErrStat, ErrMsg, OnlySize ) ! Y1Mesh 
  IF(ALLOCATED(Re_Y1Mesh_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Y1Mesh_Buf)-1 ) = Re_Y1Mesh_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_Y1Mesh_Buf)
  ENDIF
  IF(ALLOCATED(Db_Y1Mesh_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Y1Mesh_Buf)-1 ) = Db_Y1Mesh_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_Y1Mesh_Buf)
  ENDIF
  IF(ALLOCATED(Int_Y1Mesh_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Y1Mesh_Buf)-1 ) = Int_Y1Mesh_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_Y1Mesh_Buf)
  ENDIF
  IF( ALLOCATED(Re_Y1Mesh_Buf) )  DEALLOCATE(Re_Y1Mesh_Buf)
  IF( ALLOCATED(Db_Y1Mesh_Buf) )  DEALLOCATE(Db_Y1Mesh_Buf)
  IF( ALLOCATED(Int_Y1Mesh_Buf) ) DEALLOCATE(Int_Y1Mesh_Buf)
  CALL MeshPack( InData%Y2Mesh, Re_Y2Mesh_Buf, Db_Y2Mesh_Buf, Int_Y2Mesh_Buf, ErrStat, ErrMsg, OnlySize ) ! Y2Mesh 
  IF(ALLOCATED(Re_Y2Mesh_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Y2Mesh_Buf)-1 ) = Re_Y2Mesh_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_Y2Mesh_Buf)
  ENDIF
  IF(ALLOCATED(Db_Y2Mesh_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Y2Mesh_Buf)-1 ) = Db_Y2Mesh_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_Y2Mesh_Buf)
  ENDIF
  IF(ALLOCATED(Int_Y2Mesh_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Y2Mesh_Buf)-1 ) = Int_Y2Mesh_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_Y2Mesh_Buf)
  ENDIF
  IF( ALLOCATED(Re_Y2Mesh_Buf) )  DEALLOCATE(Re_Y2Mesh_Buf)
  IF( ALLOCATED(Db_Y2Mesh_Buf) )  DEALLOCATE(Db_Y2Mesh_Buf)
  IF( ALLOCATED(Int_Y2Mesh_Buf) ) DEALLOCATE(Int_Y2Mesh_Buf)
  IF ( ALLOCATED(InData%WriteOutput) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%WriteOutput))-1 ) =  PACK(InData%WriteOutput ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%WriteOutput)
  ENDIF
 END SUBROUTINE SD_PackOutput

 SUBROUTINE SD_UnPackOutput( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(SD_outputtype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_Y1Mesh_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_Y1Mesh_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_Y1Mesh_Buf(:)
  REAL(ReKi),    ALLOCATABLE :: Re_Y2Mesh_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_Y2Mesh_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_Y2Mesh_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
 ! first call MeshPack to get correctly sized buffers for unpacking
  CALL MeshPack( OutData%Y1Mesh, Re_Y1Mesh_Buf, Db_Y1Mesh_Buf, Int_Y1Mesh_Buf, ErrStat, ErrMsg , .TRUE. ) ! Y1Mesh 
  IF(ALLOCATED(Re_Y1Mesh_Buf)) THEN
    Re_Y1Mesh_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Y1Mesh_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_Y1Mesh_Buf)
  ENDIF
  IF(ALLOCATED(Db_Y1Mesh_Buf)) THEN
    Db_Y1Mesh_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Y1Mesh_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_Y1Mesh_Buf)
  ENDIF
  IF(ALLOCATED(Int_Y1Mesh_Buf)) THEN
    Int_Y1Mesh_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Y1Mesh_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_Y1Mesh_Buf)
  ENDIF
  CALL MeshUnPack( OutData%Y1Mesh, Re_Y1Mesh_Buf, Db_Y1Mesh_Buf, Int_Y1Mesh_Buf, ErrStat, ErrMsg ) ! Y1Mesh 
  IF( ALLOCATED(Re_Y1Mesh_Buf) )  DEALLOCATE(Re_Y1Mesh_Buf)
  IF( ALLOCATED(Db_Y1Mesh_Buf) )  DEALLOCATE(Db_Y1Mesh_Buf)
  IF( ALLOCATED(Int_Y1Mesh_Buf) ) DEALLOCATE(Int_Y1Mesh_Buf)
  CALL MeshPack( OutData%Y2Mesh, Re_Y2Mesh_Buf, Db_Y2Mesh_Buf, Int_Y2Mesh_Buf, ErrStat, ErrMsg , .TRUE. ) ! Y2Mesh 
  IF(ALLOCATED(Re_Y2Mesh_Buf)) THEN
    Re_Y2Mesh_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Y2Mesh_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_Y2Mesh_Buf)
  ENDIF
  IF(ALLOCATED(Db_Y2Mesh_Buf)) THEN
    Db_Y2Mesh_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Y2Mesh_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_Y2Mesh_Buf)
  ENDIF
  IF(ALLOCATED(Int_Y2Mesh_Buf)) THEN
    Int_Y2Mesh_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Y2Mesh_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_Y2Mesh_Buf)
  ENDIF
  CALL MeshUnPack( OutData%Y2Mesh, Re_Y2Mesh_Buf, Db_Y2Mesh_Buf, Int_Y2Mesh_Buf, ErrStat, ErrMsg ) ! Y2Mesh 
  IF( ALLOCATED(Re_Y2Mesh_Buf) )  DEALLOCATE(Re_Y2Mesh_Buf)
  IF( ALLOCATED(Db_Y2Mesh_Buf) )  DEALLOCATE(Db_Y2Mesh_Buf)
  IF( ALLOCATED(Int_Y2Mesh_Buf) ) DEALLOCATE(Int_Y2Mesh_Buf)
  IF ( ALLOCATED(OutData%WriteOutput) ) THEN
  ALLOCATE(mask1(SIZE(OutData%WriteOutput,1))); mask1 = .TRUE.
    OutData%WriteOutput = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%WriteOutput))-1 ),mask1,OutData%WriteOutput)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%WriteOutput)
  ENDIF
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE SD_UnPackOutput

 SUBROUTINE SD_CopydYdu( SrcdYduData, DstdYduData, CtrlCode, ErrStat, ErrMsg )
   TYPE(SD_partialoutputpinputtype), INTENT(INOUT) :: SrcdYduData
   TYPE(SD_partialoutputpinputtype), INTENT(INOUT) :: DstdYduData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
      CALL SD_CopyInput( SrcdYduData%DummyOutput, DstdYduData%DummyOutput, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'SD_CopydYdu:DummyOutput')
         IF (ErrStat>=AbortErrLev) RETURN
 END SUBROUTINE SD_CopydYdu

 SUBROUTINE SD_DestroydYdu( dYduData, ErrStat, ErrMsg )
  TYPE(SD_partialoutputpinputtype), INTENT(INOUT) :: dYduData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  CALL SD_DestroyInput( dYduData%DummyOutput, ErrStat, ErrMsg )
 END SUBROUTINE SD_DestroydYdu

 SUBROUTINE SD_PackdYdu( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(SD_partialoutputpinputtype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_DummyOutput_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_DummyOutput_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_DummyOutput_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  CALL SD_PackInput( Re_DummyOutput_Buf, Db_DummyOutput_Buf, Int_DummyOutput_Buf, InData%DummyOutput, ErrStat, ErrMsg, .TRUE. ) ! DummyOutput 
  IF(ALLOCATED(Re_DummyOutput_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_DummyOutput_Buf  ) ! DummyOutput
  IF(ALLOCATED(Db_DummyOutput_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_DummyOutput_Buf  ) ! DummyOutput
  IF(ALLOCATED(Int_DummyOutput_Buf))Int_BufSz = Int_BufSz + SIZE( Int_DummyOutput_Buf ) ! DummyOutput
  IF(ALLOCATED(Re_DummyOutput_Buf))  DEALLOCATE(Re_DummyOutput_Buf)
  IF(ALLOCATED(Db_DummyOutput_Buf))  DEALLOCATE(Db_DummyOutput_Buf)
  IF(ALLOCATED(Int_DummyOutput_Buf)) DEALLOCATE(Int_DummyOutput_Buf)
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  CALL SD_PackInput( Re_DummyOutput_Buf, Db_DummyOutput_Buf, Int_DummyOutput_Buf, InData%DummyOutput, ErrStat, ErrMsg, OnlySize ) ! DummyOutput 
  IF(ALLOCATED(Re_DummyOutput_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_DummyOutput_Buf)-1 ) = Re_DummyOutput_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_DummyOutput_Buf)
  ENDIF
  IF(ALLOCATED(Db_DummyOutput_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_DummyOutput_Buf)-1 ) = Db_DummyOutput_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_DummyOutput_Buf)
  ENDIF
  IF(ALLOCATED(Int_DummyOutput_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_DummyOutput_Buf)-1 ) = Int_DummyOutput_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_DummyOutput_Buf)
  ENDIF
  IF( ALLOCATED(Re_DummyOutput_Buf) )  DEALLOCATE(Re_DummyOutput_Buf)
  IF( ALLOCATED(Db_DummyOutput_Buf) )  DEALLOCATE(Db_DummyOutput_Buf)
  IF( ALLOCATED(Int_DummyOutput_Buf) ) DEALLOCATE(Int_DummyOutput_Buf)
 END SUBROUTINE SD_PackdYdu

 SUBROUTINE SD_UnPackdYdu( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(SD_partialoutputpinputtype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_DummyOutput_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_DummyOutput_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_DummyOutput_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
 ! first call SD_PackInput to get correctly sized buffers for unpacking
  CALL SD_PackInput( Re_DummyOutput_Buf, Db_DummyOutput_Buf, Int_DummyOutput_Buf, OutData%DummyOutput, ErrStat, ErrMsg, .TRUE. ) ! DummyOutput 
  IF(ALLOCATED(Re_DummyOutput_Buf)) THEN
    Re_DummyOutput_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_DummyOutput_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_DummyOutput_Buf)
  ENDIF
  IF(ALLOCATED(Db_DummyOutput_Buf)) THEN
    Db_DummyOutput_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_DummyOutput_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_DummyOutput_Buf)
  ENDIF
  IF(ALLOCATED(Int_DummyOutput_Buf)) THEN
    Int_DummyOutput_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_DummyOutput_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_DummyOutput_Buf)
  ENDIF
  CALL SD_UnPackInput( Re_DummyOutput_Buf, Db_DummyOutput_Buf, Int_DummyOutput_Buf, OutData%DummyOutput, ErrStat, ErrMsg ) ! DummyOutput 
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE SD_UnPackdYdu

 SUBROUTINE SD_CopydXdu( SrcdXduData, DstdXduData, CtrlCode, ErrStat, ErrMsg )
   TYPE(SD_partialcontstatepinputtype), INTENT(INOUT) :: SrcdXduData
   TYPE(SD_partialcontstatepinputtype), INTENT(INOUT) :: DstdXduData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
      CALL SD_CopyInput( SrcdXduData%DummyContState, DstdXduData%DummyContState, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'SD_CopydXdu:DummyContState')
         IF (ErrStat>=AbortErrLev) RETURN
 END SUBROUTINE SD_CopydXdu

 SUBROUTINE SD_DestroydXdu( dXduData, ErrStat, ErrMsg )
  TYPE(SD_partialcontstatepinputtype), INTENT(INOUT) :: dXduData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  CALL SD_DestroyInput( dXduData%DummyContState, ErrStat, ErrMsg )
 END SUBROUTINE SD_DestroydXdu

 SUBROUTINE SD_PackdXdu( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(SD_partialcontstatepinputtype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_DummyContState_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_DummyContState_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_DummyContState_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  CALL SD_PackInput( Re_DummyContState_Buf, Db_DummyContState_Buf, Int_DummyContState_Buf, InData%DummyContState, ErrStat, ErrMsg, .TRUE. ) ! DummyContState 
  IF(ALLOCATED(Re_DummyContState_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_DummyContState_Buf  ) ! DummyContState
  IF(ALLOCATED(Db_DummyContState_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_DummyContState_Buf  ) ! DummyContState
  IF(ALLOCATED(Int_DummyContState_Buf))Int_BufSz = Int_BufSz + SIZE( Int_DummyContState_Buf ) ! DummyContState
  IF(ALLOCATED(Re_DummyContState_Buf))  DEALLOCATE(Re_DummyContState_Buf)
  IF(ALLOCATED(Db_DummyContState_Buf))  DEALLOCATE(Db_DummyContState_Buf)
  IF(ALLOCATED(Int_DummyContState_Buf)) DEALLOCATE(Int_DummyContState_Buf)
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  CALL SD_PackInput( Re_DummyContState_Buf, Db_DummyContState_Buf, Int_DummyContState_Buf, InData%DummyContState, ErrStat, ErrMsg, OnlySize ) ! DummyContState 
  IF(ALLOCATED(Re_DummyContState_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_DummyContState_Buf)-1 ) = Re_DummyContState_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_DummyContState_Buf)
  ENDIF
  IF(ALLOCATED(Db_DummyContState_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_DummyContState_Buf)-1 ) = Db_DummyContState_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_DummyContState_Buf)
  ENDIF
  IF(ALLOCATED(Int_DummyContState_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_DummyContState_Buf)-1 ) = Int_DummyContState_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_DummyContState_Buf)
  ENDIF
  IF( ALLOCATED(Re_DummyContState_Buf) )  DEALLOCATE(Re_DummyContState_Buf)
  IF( ALLOCATED(Db_DummyContState_Buf) )  DEALLOCATE(Db_DummyContState_Buf)
  IF( ALLOCATED(Int_DummyContState_Buf) ) DEALLOCATE(Int_DummyContState_Buf)
 END SUBROUTINE SD_PackdXdu

 SUBROUTINE SD_UnPackdXdu( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(SD_partialcontstatepinputtype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_DummyContState_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_DummyContState_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_DummyContState_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
 ! first call SD_PackInput to get correctly sized buffers for unpacking
  CALL SD_PackInput( Re_DummyContState_Buf, Db_DummyContState_Buf, Int_DummyContState_Buf, OutData%DummyContState, ErrStat, ErrMsg, .TRUE. ) ! DummyContState 
  IF(ALLOCATED(Re_DummyContState_Buf)) THEN
    Re_DummyContState_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_DummyContState_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_DummyContState_Buf)
  ENDIF
  IF(ALLOCATED(Db_DummyContState_Buf)) THEN
    Db_DummyContState_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_DummyContState_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_DummyContState_Buf)
  ENDIF
  IF(ALLOCATED(Int_DummyContState_Buf)) THEN
    Int_DummyContState_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_DummyContState_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_DummyContState_Buf)
  ENDIF
  CALL SD_UnPackInput( Re_DummyContState_Buf, Db_DummyContState_Buf, Int_DummyContState_Buf, OutData%DummyContState, ErrStat, ErrMsg ) ! DummyContState 
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE SD_UnPackdXdu

 SUBROUTINE SD_CopydXddu( SrcdXdduData, DstdXdduData, CtrlCode, ErrStat, ErrMsg )
   TYPE(SD_partialdiscstatepinputtype), INTENT(INOUT) :: SrcdXdduData
   TYPE(SD_partialdiscstatepinputtype), INTENT(INOUT) :: DstdXdduData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
      CALL SD_CopyInput( SrcdXdduData%DummyDiscState, DstdXdduData%DummyDiscState, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'SD_CopydXddu:DummyDiscState')
         IF (ErrStat>=AbortErrLev) RETURN
 END SUBROUTINE SD_CopydXddu

 SUBROUTINE SD_DestroydXddu( dXdduData, ErrStat, ErrMsg )
  TYPE(SD_partialdiscstatepinputtype), INTENT(INOUT) :: dXdduData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  CALL SD_DestroyInput( dXdduData%DummyDiscState, ErrStat, ErrMsg )
 END SUBROUTINE SD_DestroydXddu

 SUBROUTINE SD_PackdXddu( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(SD_partialdiscstatepinputtype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_DummyDiscState_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_DummyDiscState_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_DummyDiscState_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  CALL SD_PackInput( Re_DummyDiscState_Buf, Db_DummyDiscState_Buf, Int_DummyDiscState_Buf, InData%DummyDiscState, ErrStat, ErrMsg, .TRUE. ) ! DummyDiscState 
  IF(ALLOCATED(Re_DummyDiscState_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_DummyDiscState_Buf  ) ! DummyDiscState
  IF(ALLOCATED(Db_DummyDiscState_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_DummyDiscState_Buf  ) ! DummyDiscState
  IF(ALLOCATED(Int_DummyDiscState_Buf))Int_BufSz = Int_BufSz + SIZE( Int_DummyDiscState_Buf ) ! DummyDiscState
  IF(ALLOCATED(Re_DummyDiscState_Buf))  DEALLOCATE(Re_DummyDiscState_Buf)
  IF(ALLOCATED(Db_DummyDiscState_Buf))  DEALLOCATE(Db_DummyDiscState_Buf)
  IF(ALLOCATED(Int_DummyDiscState_Buf)) DEALLOCATE(Int_DummyDiscState_Buf)
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  CALL SD_PackInput( Re_DummyDiscState_Buf, Db_DummyDiscState_Buf, Int_DummyDiscState_Buf, InData%DummyDiscState, ErrStat, ErrMsg, OnlySize ) ! DummyDiscState 
  IF(ALLOCATED(Re_DummyDiscState_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_DummyDiscState_Buf)-1 ) = Re_DummyDiscState_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_DummyDiscState_Buf)
  ENDIF
  IF(ALLOCATED(Db_DummyDiscState_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_DummyDiscState_Buf)-1 ) = Db_DummyDiscState_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_DummyDiscState_Buf)
  ENDIF
  IF(ALLOCATED(Int_DummyDiscState_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_DummyDiscState_Buf)-1 ) = Int_DummyDiscState_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_DummyDiscState_Buf)
  ENDIF
  IF( ALLOCATED(Re_DummyDiscState_Buf) )  DEALLOCATE(Re_DummyDiscState_Buf)
  IF( ALLOCATED(Db_DummyDiscState_Buf) )  DEALLOCATE(Db_DummyDiscState_Buf)
  IF( ALLOCATED(Int_DummyDiscState_Buf) ) DEALLOCATE(Int_DummyDiscState_Buf)
 END SUBROUTINE SD_PackdXddu

 SUBROUTINE SD_UnPackdXddu( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(SD_partialdiscstatepinputtype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_DummyDiscState_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_DummyDiscState_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_DummyDiscState_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
 ! first call SD_PackInput to get correctly sized buffers for unpacking
  CALL SD_PackInput( Re_DummyDiscState_Buf, Db_DummyDiscState_Buf, Int_DummyDiscState_Buf, OutData%DummyDiscState, ErrStat, ErrMsg, .TRUE. ) ! DummyDiscState 
  IF(ALLOCATED(Re_DummyDiscState_Buf)) THEN
    Re_DummyDiscState_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_DummyDiscState_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_DummyDiscState_Buf)
  ENDIF
  IF(ALLOCATED(Db_DummyDiscState_Buf)) THEN
    Db_DummyDiscState_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_DummyDiscState_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_DummyDiscState_Buf)
  ENDIF
  IF(ALLOCATED(Int_DummyDiscState_Buf)) THEN
    Int_DummyDiscState_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_DummyDiscState_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_DummyDiscState_Buf)
  ENDIF
  CALL SD_UnPackInput( Re_DummyDiscState_Buf, Db_DummyDiscState_Buf, Int_DummyDiscState_Buf, OutData%DummyDiscState, ErrStat, ErrMsg ) ! DummyDiscState 
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE SD_UnPackdXddu

 SUBROUTINE SD_CopydZdu( SrcdZduData, DstdZduData, CtrlCode, ErrStat, ErrMsg )
   TYPE(SD_partialconstrstatepinputtype), INTENT(INOUT) :: SrcdZduData
   TYPE(SD_partialconstrstatepinputtype), INTENT(INOUT) :: DstdZduData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
      CALL SD_CopyInput( SrcdZduData%DummyConstrState, DstdZduData%DummyConstrState, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'SD_CopydZdu:DummyConstrState')
         IF (ErrStat>=AbortErrLev) RETURN
 END SUBROUTINE SD_CopydZdu

 SUBROUTINE SD_DestroydZdu( dZduData, ErrStat, ErrMsg )
  TYPE(SD_partialconstrstatepinputtype), INTENT(INOUT) :: dZduData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  CALL SD_DestroyInput( dZduData%DummyConstrState, ErrStat, ErrMsg )
 END SUBROUTINE SD_DestroydZdu

 SUBROUTINE SD_PackdZdu( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(SD_partialconstrstatepinputtype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_DummyConstrState_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_DummyConstrState_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_DummyConstrState_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  CALL SD_PackInput( Re_DummyConstrState_Buf, Db_DummyConstrState_Buf, Int_DummyConstrState_Buf, InData%DummyConstrState, ErrStat, ErrMsg, .TRUE. ) ! DummyConstrState 
  IF(ALLOCATED(Re_DummyConstrState_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_DummyConstrState_Buf  ) ! DummyConstrState
  IF(ALLOCATED(Db_DummyConstrState_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_DummyConstrState_Buf  ) ! DummyConstrState
  IF(ALLOCATED(Int_DummyConstrState_Buf))Int_BufSz = Int_BufSz + SIZE( Int_DummyConstrState_Buf ) ! DummyConstrState
  IF(ALLOCATED(Re_DummyConstrState_Buf))  DEALLOCATE(Re_DummyConstrState_Buf)
  IF(ALLOCATED(Db_DummyConstrState_Buf))  DEALLOCATE(Db_DummyConstrState_Buf)
  IF(ALLOCATED(Int_DummyConstrState_Buf)) DEALLOCATE(Int_DummyConstrState_Buf)
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  CALL SD_PackInput( Re_DummyConstrState_Buf, Db_DummyConstrState_Buf, Int_DummyConstrState_Buf, InData%DummyConstrState, ErrStat, ErrMsg, OnlySize ) ! DummyConstrState 
  IF(ALLOCATED(Re_DummyConstrState_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_DummyConstrState_Buf)-1 ) = Re_DummyConstrState_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_DummyConstrState_Buf)
  ENDIF
  IF(ALLOCATED(Db_DummyConstrState_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_DummyConstrState_Buf)-1 ) = Db_DummyConstrState_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_DummyConstrState_Buf)
  ENDIF
  IF(ALLOCATED(Int_DummyConstrState_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_DummyConstrState_Buf)-1 ) = Int_DummyConstrState_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_DummyConstrState_Buf)
  ENDIF
  IF( ALLOCATED(Re_DummyConstrState_Buf) )  DEALLOCATE(Re_DummyConstrState_Buf)
  IF( ALLOCATED(Db_DummyConstrState_Buf) )  DEALLOCATE(Db_DummyConstrState_Buf)
  IF( ALLOCATED(Int_DummyConstrState_Buf) ) DEALLOCATE(Int_DummyConstrState_Buf)
 END SUBROUTINE SD_PackdZdu

 SUBROUTINE SD_UnPackdZdu( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(SD_partialconstrstatepinputtype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_DummyConstrState_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_DummyConstrState_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_DummyConstrState_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
 ! first call SD_PackInput to get correctly sized buffers for unpacking
  CALL SD_PackInput( Re_DummyConstrState_Buf, Db_DummyConstrState_Buf, Int_DummyConstrState_Buf, OutData%DummyConstrState, ErrStat, ErrMsg, .TRUE. ) ! DummyConstrState 
  IF(ALLOCATED(Re_DummyConstrState_Buf)) THEN
    Re_DummyConstrState_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_DummyConstrState_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_DummyConstrState_Buf)
  ENDIF
  IF(ALLOCATED(Db_DummyConstrState_Buf)) THEN
    Db_DummyConstrState_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_DummyConstrState_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_DummyConstrState_Buf)
  ENDIF
  IF(ALLOCATED(Int_DummyConstrState_Buf)) THEN
    Int_DummyConstrState_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_DummyConstrState_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_DummyConstrState_Buf)
  ENDIF
  CALL SD_UnPackInput( Re_DummyConstrState_Buf, Db_DummyConstrState_Buf, Int_DummyConstrState_Buf, OutData%DummyConstrState, ErrStat, ErrMsg ) ! DummyConstrState 
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE SD_UnPackdZdu

 SUBROUTINE SD_Copypartialoutputpcontstatetype( SrcpartialoutputpcontstatetypeData, DstpartialoutputpcontstatetypeData, CtrlCode, ErrStat, ErrMsg )
   TYPE(sd_partialoutputpcontstatetype), INTENT(INOUT) :: SrcpartialoutputpcontstatetypeData
   TYPE(sd_partialoutputpcontstatetype), INTENT(INOUT) :: DstpartialoutputpcontstatetypeData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
      CALL SD_CopyContState( SrcpartialoutputpcontstatetypeData%DummyOutput, DstpartialoutputpcontstatetypeData%DummyOutput, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'SD_Copypartialoutputpcontstatetype:DummyOutput')
         IF (ErrStat>=AbortErrLev) RETURN
 END SUBROUTINE SD_Copypartialoutputpcontstatetype

 SUBROUTINE SD_Destroypartialoutputpcontstatetype( partialoutputpcontstatetypeData, ErrStat, ErrMsg )
  TYPE(sd_partialoutputpcontstatetype), INTENT(INOUT) :: partialoutputpcontstatetypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  CALL SD_DestroyContState( partialoutputpcontstatetypeData%DummyOutput, ErrStat, ErrMsg )
 END SUBROUTINE SD_Destroypartialoutputpcontstatetype

 SUBROUTINE SD_Packpartialoutputpcontstatetype( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(sd_partialoutputpcontstatetype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_DummyOutput_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_DummyOutput_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_DummyOutput_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  CALL SD_PackContState( Re_DummyOutput_Buf, Db_DummyOutput_Buf, Int_DummyOutput_Buf, InData%DummyOutput, ErrStat, ErrMsg, .TRUE. ) ! DummyOutput 
  IF(ALLOCATED(Re_DummyOutput_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_DummyOutput_Buf  ) ! DummyOutput
  IF(ALLOCATED(Db_DummyOutput_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_DummyOutput_Buf  ) ! DummyOutput
  IF(ALLOCATED(Int_DummyOutput_Buf))Int_BufSz = Int_BufSz + SIZE( Int_DummyOutput_Buf ) ! DummyOutput
  IF(ALLOCATED(Re_DummyOutput_Buf))  DEALLOCATE(Re_DummyOutput_Buf)
  IF(ALLOCATED(Db_DummyOutput_Buf))  DEALLOCATE(Db_DummyOutput_Buf)
  IF(ALLOCATED(Int_DummyOutput_Buf)) DEALLOCATE(Int_DummyOutput_Buf)
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  CALL SD_PackContState( Re_DummyOutput_Buf, Db_DummyOutput_Buf, Int_DummyOutput_Buf, InData%DummyOutput, ErrStat, ErrMsg, OnlySize ) ! DummyOutput 
  IF(ALLOCATED(Re_DummyOutput_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_DummyOutput_Buf)-1 ) = Re_DummyOutput_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_DummyOutput_Buf)
  ENDIF
  IF(ALLOCATED(Db_DummyOutput_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_DummyOutput_Buf)-1 ) = Db_DummyOutput_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_DummyOutput_Buf)
  ENDIF
  IF(ALLOCATED(Int_DummyOutput_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_DummyOutput_Buf)-1 ) = Int_DummyOutput_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_DummyOutput_Buf)
  ENDIF
  IF( ALLOCATED(Re_DummyOutput_Buf) )  DEALLOCATE(Re_DummyOutput_Buf)
  IF( ALLOCATED(Db_DummyOutput_Buf) )  DEALLOCATE(Db_DummyOutput_Buf)
  IF( ALLOCATED(Int_DummyOutput_Buf) ) DEALLOCATE(Int_DummyOutput_Buf)
 END SUBROUTINE SD_Packpartialoutputpcontstatetype

 SUBROUTINE SD_UnPackpartialoutputpcontstatetype( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(sd_partialoutputpcontstatetype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_DummyOutput_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_DummyOutput_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_DummyOutput_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
 ! first call SD_PackContState to get correctly sized buffers for unpacking
  CALL SD_PackContState( Re_DummyOutput_Buf, Db_DummyOutput_Buf, Int_DummyOutput_Buf, OutData%DummyOutput, ErrStat, ErrMsg, .TRUE. ) ! DummyOutput 
  IF(ALLOCATED(Re_DummyOutput_Buf)) THEN
    Re_DummyOutput_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_DummyOutput_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_DummyOutput_Buf)
  ENDIF
  IF(ALLOCATED(Db_DummyOutput_Buf)) THEN
    Db_DummyOutput_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_DummyOutput_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_DummyOutput_Buf)
  ENDIF
  IF(ALLOCATED(Int_DummyOutput_Buf)) THEN
    Int_DummyOutput_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_DummyOutput_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_DummyOutput_Buf)
  ENDIF
  CALL SD_UnPackContState( Re_DummyOutput_Buf, Db_DummyOutput_Buf, Int_DummyOutput_Buf, OutData%DummyOutput, ErrStat, ErrMsg ) ! DummyOutput 
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE SD_UnPackpartialoutputpcontstatetype

 SUBROUTINE SD_Copypartialcontstatepcontstatetype( SrcpartialcontstatepcontstatetypeData, DstpartialcontstatepcontstatetypeData, CtrlCode, ErrStat, ErrMsg )
   TYPE(sd_partialcontstatepcontstatetype), INTENT(INOUT) :: SrcpartialcontstatepcontstatetypeData
   TYPE(sd_partialcontstatepcontstatetype), INTENT(INOUT) :: DstpartialcontstatepcontstatetypeData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
      CALL SD_CopyContState( SrcpartialcontstatepcontstatetypeData%DummyContState, DstpartialcontstatepcontstatetypeData%DummyContState, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'SD_Copypartialcontstatepcontstatetype:DummyContState')
         IF (ErrStat>=AbortErrLev) RETURN
 END SUBROUTINE SD_Copypartialcontstatepcontstatetype

 SUBROUTINE SD_Destroypartialcontstatepcontstatetype( partialcontstatepcontstatetypeData, ErrStat, ErrMsg )
  TYPE(sd_partialcontstatepcontstatetype), INTENT(INOUT) :: partialcontstatepcontstatetypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  CALL SD_DestroyContState( partialcontstatepcontstatetypeData%DummyContState, ErrStat, ErrMsg )
 END SUBROUTINE SD_Destroypartialcontstatepcontstatetype

 SUBROUTINE SD_Packpartialcontstatepcontstatetype( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(sd_partialcontstatepcontstatetype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_DummyContState_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_DummyContState_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_DummyContState_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  CALL SD_PackContState( Re_DummyContState_Buf, Db_DummyContState_Buf, Int_DummyContState_Buf, InData%DummyContState, ErrStat, ErrMsg, .TRUE. ) ! DummyContState 
  IF(ALLOCATED(Re_DummyContState_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_DummyContState_Buf  ) ! DummyContState
  IF(ALLOCATED(Db_DummyContState_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_DummyContState_Buf  ) ! DummyContState
  IF(ALLOCATED(Int_DummyContState_Buf))Int_BufSz = Int_BufSz + SIZE( Int_DummyContState_Buf ) ! DummyContState
  IF(ALLOCATED(Re_DummyContState_Buf))  DEALLOCATE(Re_DummyContState_Buf)
  IF(ALLOCATED(Db_DummyContState_Buf))  DEALLOCATE(Db_DummyContState_Buf)
  IF(ALLOCATED(Int_DummyContState_Buf)) DEALLOCATE(Int_DummyContState_Buf)
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  CALL SD_PackContState( Re_DummyContState_Buf, Db_DummyContState_Buf, Int_DummyContState_Buf, InData%DummyContState, ErrStat, ErrMsg, OnlySize ) ! DummyContState 
  IF(ALLOCATED(Re_DummyContState_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_DummyContState_Buf)-1 ) = Re_DummyContState_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_DummyContState_Buf)
  ENDIF
  IF(ALLOCATED(Db_DummyContState_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_DummyContState_Buf)-1 ) = Db_DummyContState_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_DummyContState_Buf)
  ENDIF
  IF(ALLOCATED(Int_DummyContState_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_DummyContState_Buf)-1 ) = Int_DummyContState_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_DummyContState_Buf)
  ENDIF
  IF( ALLOCATED(Re_DummyContState_Buf) )  DEALLOCATE(Re_DummyContState_Buf)
  IF( ALLOCATED(Db_DummyContState_Buf) )  DEALLOCATE(Db_DummyContState_Buf)
  IF( ALLOCATED(Int_DummyContState_Buf) ) DEALLOCATE(Int_DummyContState_Buf)
 END SUBROUTINE SD_Packpartialcontstatepcontstatetype

 SUBROUTINE SD_UnPackpartialcontstatepcontstatetype( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(sd_partialcontstatepcontstatetype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_DummyContState_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_DummyContState_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_DummyContState_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
 ! first call SD_PackContState to get correctly sized buffers for unpacking
  CALL SD_PackContState( Re_DummyContState_Buf, Db_DummyContState_Buf, Int_DummyContState_Buf, OutData%DummyContState, ErrStat, ErrMsg, .TRUE. ) ! DummyContState 
  IF(ALLOCATED(Re_DummyContState_Buf)) THEN
    Re_DummyContState_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_DummyContState_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_DummyContState_Buf)
  ENDIF
  IF(ALLOCATED(Db_DummyContState_Buf)) THEN
    Db_DummyContState_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_DummyContState_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_DummyContState_Buf)
  ENDIF
  IF(ALLOCATED(Int_DummyContState_Buf)) THEN
    Int_DummyContState_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_DummyContState_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_DummyContState_Buf)
  ENDIF
  CALL SD_UnPackContState( Re_DummyContState_Buf, Db_DummyContState_Buf, Int_DummyContState_Buf, OutData%DummyContState, ErrStat, ErrMsg ) ! DummyContState 
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE SD_UnPackpartialcontstatepcontstatetype

 SUBROUTINE SD_Copypartialdiscstatepcontstatetype( SrcpartialdiscstatepcontstatetypeData, DstpartialdiscstatepcontstatetypeData, CtrlCode, ErrStat, ErrMsg )
   TYPE(sd_partialdiscstatepcontstatetype), INTENT(INOUT) :: SrcpartialdiscstatepcontstatetypeData
   TYPE(sd_partialdiscstatepcontstatetype), INTENT(INOUT) :: DstpartialdiscstatepcontstatetypeData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
      CALL SD_CopyContState( SrcpartialdiscstatepcontstatetypeData%DummyDiscState, DstpartialdiscstatepcontstatetypeData%DummyDiscState, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'SD_Copypartialdiscstatepcontstatetype:DummyDiscState')
         IF (ErrStat>=AbortErrLev) RETURN
 END SUBROUTINE SD_Copypartialdiscstatepcontstatetype

 SUBROUTINE SD_Destroypartialdiscstatepcontstatetype( partialdiscstatepcontstatetypeData, ErrStat, ErrMsg )
  TYPE(sd_partialdiscstatepcontstatetype), INTENT(INOUT) :: partialdiscstatepcontstatetypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  CALL SD_DestroyContState( partialdiscstatepcontstatetypeData%DummyDiscState, ErrStat, ErrMsg )
 END SUBROUTINE SD_Destroypartialdiscstatepcontstatetype

 SUBROUTINE SD_Packpartialdiscstatepcontstatetype( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(sd_partialdiscstatepcontstatetype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_DummyDiscState_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_DummyDiscState_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_DummyDiscState_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  CALL SD_PackContState( Re_DummyDiscState_Buf, Db_DummyDiscState_Buf, Int_DummyDiscState_Buf, InData%DummyDiscState, ErrStat, ErrMsg, .TRUE. ) ! DummyDiscState 
  IF(ALLOCATED(Re_DummyDiscState_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_DummyDiscState_Buf  ) ! DummyDiscState
  IF(ALLOCATED(Db_DummyDiscState_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_DummyDiscState_Buf  ) ! DummyDiscState
  IF(ALLOCATED(Int_DummyDiscState_Buf))Int_BufSz = Int_BufSz + SIZE( Int_DummyDiscState_Buf ) ! DummyDiscState
  IF(ALLOCATED(Re_DummyDiscState_Buf))  DEALLOCATE(Re_DummyDiscState_Buf)
  IF(ALLOCATED(Db_DummyDiscState_Buf))  DEALLOCATE(Db_DummyDiscState_Buf)
  IF(ALLOCATED(Int_DummyDiscState_Buf)) DEALLOCATE(Int_DummyDiscState_Buf)
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  CALL SD_PackContState( Re_DummyDiscState_Buf, Db_DummyDiscState_Buf, Int_DummyDiscState_Buf, InData%DummyDiscState, ErrStat, ErrMsg, OnlySize ) ! DummyDiscState 
  IF(ALLOCATED(Re_DummyDiscState_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_DummyDiscState_Buf)-1 ) = Re_DummyDiscState_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_DummyDiscState_Buf)
  ENDIF
  IF(ALLOCATED(Db_DummyDiscState_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_DummyDiscState_Buf)-1 ) = Db_DummyDiscState_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_DummyDiscState_Buf)
  ENDIF
  IF(ALLOCATED(Int_DummyDiscState_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_DummyDiscState_Buf)-1 ) = Int_DummyDiscState_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_DummyDiscState_Buf)
  ENDIF
  IF( ALLOCATED(Re_DummyDiscState_Buf) )  DEALLOCATE(Re_DummyDiscState_Buf)
  IF( ALLOCATED(Db_DummyDiscState_Buf) )  DEALLOCATE(Db_DummyDiscState_Buf)
  IF( ALLOCATED(Int_DummyDiscState_Buf) ) DEALLOCATE(Int_DummyDiscState_Buf)
 END SUBROUTINE SD_Packpartialdiscstatepcontstatetype

 SUBROUTINE SD_UnPackpartialdiscstatepcontstatetype( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(sd_partialdiscstatepcontstatetype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_DummyDiscState_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_DummyDiscState_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_DummyDiscState_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
 ! first call SD_PackContState to get correctly sized buffers for unpacking
  CALL SD_PackContState( Re_DummyDiscState_Buf, Db_DummyDiscState_Buf, Int_DummyDiscState_Buf, OutData%DummyDiscState, ErrStat, ErrMsg, .TRUE. ) ! DummyDiscState 
  IF(ALLOCATED(Re_DummyDiscState_Buf)) THEN
    Re_DummyDiscState_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_DummyDiscState_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_DummyDiscState_Buf)
  ENDIF
  IF(ALLOCATED(Db_DummyDiscState_Buf)) THEN
    Db_DummyDiscState_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_DummyDiscState_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_DummyDiscState_Buf)
  ENDIF
  IF(ALLOCATED(Int_DummyDiscState_Buf)) THEN
    Int_DummyDiscState_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_DummyDiscState_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_DummyDiscState_Buf)
  ENDIF
  CALL SD_UnPackContState( Re_DummyDiscState_Buf, Db_DummyDiscState_Buf, Int_DummyDiscState_Buf, OutData%DummyDiscState, ErrStat, ErrMsg ) ! DummyDiscState 
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE SD_UnPackpartialdiscstatepcontstatetype

 SUBROUTINE SD_Copypartialconstrstatepcontstatetype( SrcpartialconstrstatepcontstatetypeData, DstpartialconstrstatepcontstatetypeData, CtrlCode, ErrStat, ErrMsg )
   TYPE(sd_partialconstrstatepcontstatetype), INTENT(INOUT) :: SrcpartialconstrstatepcontstatetypeData
   TYPE(sd_partialconstrstatepcontstatetype), INTENT(INOUT) :: DstpartialconstrstatepcontstatetypeData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
      CALL SD_CopyContState( SrcpartialconstrstatepcontstatetypeData%DummyConstrState, DstpartialconstrstatepcontstatetypeData%DummyConstrState, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'SD_Copypartialconstrstatepcontstatetype:DummyConstrState')
         IF (ErrStat>=AbortErrLev) RETURN
 END SUBROUTINE SD_Copypartialconstrstatepcontstatetype

 SUBROUTINE SD_Destroypartialconstrstatepcontstatetype( partialconstrstatepcontstatetypeData, ErrStat, ErrMsg )
  TYPE(sd_partialconstrstatepcontstatetype), INTENT(INOUT) :: partialconstrstatepcontstatetypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  CALL SD_DestroyContState( partialconstrstatepcontstatetypeData%DummyConstrState, ErrStat, ErrMsg )
 END SUBROUTINE SD_Destroypartialconstrstatepcontstatetype

 SUBROUTINE SD_Packpartialconstrstatepcontstatetype( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(sd_partialconstrstatepcontstatetype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_DummyConstrState_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_DummyConstrState_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_DummyConstrState_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  CALL SD_PackContState( Re_DummyConstrState_Buf, Db_DummyConstrState_Buf, Int_DummyConstrState_Buf, InData%DummyConstrState, ErrStat, ErrMsg, .TRUE. ) ! DummyConstrState 
  IF(ALLOCATED(Re_DummyConstrState_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_DummyConstrState_Buf  ) ! DummyConstrState
  IF(ALLOCATED(Db_DummyConstrState_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_DummyConstrState_Buf  ) ! DummyConstrState
  IF(ALLOCATED(Int_DummyConstrState_Buf))Int_BufSz = Int_BufSz + SIZE( Int_DummyConstrState_Buf ) ! DummyConstrState
  IF(ALLOCATED(Re_DummyConstrState_Buf))  DEALLOCATE(Re_DummyConstrState_Buf)
  IF(ALLOCATED(Db_DummyConstrState_Buf))  DEALLOCATE(Db_DummyConstrState_Buf)
  IF(ALLOCATED(Int_DummyConstrState_Buf)) DEALLOCATE(Int_DummyConstrState_Buf)
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  CALL SD_PackContState( Re_DummyConstrState_Buf, Db_DummyConstrState_Buf, Int_DummyConstrState_Buf, InData%DummyConstrState, ErrStat, ErrMsg, OnlySize ) ! DummyConstrState 
  IF(ALLOCATED(Re_DummyConstrState_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_DummyConstrState_Buf)-1 ) = Re_DummyConstrState_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_DummyConstrState_Buf)
  ENDIF
  IF(ALLOCATED(Db_DummyConstrState_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_DummyConstrState_Buf)-1 ) = Db_DummyConstrState_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_DummyConstrState_Buf)
  ENDIF
  IF(ALLOCATED(Int_DummyConstrState_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_DummyConstrState_Buf)-1 ) = Int_DummyConstrState_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_DummyConstrState_Buf)
  ENDIF
  IF( ALLOCATED(Re_DummyConstrState_Buf) )  DEALLOCATE(Re_DummyConstrState_Buf)
  IF( ALLOCATED(Db_DummyConstrState_Buf) )  DEALLOCATE(Db_DummyConstrState_Buf)
  IF( ALLOCATED(Int_DummyConstrState_Buf) ) DEALLOCATE(Int_DummyConstrState_Buf)
 END SUBROUTINE SD_Packpartialconstrstatepcontstatetype

 SUBROUTINE SD_UnPackpartialconstrstatepcontstatetype( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(sd_partialconstrstatepcontstatetype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_DummyConstrState_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_DummyConstrState_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_DummyConstrState_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
 ! first call SD_PackContState to get correctly sized buffers for unpacking
  CALL SD_PackContState( Re_DummyConstrState_Buf, Db_DummyConstrState_Buf, Int_DummyConstrState_Buf, OutData%DummyConstrState, ErrStat, ErrMsg, .TRUE. ) ! DummyConstrState 
  IF(ALLOCATED(Re_DummyConstrState_Buf)) THEN
    Re_DummyConstrState_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_DummyConstrState_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_DummyConstrState_Buf)
  ENDIF
  IF(ALLOCATED(Db_DummyConstrState_Buf)) THEN
    Db_DummyConstrState_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_DummyConstrState_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_DummyConstrState_Buf)
  ENDIF
  IF(ALLOCATED(Int_DummyConstrState_Buf)) THEN
    Int_DummyConstrState_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_DummyConstrState_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_DummyConstrState_Buf)
  ENDIF
  CALL SD_UnPackContState( Re_DummyConstrState_Buf, Db_DummyConstrState_Buf, Int_DummyConstrState_Buf, OutData%DummyConstrState, ErrStat, ErrMsg ) ! DummyConstrState 
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE SD_UnPackpartialconstrstatepcontstatetype

 SUBROUTINE SD_Copypartialoutputpdiscstatetype( SrcpartialoutputpdiscstatetypeData, DstpartialoutputpdiscstatetypeData, CtrlCode, ErrStat, ErrMsg )
   TYPE(sd_partialoutputpdiscstatetype), INTENT(INOUT) :: SrcpartialoutputpdiscstatetypeData
   TYPE(sd_partialoutputpdiscstatetype), INTENT(INOUT) :: DstpartialoutputpdiscstatetypeData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
      CALL SD_CopyDiscState( SrcpartialoutputpdiscstatetypeData%DummyOutput, DstpartialoutputpdiscstatetypeData%DummyOutput, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'SD_Copypartialoutputpdiscstatetype:DummyOutput')
         IF (ErrStat>=AbortErrLev) RETURN
 END SUBROUTINE SD_Copypartialoutputpdiscstatetype

 SUBROUTINE SD_Destroypartialoutputpdiscstatetype( partialoutputpdiscstatetypeData, ErrStat, ErrMsg )
  TYPE(sd_partialoutputpdiscstatetype), INTENT(INOUT) :: partialoutputpdiscstatetypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  CALL SD_DestroyDiscState( partialoutputpdiscstatetypeData%DummyOutput, ErrStat, ErrMsg )
 END SUBROUTINE SD_Destroypartialoutputpdiscstatetype

 SUBROUTINE SD_Packpartialoutputpdiscstatetype( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(sd_partialoutputpdiscstatetype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_DummyOutput_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_DummyOutput_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_DummyOutput_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  CALL SD_PackDiscState( Re_DummyOutput_Buf, Db_DummyOutput_Buf, Int_DummyOutput_Buf, InData%DummyOutput, ErrStat, ErrMsg, .TRUE. ) ! DummyOutput 
  IF(ALLOCATED(Re_DummyOutput_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_DummyOutput_Buf  ) ! DummyOutput
  IF(ALLOCATED(Db_DummyOutput_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_DummyOutput_Buf  ) ! DummyOutput
  IF(ALLOCATED(Int_DummyOutput_Buf))Int_BufSz = Int_BufSz + SIZE( Int_DummyOutput_Buf ) ! DummyOutput
  IF(ALLOCATED(Re_DummyOutput_Buf))  DEALLOCATE(Re_DummyOutput_Buf)
  IF(ALLOCATED(Db_DummyOutput_Buf))  DEALLOCATE(Db_DummyOutput_Buf)
  IF(ALLOCATED(Int_DummyOutput_Buf)) DEALLOCATE(Int_DummyOutput_Buf)
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  CALL SD_PackDiscState( Re_DummyOutput_Buf, Db_DummyOutput_Buf, Int_DummyOutput_Buf, InData%DummyOutput, ErrStat, ErrMsg, OnlySize ) ! DummyOutput 
  IF(ALLOCATED(Re_DummyOutput_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_DummyOutput_Buf)-1 ) = Re_DummyOutput_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_DummyOutput_Buf)
  ENDIF
  IF(ALLOCATED(Db_DummyOutput_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_DummyOutput_Buf)-1 ) = Db_DummyOutput_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_DummyOutput_Buf)
  ENDIF
  IF(ALLOCATED(Int_DummyOutput_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_DummyOutput_Buf)-1 ) = Int_DummyOutput_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_DummyOutput_Buf)
  ENDIF
  IF( ALLOCATED(Re_DummyOutput_Buf) )  DEALLOCATE(Re_DummyOutput_Buf)
  IF( ALLOCATED(Db_DummyOutput_Buf) )  DEALLOCATE(Db_DummyOutput_Buf)
  IF( ALLOCATED(Int_DummyOutput_Buf) ) DEALLOCATE(Int_DummyOutput_Buf)
 END SUBROUTINE SD_Packpartialoutputpdiscstatetype

 SUBROUTINE SD_UnPackpartialoutputpdiscstatetype( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(sd_partialoutputpdiscstatetype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_DummyOutput_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_DummyOutput_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_DummyOutput_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
 ! first call SD_PackDiscState to get correctly sized buffers for unpacking
  CALL SD_PackDiscState( Re_DummyOutput_Buf, Db_DummyOutput_Buf, Int_DummyOutput_Buf, OutData%DummyOutput, ErrStat, ErrMsg, .TRUE. ) ! DummyOutput 
  IF(ALLOCATED(Re_DummyOutput_Buf)) THEN
    Re_DummyOutput_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_DummyOutput_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_DummyOutput_Buf)
  ENDIF
  IF(ALLOCATED(Db_DummyOutput_Buf)) THEN
    Db_DummyOutput_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_DummyOutput_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_DummyOutput_Buf)
  ENDIF
  IF(ALLOCATED(Int_DummyOutput_Buf)) THEN
    Int_DummyOutput_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_DummyOutput_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_DummyOutput_Buf)
  ENDIF
  CALL SD_UnPackDiscState( Re_DummyOutput_Buf, Db_DummyOutput_Buf, Int_DummyOutput_Buf, OutData%DummyOutput, ErrStat, ErrMsg ) ! DummyOutput 
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE SD_UnPackpartialoutputpdiscstatetype

 SUBROUTINE SD_Copypartialcontstatepdiscstatetype( SrcpartialcontstatepdiscstatetypeData, DstpartialcontstatepdiscstatetypeData, CtrlCode, ErrStat, ErrMsg )
   TYPE(sd_partialcontstatepdiscstatetype), INTENT(INOUT) :: SrcpartialcontstatepdiscstatetypeData
   TYPE(sd_partialcontstatepdiscstatetype), INTENT(INOUT) :: DstpartialcontstatepdiscstatetypeData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
      CALL SD_CopyDiscState( SrcpartialcontstatepdiscstatetypeData%DummyContState, DstpartialcontstatepdiscstatetypeData%DummyContState, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'SD_Copypartialcontstatepdiscstatetype:DummyContState')
         IF (ErrStat>=AbortErrLev) RETURN
 END SUBROUTINE SD_Copypartialcontstatepdiscstatetype

 SUBROUTINE SD_Destroypartialcontstatepdiscstatetype( partialcontstatepdiscstatetypeData, ErrStat, ErrMsg )
  TYPE(sd_partialcontstatepdiscstatetype), INTENT(INOUT) :: partialcontstatepdiscstatetypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  CALL SD_DestroyDiscState( partialcontstatepdiscstatetypeData%DummyContState, ErrStat, ErrMsg )
 END SUBROUTINE SD_Destroypartialcontstatepdiscstatetype

 SUBROUTINE SD_Packpartialcontstatepdiscstatetype( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(sd_partialcontstatepdiscstatetype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_DummyContState_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_DummyContState_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_DummyContState_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  CALL SD_PackDiscState( Re_DummyContState_Buf, Db_DummyContState_Buf, Int_DummyContState_Buf, InData%DummyContState, ErrStat, ErrMsg, .TRUE. ) ! DummyContState 
  IF(ALLOCATED(Re_DummyContState_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_DummyContState_Buf  ) ! DummyContState
  IF(ALLOCATED(Db_DummyContState_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_DummyContState_Buf  ) ! DummyContState
  IF(ALLOCATED(Int_DummyContState_Buf))Int_BufSz = Int_BufSz + SIZE( Int_DummyContState_Buf ) ! DummyContState
  IF(ALLOCATED(Re_DummyContState_Buf))  DEALLOCATE(Re_DummyContState_Buf)
  IF(ALLOCATED(Db_DummyContState_Buf))  DEALLOCATE(Db_DummyContState_Buf)
  IF(ALLOCATED(Int_DummyContState_Buf)) DEALLOCATE(Int_DummyContState_Buf)
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  CALL SD_PackDiscState( Re_DummyContState_Buf, Db_DummyContState_Buf, Int_DummyContState_Buf, InData%DummyContState, ErrStat, ErrMsg, OnlySize ) ! DummyContState 
  IF(ALLOCATED(Re_DummyContState_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_DummyContState_Buf)-1 ) = Re_DummyContState_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_DummyContState_Buf)
  ENDIF
  IF(ALLOCATED(Db_DummyContState_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_DummyContState_Buf)-1 ) = Db_DummyContState_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_DummyContState_Buf)
  ENDIF
  IF(ALLOCATED(Int_DummyContState_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_DummyContState_Buf)-1 ) = Int_DummyContState_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_DummyContState_Buf)
  ENDIF
  IF( ALLOCATED(Re_DummyContState_Buf) )  DEALLOCATE(Re_DummyContState_Buf)
  IF( ALLOCATED(Db_DummyContState_Buf) )  DEALLOCATE(Db_DummyContState_Buf)
  IF( ALLOCATED(Int_DummyContState_Buf) ) DEALLOCATE(Int_DummyContState_Buf)
 END SUBROUTINE SD_Packpartialcontstatepdiscstatetype

 SUBROUTINE SD_UnPackpartialcontstatepdiscstatetype( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(sd_partialcontstatepdiscstatetype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_DummyContState_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_DummyContState_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_DummyContState_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
 ! first call SD_PackDiscState to get correctly sized buffers for unpacking
  CALL SD_PackDiscState( Re_DummyContState_Buf, Db_DummyContState_Buf, Int_DummyContState_Buf, OutData%DummyContState, ErrStat, ErrMsg, .TRUE. ) ! DummyContState 
  IF(ALLOCATED(Re_DummyContState_Buf)) THEN
    Re_DummyContState_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_DummyContState_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_DummyContState_Buf)
  ENDIF
  IF(ALLOCATED(Db_DummyContState_Buf)) THEN
    Db_DummyContState_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_DummyContState_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_DummyContState_Buf)
  ENDIF
  IF(ALLOCATED(Int_DummyContState_Buf)) THEN
    Int_DummyContState_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_DummyContState_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_DummyContState_Buf)
  ENDIF
  CALL SD_UnPackDiscState( Re_DummyContState_Buf, Db_DummyContState_Buf, Int_DummyContState_Buf, OutData%DummyContState, ErrStat, ErrMsg ) ! DummyContState 
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE SD_UnPackpartialcontstatepdiscstatetype

 SUBROUTINE SD_Copypartialdiscstatepdiscstatetype( SrcpartialdiscstatepdiscstatetypeData, DstpartialdiscstatepdiscstatetypeData, CtrlCode, ErrStat, ErrMsg )
   TYPE(sd_partialdiscstatepdiscstatetype), INTENT(INOUT) :: SrcpartialdiscstatepdiscstatetypeData
   TYPE(sd_partialdiscstatepdiscstatetype), INTENT(INOUT) :: DstpartialdiscstatepdiscstatetypeData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
      CALL SD_CopyDiscState( SrcpartialdiscstatepdiscstatetypeData%DummyDiscState, DstpartialdiscstatepdiscstatetypeData%DummyDiscState, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'SD_Copypartialdiscstatepdiscstatetype:DummyDiscState')
         IF (ErrStat>=AbortErrLev) RETURN
 END SUBROUTINE SD_Copypartialdiscstatepdiscstatetype

 SUBROUTINE SD_Destroypartialdiscstatepdiscstatetype( partialdiscstatepdiscstatetypeData, ErrStat, ErrMsg )
  TYPE(sd_partialdiscstatepdiscstatetype), INTENT(INOUT) :: partialdiscstatepdiscstatetypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  CALL SD_DestroyDiscState( partialdiscstatepdiscstatetypeData%DummyDiscState, ErrStat, ErrMsg )
 END SUBROUTINE SD_Destroypartialdiscstatepdiscstatetype

 SUBROUTINE SD_Packpartialdiscstatepdiscstatetype( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(sd_partialdiscstatepdiscstatetype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_DummyDiscState_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_DummyDiscState_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_DummyDiscState_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  CALL SD_PackDiscState( Re_DummyDiscState_Buf, Db_DummyDiscState_Buf, Int_DummyDiscState_Buf, InData%DummyDiscState, ErrStat, ErrMsg, .TRUE. ) ! DummyDiscState 
  IF(ALLOCATED(Re_DummyDiscState_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_DummyDiscState_Buf  ) ! DummyDiscState
  IF(ALLOCATED(Db_DummyDiscState_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_DummyDiscState_Buf  ) ! DummyDiscState
  IF(ALLOCATED(Int_DummyDiscState_Buf))Int_BufSz = Int_BufSz + SIZE( Int_DummyDiscState_Buf ) ! DummyDiscState
  IF(ALLOCATED(Re_DummyDiscState_Buf))  DEALLOCATE(Re_DummyDiscState_Buf)
  IF(ALLOCATED(Db_DummyDiscState_Buf))  DEALLOCATE(Db_DummyDiscState_Buf)
  IF(ALLOCATED(Int_DummyDiscState_Buf)) DEALLOCATE(Int_DummyDiscState_Buf)
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  CALL SD_PackDiscState( Re_DummyDiscState_Buf, Db_DummyDiscState_Buf, Int_DummyDiscState_Buf, InData%DummyDiscState, ErrStat, ErrMsg, OnlySize ) ! DummyDiscState 
  IF(ALLOCATED(Re_DummyDiscState_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_DummyDiscState_Buf)-1 ) = Re_DummyDiscState_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_DummyDiscState_Buf)
  ENDIF
  IF(ALLOCATED(Db_DummyDiscState_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_DummyDiscState_Buf)-1 ) = Db_DummyDiscState_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_DummyDiscState_Buf)
  ENDIF
  IF(ALLOCATED(Int_DummyDiscState_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_DummyDiscState_Buf)-1 ) = Int_DummyDiscState_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_DummyDiscState_Buf)
  ENDIF
  IF( ALLOCATED(Re_DummyDiscState_Buf) )  DEALLOCATE(Re_DummyDiscState_Buf)
  IF( ALLOCATED(Db_DummyDiscState_Buf) )  DEALLOCATE(Db_DummyDiscState_Buf)
  IF( ALLOCATED(Int_DummyDiscState_Buf) ) DEALLOCATE(Int_DummyDiscState_Buf)
 END SUBROUTINE SD_Packpartialdiscstatepdiscstatetype

 SUBROUTINE SD_UnPackpartialdiscstatepdiscstatetype( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(sd_partialdiscstatepdiscstatetype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_DummyDiscState_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_DummyDiscState_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_DummyDiscState_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
 ! first call SD_PackDiscState to get correctly sized buffers for unpacking
  CALL SD_PackDiscState( Re_DummyDiscState_Buf, Db_DummyDiscState_Buf, Int_DummyDiscState_Buf, OutData%DummyDiscState, ErrStat, ErrMsg, .TRUE. ) ! DummyDiscState 
  IF(ALLOCATED(Re_DummyDiscState_Buf)) THEN
    Re_DummyDiscState_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_DummyDiscState_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_DummyDiscState_Buf)
  ENDIF
  IF(ALLOCATED(Db_DummyDiscState_Buf)) THEN
    Db_DummyDiscState_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_DummyDiscState_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_DummyDiscState_Buf)
  ENDIF
  IF(ALLOCATED(Int_DummyDiscState_Buf)) THEN
    Int_DummyDiscState_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_DummyDiscState_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_DummyDiscState_Buf)
  ENDIF
  CALL SD_UnPackDiscState( Re_DummyDiscState_Buf, Db_DummyDiscState_Buf, Int_DummyDiscState_Buf, OutData%DummyDiscState, ErrStat, ErrMsg ) ! DummyDiscState 
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE SD_UnPackpartialdiscstatepdiscstatetype

 SUBROUTINE SD_Copypartialconstrstatepdiscstatetype( SrcpartialconstrstatepdiscstatetypeData, DstpartialconstrstatepdiscstatetypeData, CtrlCode, ErrStat, ErrMsg )
   TYPE(sd_partialconstrstatepdiscstatetype), INTENT(INOUT) :: SrcpartialconstrstatepdiscstatetypeData
   TYPE(sd_partialconstrstatepdiscstatetype), INTENT(INOUT) :: DstpartialconstrstatepdiscstatetypeData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
      CALL SD_CopyDiscState( SrcpartialconstrstatepdiscstatetypeData%DummyConstrState, DstpartialconstrstatepdiscstatetypeData%DummyConstrState, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'SD_Copypartialconstrstatepdiscstatetype:DummyConstrState')
         IF (ErrStat>=AbortErrLev) RETURN
 END SUBROUTINE SD_Copypartialconstrstatepdiscstatetype

 SUBROUTINE SD_Destroypartialconstrstatepdiscstatetype( partialconstrstatepdiscstatetypeData, ErrStat, ErrMsg )
  TYPE(sd_partialconstrstatepdiscstatetype), INTENT(INOUT) :: partialconstrstatepdiscstatetypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  CALL SD_DestroyDiscState( partialconstrstatepdiscstatetypeData%DummyConstrState, ErrStat, ErrMsg )
 END SUBROUTINE SD_Destroypartialconstrstatepdiscstatetype

 SUBROUTINE SD_Packpartialconstrstatepdiscstatetype( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(sd_partialconstrstatepdiscstatetype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_DummyConstrState_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_DummyConstrState_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_DummyConstrState_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  CALL SD_PackDiscState( Re_DummyConstrState_Buf, Db_DummyConstrState_Buf, Int_DummyConstrState_Buf, InData%DummyConstrState, ErrStat, ErrMsg, .TRUE. ) ! DummyConstrState 
  IF(ALLOCATED(Re_DummyConstrState_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_DummyConstrState_Buf  ) ! DummyConstrState
  IF(ALLOCATED(Db_DummyConstrState_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_DummyConstrState_Buf  ) ! DummyConstrState
  IF(ALLOCATED(Int_DummyConstrState_Buf))Int_BufSz = Int_BufSz + SIZE( Int_DummyConstrState_Buf ) ! DummyConstrState
  IF(ALLOCATED(Re_DummyConstrState_Buf))  DEALLOCATE(Re_DummyConstrState_Buf)
  IF(ALLOCATED(Db_DummyConstrState_Buf))  DEALLOCATE(Db_DummyConstrState_Buf)
  IF(ALLOCATED(Int_DummyConstrState_Buf)) DEALLOCATE(Int_DummyConstrState_Buf)
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  CALL SD_PackDiscState( Re_DummyConstrState_Buf, Db_DummyConstrState_Buf, Int_DummyConstrState_Buf, InData%DummyConstrState, ErrStat, ErrMsg, OnlySize ) ! DummyConstrState 
  IF(ALLOCATED(Re_DummyConstrState_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_DummyConstrState_Buf)-1 ) = Re_DummyConstrState_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_DummyConstrState_Buf)
  ENDIF
  IF(ALLOCATED(Db_DummyConstrState_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_DummyConstrState_Buf)-1 ) = Db_DummyConstrState_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_DummyConstrState_Buf)
  ENDIF
  IF(ALLOCATED(Int_DummyConstrState_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_DummyConstrState_Buf)-1 ) = Int_DummyConstrState_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_DummyConstrState_Buf)
  ENDIF
  IF( ALLOCATED(Re_DummyConstrState_Buf) )  DEALLOCATE(Re_DummyConstrState_Buf)
  IF( ALLOCATED(Db_DummyConstrState_Buf) )  DEALLOCATE(Db_DummyConstrState_Buf)
  IF( ALLOCATED(Int_DummyConstrState_Buf) ) DEALLOCATE(Int_DummyConstrState_Buf)
 END SUBROUTINE SD_Packpartialconstrstatepdiscstatetype

 SUBROUTINE SD_UnPackpartialconstrstatepdiscstatetype( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(sd_partialconstrstatepdiscstatetype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_DummyConstrState_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_DummyConstrState_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_DummyConstrState_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
 ! first call SD_PackDiscState to get correctly sized buffers for unpacking
  CALL SD_PackDiscState( Re_DummyConstrState_Buf, Db_DummyConstrState_Buf, Int_DummyConstrState_Buf, OutData%DummyConstrState, ErrStat, ErrMsg, .TRUE. ) ! DummyConstrState 
  IF(ALLOCATED(Re_DummyConstrState_Buf)) THEN
    Re_DummyConstrState_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_DummyConstrState_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_DummyConstrState_Buf)
  ENDIF
  IF(ALLOCATED(Db_DummyConstrState_Buf)) THEN
    Db_DummyConstrState_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_DummyConstrState_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_DummyConstrState_Buf)
  ENDIF
  IF(ALLOCATED(Int_DummyConstrState_Buf)) THEN
    Int_DummyConstrState_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_DummyConstrState_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_DummyConstrState_Buf)
  ENDIF
  CALL SD_UnPackDiscState( Re_DummyConstrState_Buf, Db_DummyConstrState_Buf, Int_DummyConstrState_Buf, OutData%DummyConstrState, ErrStat, ErrMsg ) ! DummyConstrState 
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE SD_UnPackpartialconstrstatepdiscstatetype

 SUBROUTINE SD_Copypartialoutputpconstrstatetype( SrcpartialoutputpconstrstatetypeData, DstpartialoutputpconstrstatetypeData, CtrlCode, ErrStat, ErrMsg )
   TYPE(sd_partialoutputpconstrstatetype), INTENT(INOUT) :: SrcpartialoutputpconstrstatetypeData
   TYPE(sd_partialoutputpconstrstatetype), INTENT(INOUT) :: DstpartialoutputpconstrstatetypeData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
      CALL SD_CopyConstrState( SrcpartialoutputpconstrstatetypeData%DummyOutput, DstpartialoutputpconstrstatetypeData%DummyOutput, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'SD_Copypartialoutputpconstrstatetype:DummyOutput')
         IF (ErrStat>=AbortErrLev) RETURN
 END SUBROUTINE SD_Copypartialoutputpconstrstatetype

 SUBROUTINE SD_Destroypartialoutputpconstrstatetype( partialoutputpconstrstatetypeData, ErrStat, ErrMsg )
  TYPE(sd_partialoutputpconstrstatetype), INTENT(INOUT) :: partialoutputpconstrstatetypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  CALL SD_DestroyConstrState( partialoutputpconstrstatetypeData%DummyOutput, ErrStat, ErrMsg )
 END SUBROUTINE SD_Destroypartialoutputpconstrstatetype

 SUBROUTINE SD_Packpartialoutputpconstrstatetype( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(sd_partialoutputpconstrstatetype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_DummyOutput_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_DummyOutput_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_DummyOutput_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  CALL SD_PackConstrState( Re_DummyOutput_Buf, Db_DummyOutput_Buf, Int_DummyOutput_Buf, InData%DummyOutput, ErrStat, ErrMsg, .TRUE. ) ! DummyOutput 
  IF(ALLOCATED(Re_DummyOutput_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_DummyOutput_Buf  ) ! DummyOutput
  IF(ALLOCATED(Db_DummyOutput_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_DummyOutput_Buf  ) ! DummyOutput
  IF(ALLOCATED(Int_DummyOutput_Buf))Int_BufSz = Int_BufSz + SIZE( Int_DummyOutput_Buf ) ! DummyOutput
  IF(ALLOCATED(Re_DummyOutput_Buf))  DEALLOCATE(Re_DummyOutput_Buf)
  IF(ALLOCATED(Db_DummyOutput_Buf))  DEALLOCATE(Db_DummyOutput_Buf)
  IF(ALLOCATED(Int_DummyOutput_Buf)) DEALLOCATE(Int_DummyOutput_Buf)
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  CALL SD_PackConstrState( Re_DummyOutput_Buf, Db_DummyOutput_Buf, Int_DummyOutput_Buf, InData%DummyOutput, ErrStat, ErrMsg, OnlySize ) ! DummyOutput 
  IF(ALLOCATED(Re_DummyOutput_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_DummyOutput_Buf)-1 ) = Re_DummyOutput_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_DummyOutput_Buf)
  ENDIF
  IF(ALLOCATED(Db_DummyOutput_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_DummyOutput_Buf)-1 ) = Db_DummyOutput_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_DummyOutput_Buf)
  ENDIF
  IF(ALLOCATED(Int_DummyOutput_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_DummyOutput_Buf)-1 ) = Int_DummyOutput_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_DummyOutput_Buf)
  ENDIF
  IF( ALLOCATED(Re_DummyOutput_Buf) )  DEALLOCATE(Re_DummyOutput_Buf)
  IF( ALLOCATED(Db_DummyOutput_Buf) )  DEALLOCATE(Db_DummyOutput_Buf)
  IF( ALLOCATED(Int_DummyOutput_Buf) ) DEALLOCATE(Int_DummyOutput_Buf)
 END SUBROUTINE SD_Packpartialoutputpconstrstatetype

 SUBROUTINE SD_UnPackpartialoutputpconstrstatetype( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(sd_partialoutputpconstrstatetype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_DummyOutput_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_DummyOutput_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_DummyOutput_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
 ! first call SD_PackConstrState to get correctly sized buffers for unpacking
  CALL SD_PackConstrState( Re_DummyOutput_Buf, Db_DummyOutput_Buf, Int_DummyOutput_Buf, OutData%DummyOutput, ErrStat, ErrMsg, .TRUE. ) ! DummyOutput 
  IF(ALLOCATED(Re_DummyOutput_Buf)) THEN
    Re_DummyOutput_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_DummyOutput_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_DummyOutput_Buf)
  ENDIF
  IF(ALLOCATED(Db_DummyOutput_Buf)) THEN
    Db_DummyOutput_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_DummyOutput_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_DummyOutput_Buf)
  ENDIF
  IF(ALLOCATED(Int_DummyOutput_Buf)) THEN
    Int_DummyOutput_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_DummyOutput_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_DummyOutput_Buf)
  ENDIF
  CALL SD_UnPackConstrState( Re_DummyOutput_Buf, Db_DummyOutput_Buf, Int_DummyOutput_Buf, OutData%DummyOutput, ErrStat, ErrMsg ) ! DummyOutput 
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE SD_UnPackpartialoutputpconstrstatetype

 SUBROUTINE SD_Copypartialcontstatepconstrstatetype( SrcpartialcontstatepconstrstatetypeData, DstpartialcontstatepconstrstatetypeData, CtrlCode, ErrStat, ErrMsg )
   TYPE(sd_partialcontstatepconstrstatetype), INTENT(INOUT) :: SrcpartialcontstatepconstrstatetypeData
   TYPE(sd_partialcontstatepconstrstatetype), INTENT(INOUT) :: DstpartialcontstatepconstrstatetypeData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
      CALL SD_CopyConstrState( SrcpartialcontstatepconstrstatetypeData%DummyContState, DstpartialcontstatepconstrstatetypeData%DummyContState, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'SD_Copypartialcontstatepconstrstatetype:DummyContState')
         IF (ErrStat>=AbortErrLev) RETURN
 END SUBROUTINE SD_Copypartialcontstatepconstrstatetype

 SUBROUTINE SD_Destroypartialcontstatepconstrstatetype( partialcontstatepconstrstatetypeData, ErrStat, ErrMsg )
  TYPE(sd_partialcontstatepconstrstatetype), INTENT(INOUT) :: partialcontstatepconstrstatetypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  CALL SD_DestroyConstrState( partialcontstatepconstrstatetypeData%DummyContState, ErrStat, ErrMsg )
 END SUBROUTINE SD_Destroypartialcontstatepconstrstatetype

 SUBROUTINE SD_Packpartialcontstatepconstrstatetype( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(sd_partialcontstatepconstrstatetype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_DummyContState_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_DummyContState_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_DummyContState_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  CALL SD_PackConstrState( Re_DummyContState_Buf, Db_DummyContState_Buf, Int_DummyContState_Buf, InData%DummyContState, ErrStat, ErrMsg, .TRUE. ) ! DummyContState 
  IF(ALLOCATED(Re_DummyContState_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_DummyContState_Buf  ) ! DummyContState
  IF(ALLOCATED(Db_DummyContState_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_DummyContState_Buf  ) ! DummyContState
  IF(ALLOCATED(Int_DummyContState_Buf))Int_BufSz = Int_BufSz + SIZE( Int_DummyContState_Buf ) ! DummyContState
  IF(ALLOCATED(Re_DummyContState_Buf))  DEALLOCATE(Re_DummyContState_Buf)
  IF(ALLOCATED(Db_DummyContState_Buf))  DEALLOCATE(Db_DummyContState_Buf)
  IF(ALLOCATED(Int_DummyContState_Buf)) DEALLOCATE(Int_DummyContState_Buf)
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  CALL SD_PackConstrState( Re_DummyContState_Buf, Db_DummyContState_Buf, Int_DummyContState_Buf, InData%DummyContState, ErrStat, ErrMsg, OnlySize ) ! DummyContState 
  IF(ALLOCATED(Re_DummyContState_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_DummyContState_Buf)-1 ) = Re_DummyContState_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_DummyContState_Buf)
  ENDIF
  IF(ALLOCATED(Db_DummyContState_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_DummyContState_Buf)-1 ) = Db_DummyContState_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_DummyContState_Buf)
  ENDIF
  IF(ALLOCATED(Int_DummyContState_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_DummyContState_Buf)-1 ) = Int_DummyContState_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_DummyContState_Buf)
  ENDIF
  IF( ALLOCATED(Re_DummyContState_Buf) )  DEALLOCATE(Re_DummyContState_Buf)
  IF( ALLOCATED(Db_DummyContState_Buf) )  DEALLOCATE(Db_DummyContState_Buf)
  IF( ALLOCATED(Int_DummyContState_Buf) ) DEALLOCATE(Int_DummyContState_Buf)
 END SUBROUTINE SD_Packpartialcontstatepconstrstatetype

 SUBROUTINE SD_UnPackpartialcontstatepconstrstatetype( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(sd_partialcontstatepconstrstatetype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_DummyContState_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_DummyContState_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_DummyContState_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
 ! first call SD_PackConstrState to get correctly sized buffers for unpacking
  CALL SD_PackConstrState( Re_DummyContState_Buf, Db_DummyContState_Buf, Int_DummyContState_Buf, OutData%DummyContState, ErrStat, ErrMsg, .TRUE. ) ! DummyContState 
  IF(ALLOCATED(Re_DummyContState_Buf)) THEN
    Re_DummyContState_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_DummyContState_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_DummyContState_Buf)
  ENDIF
  IF(ALLOCATED(Db_DummyContState_Buf)) THEN
    Db_DummyContState_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_DummyContState_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_DummyContState_Buf)
  ENDIF
  IF(ALLOCATED(Int_DummyContState_Buf)) THEN
    Int_DummyContState_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_DummyContState_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_DummyContState_Buf)
  ENDIF
  CALL SD_UnPackConstrState( Re_DummyContState_Buf, Db_DummyContState_Buf, Int_DummyContState_Buf, OutData%DummyContState, ErrStat, ErrMsg ) ! DummyContState 
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE SD_UnPackpartialcontstatepconstrstatetype

 SUBROUTINE SD_Copypartialdiscstatepconstrstatetype( SrcpartialdiscstatepconstrstatetypeData, DstpartialdiscstatepconstrstatetypeData, CtrlCode, ErrStat, ErrMsg )
   TYPE(sd_partialdiscstatepconstrstatetype), INTENT(INOUT) :: SrcpartialdiscstatepconstrstatetypeData
   TYPE(sd_partialdiscstatepconstrstatetype), INTENT(INOUT) :: DstpartialdiscstatepconstrstatetypeData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
      CALL SD_CopyConstrState( SrcpartialdiscstatepconstrstatetypeData%DummyDiscState, DstpartialdiscstatepconstrstatetypeData%DummyDiscState, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'SD_Copypartialdiscstatepconstrstatetype:DummyDiscState')
         IF (ErrStat>=AbortErrLev) RETURN
 END SUBROUTINE SD_Copypartialdiscstatepconstrstatetype

 SUBROUTINE SD_Destroypartialdiscstatepconstrstatetype( partialdiscstatepconstrstatetypeData, ErrStat, ErrMsg )
  TYPE(sd_partialdiscstatepconstrstatetype), INTENT(INOUT) :: partialdiscstatepconstrstatetypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  CALL SD_DestroyConstrState( partialdiscstatepconstrstatetypeData%DummyDiscState, ErrStat, ErrMsg )
 END SUBROUTINE SD_Destroypartialdiscstatepconstrstatetype

 SUBROUTINE SD_Packpartialdiscstatepconstrstatetype( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(sd_partialdiscstatepconstrstatetype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_DummyDiscState_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_DummyDiscState_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_DummyDiscState_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  CALL SD_PackConstrState( Re_DummyDiscState_Buf, Db_DummyDiscState_Buf, Int_DummyDiscState_Buf, InData%DummyDiscState, ErrStat, ErrMsg, .TRUE. ) ! DummyDiscState 
  IF(ALLOCATED(Re_DummyDiscState_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_DummyDiscState_Buf  ) ! DummyDiscState
  IF(ALLOCATED(Db_DummyDiscState_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_DummyDiscState_Buf  ) ! DummyDiscState
  IF(ALLOCATED(Int_DummyDiscState_Buf))Int_BufSz = Int_BufSz + SIZE( Int_DummyDiscState_Buf ) ! DummyDiscState
  IF(ALLOCATED(Re_DummyDiscState_Buf))  DEALLOCATE(Re_DummyDiscState_Buf)
  IF(ALLOCATED(Db_DummyDiscState_Buf))  DEALLOCATE(Db_DummyDiscState_Buf)
  IF(ALLOCATED(Int_DummyDiscState_Buf)) DEALLOCATE(Int_DummyDiscState_Buf)
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  CALL SD_PackConstrState( Re_DummyDiscState_Buf, Db_DummyDiscState_Buf, Int_DummyDiscState_Buf, InData%DummyDiscState, ErrStat, ErrMsg, OnlySize ) ! DummyDiscState 
  IF(ALLOCATED(Re_DummyDiscState_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_DummyDiscState_Buf)-1 ) = Re_DummyDiscState_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_DummyDiscState_Buf)
  ENDIF
  IF(ALLOCATED(Db_DummyDiscState_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_DummyDiscState_Buf)-1 ) = Db_DummyDiscState_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_DummyDiscState_Buf)
  ENDIF
  IF(ALLOCATED(Int_DummyDiscState_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_DummyDiscState_Buf)-1 ) = Int_DummyDiscState_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_DummyDiscState_Buf)
  ENDIF
  IF( ALLOCATED(Re_DummyDiscState_Buf) )  DEALLOCATE(Re_DummyDiscState_Buf)
  IF( ALLOCATED(Db_DummyDiscState_Buf) )  DEALLOCATE(Db_DummyDiscState_Buf)
  IF( ALLOCATED(Int_DummyDiscState_Buf) ) DEALLOCATE(Int_DummyDiscState_Buf)
 END SUBROUTINE SD_Packpartialdiscstatepconstrstatetype

 SUBROUTINE SD_UnPackpartialdiscstatepconstrstatetype( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(sd_partialdiscstatepconstrstatetype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_DummyDiscState_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_DummyDiscState_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_DummyDiscState_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
 ! first call SD_PackConstrState to get correctly sized buffers for unpacking
  CALL SD_PackConstrState( Re_DummyDiscState_Buf, Db_DummyDiscState_Buf, Int_DummyDiscState_Buf, OutData%DummyDiscState, ErrStat, ErrMsg, .TRUE. ) ! DummyDiscState 
  IF(ALLOCATED(Re_DummyDiscState_Buf)) THEN
    Re_DummyDiscState_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_DummyDiscState_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_DummyDiscState_Buf)
  ENDIF
  IF(ALLOCATED(Db_DummyDiscState_Buf)) THEN
    Db_DummyDiscState_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_DummyDiscState_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_DummyDiscState_Buf)
  ENDIF
  IF(ALLOCATED(Int_DummyDiscState_Buf)) THEN
    Int_DummyDiscState_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_DummyDiscState_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_DummyDiscState_Buf)
  ENDIF
  CALL SD_UnPackConstrState( Re_DummyDiscState_Buf, Db_DummyDiscState_Buf, Int_DummyDiscState_Buf, OutData%DummyDiscState, ErrStat, ErrMsg ) ! DummyDiscState 
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE SD_UnPackpartialdiscstatepconstrstatetype

 SUBROUTINE SD_Copypartialconstrstatepconstrstatetype( SrcpartialconstrstatepconstrstatetypeData, DstpartialconstrstatepconstrstatetypeData, CtrlCode, ErrStat, ErrMsg )
   TYPE(sd_partialconstrstatepconstrstatetype), INTENT(INOUT) :: SrcpartialconstrstatepconstrstatetypeData
   TYPE(sd_partialconstrstatepconstrstatetype), INTENT(INOUT) :: DstpartialconstrstatepconstrstatetypeData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
      CALL SD_CopyConstrState( SrcpartialconstrstatepconstrstatetypeData%DummyConstrState, DstpartialconstrstatepconstrstatetypeData%DummyConstrState, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'SD_Copypartialconstrstatepconstrstatetype:DummyConstrState')
         IF (ErrStat>=AbortErrLev) RETURN
 END SUBROUTINE SD_Copypartialconstrstatepconstrstatetype

 SUBROUTINE SD_Destroypartialconstrstatepconstrstatetype( partialconstrstatepconstrstatetypeData, ErrStat, ErrMsg )
  TYPE(sd_partialconstrstatepconstrstatetype), INTENT(INOUT) :: partialconstrstatepconstrstatetypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  CALL SD_DestroyConstrState( partialconstrstatepconstrstatetypeData%DummyConstrState, ErrStat, ErrMsg )
 END SUBROUTINE SD_Destroypartialconstrstatepconstrstatetype

 SUBROUTINE SD_Packpartialconstrstatepconstrstatetype( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(sd_partialconstrstatepconstrstatetype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_DummyConstrState_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_DummyConstrState_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_DummyConstrState_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  CALL SD_PackConstrState( Re_DummyConstrState_Buf, Db_DummyConstrState_Buf, Int_DummyConstrState_Buf, InData%DummyConstrState, ErrStat, ErrMsg, .TRUE. ) ! DummyConstrState 
  IF(ALLOCATED(Re_DummyConstrState_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_DummyConstrState_Buf  ) ! DummyConstrState
  IF(ALLOCATED(Db_DummyConstrState_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_DummyConstrState_Buf  ) ! DummyConstrState
  IF(ALLOCATED(Int_DummyConstrState_Buf))Int_BufSz = Int_BufSz + SIZE( Int_DummyConstrState_Buf ) ! DummyConstrState
  IF(ALLOCATED(Re_DummyConstrState_Buf))  DEALLOCATE(Re_DummyConstrState_Buf)
  IF(ALLOCATED(Db_DummyConstrState_Buf))  DEALLOCATE(Db_DummyConstrState_Buf)
  IF(ALLOCATED(Int_DummyConstrState_Buf)) DEALLOCATE(Int_DummyConstrState_Buf)
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  CALL SD_PackConstrState( Re_DummyConstrState_Buf, Db_DummyConstrState_Buf, Int_DummyConstrState_Buf, InData%DummyConstrState, ErrStat, ErrMsg, OnlySize ) ! DummyConstrState 
  IF(ALLOCATED(Re_DummyConstrState_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_DummyConstrState_Buf)-1 ) = Re_DummyConstrState_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_DummyConstrState_Buf)
  ENDIF
  IF(ALLOCATED(Db_DummyConstrState_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_DummyConstrState_Buf)-1 ) = Db_DummyConstrState_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_DummyConstrState_Buf)
  ENDIF
  IF(ALLOCATED(Int_DummyConstrState_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_DummyConstrState_Buf)-1 ) = Int_DummyConstrState_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_DummyConstrState_Buf)
  ENDIF
  IF( ALLOCATED(Re_DummyConstrState_Buf) )  DEALLOCATE(Re_DummyConstrState_Buf)
  IF( ALLOCATED(Db_DummyConstrState_Buf) )  DEALLOCATE(Db_DummyConstrState_Buf)
  IF( ALLOCATED(Int_DummyConstrState_Buf) ) DEALLOCATE(Int_DummyConstrState_Buf)
 END SUBROUTINE SD_Packpartialconstrstatepconstrstatetype

 SUBROUTINE SD_UnPackpartialconstrstatepconstrstatetype( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(sd_partialconstrstatepconstrstatetype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_DummyConstrState_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_DummyConstrState_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_DummyConstrState_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
 ! first call SD_PackConstrState to get correctly sized buffers for unpacking
  CALL SD_PackConstrState( Re_DummyConstrState_Buf, Db_DummyConstrState_Buf, Int_DummyConstrState_Buf, OutData%DummyConstrState, ErrStat, ErrMsg, .TRUE. ) ! DummyConstrState 
  IF(ALLOCATED(Re_DummyConstrState_Buf)) THEN
    Re_DummyConstrState_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_DummyConstrState_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_DummyConstrState_Buf)
  ENDIF
  IF(ALLOCATED(Db_DummyConstrState_Buf)) THEN
    Db_DummyConstrState_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_DummyConstrState_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_DummyConstrState_Buf)
  ENDIF
  IF(ALLOCATED(Int_DummyConstrState_Buf)) THEN
    Int_DummyConstrState_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_DummyConstrState_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_DummyConstrState_Buf)
  ENDIF
  CALL SD_UnPackConstrState( Re_DummyConstrState_Buf, Db_DummyConstrState_Buf, Int_DummyConstrState_Buf, OutData%DummyConstrState, ErrStat, ErrMsg ) ! DummyConstrState 
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE SD_UnPackpartialconstrstatepconstrstatetype


 SUBROUTINE SD_Input_ExtrapInterp(u, tin, u_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) input u_out at time t_out, from previous/future time
! values of u (which has values associated with times in t).  Order of the interpolation is given by the size of u
!
!  expressions below based on either
!
!  f(t) = a
!  f(t) = a + b * t, or
!  f(t) = a + b * t + c * t**2
!
!  where a, b and c are determined as the solution to
!  f(t1) = u1, f(t2) = u2, f(t3) = u3  (as appropriate)
!
!..................................................................................................................................

 TYPE(SD_inputtype), INTENT(INOUT)  :: u(:)      ! Inputs at t1 > t2 > t3
 REAL(DbKi),         INTENT(IN   )  :: tin(:)      ! Times associated with the inputs
 TYPE(SD_inputtype), INTENT(INOUT)  :: u_out     ! Inputs at tin_out
 REAL(DbKi),         INTENT(IN   )  :: tin_out     ! time to be extrap/interp'd to
 INTEGER(IntKi),     INTENT(  OUT)  :: ErrStat   ! Error status of the operation
 CHARACTER(*),       INTENT(  OUT)  :: ErrMsg    ! Error message if ErrStat /= ErrID_None
   ! local variables
 REAL(DbKi) :: t(SIZE(tin))    ! Times associated with the inputs
 REAL(DbKi) :: t_out           ! Time to which to be extrap/interpd
 INTEGER(IntKi)                 :: order    ! order of polynomial fit (max 2)
 REAL(DbKi)                                 :: b0       ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: c0       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:)        :: b1       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:)        :: c1       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:)      :: b2       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:)      :: c2       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:)    :: b3       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:)    :: c3       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:,:)  :: b4       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:,:)  :: c4       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:,:,:):: b5       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:,:,:):: c5       ! temporary for extrapolation/interpolation
 INTEGER(IntKi)                             :: ErrStat2 ! local errors
 CHARACTER(1024)                            :: ErrMsg2  ! local errors
 INTEGER                                    :: i01    ! dim1 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i11    ! dim1 level 1 counter variable for arrays of ddts
 INTEGER                                    :: i21    ! dim1 level 2 counter variable for arrays of ddts
 INTEGER                                    :: i31    ! dim1 level 3 counter variable for arrays of ddts
 INTEGER                                    :: i41    ! dim1 level 4 counter variable for arrays of ddts
 INTEGER                                    :: i51    ! dim1 level 5 counter variable for arrays of ddts
 INTEGER                                    :: i61    ! dim1 level 6 counter variable for arrays of ddts
 INTEGER                                    :: i71    ! dim1 level 7 counter variable for arrays of ddts
 INTEGER                                    :: i81    ! dim1 level 8 counter variable for arrays of ddts
 INTEGER                                    :: i91    ! dim1 level 9 counter variable for arrays of ddts
 INTEGER                                    :: i02    ! dim2 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i12    ! dim2 level 1 counter variable for arrays of ddts
 INTEGER                                    :: i22    ! dim2 level 2 counter variable for arrays of ddts
 INTEGER                                    :: i32    ! dim2 level 3 counter variable for arrays of ddts
 INTEGER                                    :: i42    ! dim2 level 4 counter variable for arrays of ddts
 INTEGER                                    :: i52    ! dim2 level 5 counter variable for arrays of ddts
 INTEGER                                    :: i62    ! dim2 level 6 counter variable for arrays of ddts
 INTEGER                                    :: i72    ! dim2 level 7 counter variable for arrays of ddts
 INTEGER                                    :: i82    ! dim2 level 8 counter variable for arrays of ddts
 INTEGER                                    :: i92    ! dim2 level 9 counter variable for arrays of ddts
 INTEGER                                    :: i03    ! dim3 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i13    ! dim3 level 1 counter variable for arrays of ddts
 INTEGER                                    :: i23    ! dim3 level 2 counter variable for arrays of ddts
 INTEGER                                    :: i33    ! dim3 level 3 counter variable for arrays of ddts
 INTEGER                                    :: i43    ! dim3 level 4 counter variable for arrays of ddts
 INTEGER                                    :: i53    ! dim3 level 5 counter variable for arrays of ddts
 INTEGER                                    :: i63    ! dim3 level 6 counter variable for arrays of ddts
 INTEGER                                    :: i73    ! dim3 level 7 counter variable for arrays of ddts
 INTEGER                                    :: i83    ! dim3 level 8 counter variable for arrays of ddts
 INTEGER                                    :: i93    ! dim3 level 9 counter variable for arrays of ddts
 INTEGER                                    :: i04    ! dim4 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i14    ! dim4 level 1 counter variable for arrays of ddts
 INTEGER                                    :: i24    ! dim4 level 2 counter variable for arrays of ddts
 INTEGER                                    :: i34    ! dim4 level 3 counter variable for arrays of ddts
 INTEGER                                    :: i44    ! dim4 level 4 counter variable for arrays of ddts
 INTEGER                                    :: i54    ! dim4 level 5 counter variable for arrays of ddts
 INTEGER                                    :: i64    ! dim4 level 6 counter variable for arrays of ddts
 INTEGER                                    :: i74    ! dim4 level 7 counter variable for arrays of ddts
 INTEGER                                    :: i84    ! dim4 level 8 counter variable for arrays of ddts
 INTEGER                                    :: i94    ! dim4 level 9 counter variable for arrays of ddts
 INTEGER                                    :: i05    ! dim5 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i15    ! dim5 level 1 counter variable for arrays of ddts
 INTEGER                                    :: i25    ! dim5 level 2 counter variable for arrays of ddts
 INTEGER                                    :: i35    ! dim5 level 3 counter variable for arrays of ddts
 INTEGER                                    :: i45    ! dim5 level 4 counter variable for arrays of ddts
 INTEGER                                    :: i55    ! dim5 level 5 counter variable for arrays of ddts
 INTEGER                                    :: i65    ! dim5 level 6 counter variable for arrays of ddts
 INTEGER                                    :: i75    ! dim5 level 7 counter variable for arrays of ddts
 INTEGER                                    :: i85    ! dim5 level 8 counter variable for arrays of ddts
 INTEGER                                    :: i95    ! dim5 level 9 counter variable for arrays of ddts
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
    ! we'll subtract a constant from the times to resolve some 
    ! numerical issues when t gets large (and to simplify the equations)
 t = tin - tin(1)
 t_out = tin_out - tin(1)

 if ( size(t) .ne. size(u)) then
    ErrStat = ErrID_Fatal
    ErrMsg = ' Error in SD_Input_ExtrapInterp: size(t) must equal size(u) '
    RETURN
 endif
 if (size(u) .gt. 3) then
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in SD_Input_ExtrapInterp: size(u) must be less than 4 '
    RETURN
 endif
 order = SIZE(u) - 1
 IF ( order .eq. 0 ) THEN
  CALL MeshCopy(u(1)%TPMesh, u_out%TPMesh, MESH_UPDATECOPY, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'SD_Input_ExtrapInterp:%TPMesh')
         IF (ErrStat>=AbortErrLev) RETURN
  CALL MeshCopy(u(1)%LMesh, u_out%LMesh, MESH_UPDATECOPY, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'SD_Input_ExtrapInterp:%LMesh')
         IF (ErrStat>=AbortErrLev) RETURN
 ELSE IF ( order .eq. 1 ) THEN
  IF ( EqualRealNos( t(1), t(2) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in SD_Input_ExtrapInterp: t(1) must not equal t(2) to avoid a division-by-zero error.'
    RETURN
  END IF
  CALL MeshExtrapInterp1(u(1)%TPMesh, u(2)%TPMesh, tin, u_out%TPMesh, tin_out, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'SD_Input_ExtrapInterp:%TPMesh')
         IF (ErrStat>=AbortErrLev) RETURN
  CALL MeshExtrapInterp1(u(1)%LMesh, u(2)%LMesh, tin, u_out%LMesh, tin_out, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'SD_Input_ExtrapInterp:%LMesh')
         IF (ErrStat>=AbortErrLev) RETURN
 ELSE IF ( order .eq. 2 ) THEN
  IF ( EqualRealNos( t(1), t(2) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in SD_Input_ExtrapInterp: t(1) must not equal t(2) to avoid a division-by-zero error.'
    RETURN
  END IF
  IF ( EqualRealNos( t(2), t(3) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in SD_Input_ExtrapInterp: t(2) must not equal t(3) to avoid a division-by-zero error.'
    RETURN
  END IF
  IF ( EqualRealNos( t(1), t(3) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in SD_Input_ExtrapInterp: t(1) must not equal t(3) to avoid a division-by-zero error.'
    RETURN
  END IF
  CALL MeshExtrapInterp2(u(1)%TPMesh, u(2)%TPMesh, u(3)%TPMesh, tin, u_out%TPMesh, tin_out, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'SD_Input_ExtrapInterp:%TPMesh')
         IF (ErrStat>=AbortErrLev) RETURN
  CALL MeshExtrapInterp2(u(1)%LMesh, u(2)%LMesh, u(3)%LMesh, tin, u_out%LMesh, tin_out, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'SD_Input_ExtrapInterp:%LMesh')
         IF (ErrStat>=AbortErrLev) RETURN
 ELSE 
   ErrStat = ErrID_Fatal
   ErrMsg = ' order must be less than 3 in SD_Input_ExtrapInterp '
   RETURN
 ENDIF 
 END SUBROUTINE SD_Input_ExtrapInterp


 SUBROUTINE SD_Output_ExtrapInterp(u, tin, u_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) input u_out at time t_out, from previous/future time
! values of u (which has values associated with times in t).  Order of the interpolation is given by the size of u
!
!  expressions below based on either
!
!  f(t) = a
!  f(t) = a + b * t, or
!  f(t) = a + b * t + c * t**2
!
!  where a, b and c are determined as the solution to
!  f(t1) = u1, f(t2) = u2, f(t3) = u3  (as appropriate)
!
!..................................................................................................................................

 TYPE(SD_outputtype), INTENT(INOUT)  :: u(:)      ! Inputs at t1 > t2 > t3
 REAL(DbKi),         INTENT(IN   )  :: tin(:)      ! Times associated with the inputs
 TYPE(SD_outputtype), INTENT(INOUT)  :: u_out     ! Inputs at tin_out
 REAL(DbKi),         INTENT(IN   )  :: tin_out     ! time to be extrap/interp'd to
 INTEGER(IntKi),     INTENT(  OUT)  :: ErrStat   ! Error status of the operation
 CHARACTER(*),       INTENT(  OUT)  :: ErrMsg    ! Error message if ErrStat /= ErrID_None
   ! local variables
 REAL(DbKi) :: t(SIZE(tin))    ! Times associated with the inputs
 REAL(DbKi) :: t_out           ! Time to which to be extrap/interpd
 INTEGER(IntKi)                 :: order    ! order of polynomial fit (max 2)
 REAL(DbKi)                                 :: b0       ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: c0       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:)        :: b1       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:)        :: c1       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:)      :: b2       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:)      :: c2       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:)    :: b3       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:)    :: c3       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:,:)  :: b4       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:,:)  :: c4       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:,:,:):: b5       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:,:,:):: c5       ! temporary for extrapolation/interpolation
 INTEGER(IntKi)                             :: ErrStat2 ! local errors
 CHARACTER(1024)                            :: ErrMsg2  ! local errors
 INTEGER                                    :: i01    ! dim1 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i11    ! dim1 level 1 counter variable for arrays of ddts
 INTEGER                                    :: i21    ! dim1 level 2 counter variable for arrays of ddts
 INTEGER                                    :: i31    ! dim1 level 3 counter variable for arrays of ddts
 INTEGER                                    :: i41    ! dim1 level 4 counter variable for arrays of ddts
 INTEGER                                    :: i51    ! dim1 level 5 counter variable for arrays of ddts
 INTEGER                                    :: i61    ! dim1 level 6 counter variable for arrays of ddts
 INTEGER                                    :: i71    ! dim1 level 7 counter variable for arrays of ddts
 INTEGER                                    :: i81    ! dim1 level 8 counter variable for arrays of ddts
 INTEGER                                    :: i91    ! dim1 level 9 counter variable for arrays of ddts
 INTEGER                                    :: i02    ! dim2 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i12    ! dim2 level 1 counter variable for arrays of ddts
 INTEGER                                    :: i22    ! dim2 level 2 counter variable for arrays of ddts
 INTEGER                                    :: i32    ! dim2 level 3 counter variable for arrays of ddts
 INTEGER                                    :: i42    ! dim2 level 4 counter variable for arrays of ddts
 INTEGER                                    :: i52    ! dim2 level 5 counter variable for arrays of ddts
 INTEGER                                    :: i62    ! dim2 level 6 counter variable for arrays of ddts
 INTEGER                                    :: i72    ! dim2 level 7 counter variable for arrays of ddts
 INTEGER                                    :: i82    ! dim2 level 8 counter variable for arrays of ddts
 INTEGER                                    :: i92    ! dim2 level 9 counter variable for arrays of ddts
 INTEGER                                    :: i03    ! dim3 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i13    ! dim3 level 1 counter variable for arrays of ddts
 INTEGER                                    :: i23    ! dim3 level 2 counter variable for arrays of ddts
 INTEGER                                    :: i33    ! dim3 level 3 counter variable for arrays of ddts
 INTEGER                                    :: i43    ! dim3 level 4 counter variable for arrays of ddts
 INTEGER                                    :: i53    ! dim3 level 5 counter variable for arrays of ddts
 INTEGER                                    :: i63    ! dim3 level 6 counter variable for arrays of ddts
 INTEGER                                    :: i73    ! dim3 level 7 counter variable for arrays of ddts
 INTEGER                                    :: i83    ! dim3 level 8 counter variable for arrays of ddts
 INTEGER                                    :: i93    ! dim3 level 9 counter variable for arrays of ddts
 INTEGER                                    :: i04    ! dim4 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i14    ! dim4 level 1 counter variable for arrays of ddts
 INTEGER                                    :: i24    ! dim4 level 2 counter variable for arrays of ddts
 INTEGER                                    :: i34    ! dim4 level 3 counter variable for arrays of ddts
 INTEGER                                    :: i44    ! dim4 level 4 counter variable for arrays of ddts
 INTEGER                                    :: i54    ! dim4 level 5 counter variable for arrays of ddts
 INTEGER                                    :: i64    ! dim4 level 6 counter variable for arrays of ddts
 INTEGER                                    :: i74    ! dim4 level 7 counter variable for arrays of ddts
 INTEGER                                    :: i84    ! dim4 level 8 counter variable for arrays of ddts
 INTEGER                                    :: i94    ! dim4 level 9 counter variable for arrays of ddts
 INTEGER                                    :: i05    ! dim5 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i15    ! dim5 level 1 counter variable for arrays of ddts
 INTEGER                                    :: i25    ! dim5 level 2 counter variable for arrays of ddts
 INTEGER                                    :: i35    ! dim5 level 3 counter variable for arrays of ddts
 INTEGER                                    :: i45    ! dim5 level 4 counter variable for arrays of ddts
 INTEGER                                    :: i55    ! dim5 level 5 counter variable for arrays of ddts
 INTEGER                                    :: i65    ! dim5 level 6 counter variable for arrays of ddts
 INTEGER                                    :: i75    ! dim5 level 7 counter variable for arrays of ddts
 INTEGER                                    :: i85    ! dim5 level 8 counter variable for arrays of ddts
 INTEGER                                    :: i95    ! dim5 level 9 counter variable for arrays of ddts
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
    ! we'll subtract a constant from the times to resolve some 
    ! numerical issues when t gets large (and to simplify the equations)
 t = tin - tin(1)
 t_out = tin_out - tin(1)

 if ( size(t) .ne. size(u)) then
    ErrStat = ErrID_Fatal
    ErrMsg = ' Error in SD_Output_ExtrapInterp: size(t) must equal size(u) '
    RETURN
 endif
 if (size(u) .gt. 3) then
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in SD_Output_ExtrapInterp: size(u) must be less than 4 '
    RETURN
 endif
 order = SIZE(u) - 1
 IF ( order .eq. 0 ) THEN
  CALL MeshCopy(u(1)%Y1Mesh, u_out%Y1Mesh, MESH_UPDATECOPY, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'SD_Output_ExtrapInterp:%Y1Mesh')
         IF (ErrStat>=AbortErrLev) RETURN
  CALL MeshCopy(u(1)%Y2Mesh, u_out%Y2Mesh, MESH_UPDATECOPY, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'SD_Output_ExtrapInterp:%Y2Mesh')
         IF (ErrStat>=AbortErrLev) RETURN
IF (ALLOCATED(u_out%WriteOutput) .AND. ALLOCATED(u(1)%WriteOutput)) THEN
  u_out%WriteOutput = u(1)%WriteOutput
END IF ! check if allocated
 ELSE IF ( order .eq. 1 ) THEN
  IF ( EqualRealNos( t(1), t(2) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in SD_Output_ExtrapInterp: t(1) must not equal t(2) to avoid a division-by-zero error.'
    RETURN
  END IF
  CALL MeshExtrapInterp1(u(1)%Y1Mesh, u(2)%Y1Mesh, tin, u_out%Y1Mesh, tin_out, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'SD_Output_ExtrapInterp:%Y1Mesh')
         IF (ErrStat>=AbortErrLev) RETURN
  CALL MeshExtrapInterp1(u(1)%Y2Mesh, u(2)%Y2Mesh, tin, u_out%Y2Mesh, tin_out, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'SD_Output_ExtrapInterp:%Y2Mesh')
         IF (ErrStat>=AbortErrLev) RETURN
IF (ALLOCATED(u_out%WriteOutput) .AND. ALLOCATED(u(1)%WriteOutput)) THEN
  ALLOCATE(b1(SIZE(u_out%WriteOutput,1)))
  ALLOCATE(c1(SIZE(u_out%WriteOutput,1)))
  b1 = -(u(1)%WriteOutput - u(2)%WriteOutput)/t(2)
  u_out%WriteOutput = u(1)%WriteOutput + b1 * t_out
  DEALLOCATE(b1)
  DEALLOCATE(c1)
END IF ! check if allocated
 ELSE IF ( order .eq. 2 ) THEN
  IF ( EqualRealNos( t(1), t(2) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in SD_Output_ExtrapInterp: t(1) must not equal t(2) to avoid a division-by-zero error.'
    RETURN
  END IF
  IF ( EqualRealNos( t(2), t(3) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in SD_Output_ExtrapInterp: t(2) must not equal t(3) to avoid a division-by-zero error.'
    RETURN
  END IF
  IF ( EqualRealNos( t(1), t(3) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in SD_Output_ExtrapInterp: t(1) must not equal t(3) to avoid a division-by-zero error.'
    RETURN
  END IF
  CALL MeshExtrapInterp2(u(1)%Y1Mesh, u(2)%Y1Mesh, u(3)%Y1Mesh, tin, u_out%Y1Mesh, tin_out, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'SD_Output_ExtrapInterp:%Y1Mesh')
         IF (ErrStat>=AbortErrLev) RETURN
  CALL MeshExtrapInterp2(u(1)%Y2Mesh, u(2)%Y2Mesh, u(3)%Y2Mesh, tin, u_out%Y2Mesh, tin_out, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'SD_Output_ExtrapInterp:%Y2Mesh')
         IF (ErrStat>=AbortErrLev) RETURN
IF (ALLOCATED(u_out%WriteOutput) .AND. ALLOCATED(u(1)%WriteOutput)) THEN
  ALLOCATE(b1(SIZE(u_out%WriteOutput,1)))
  ALLOCATE(c1(SIZE(u_out%WriteOutput,1)))
  b1 = (t(3)**2*(u(1)%WriteOutput - u(2)%WriteOutput) + t(2)**2*(-u(1)%WriteOutput + u(3)%WriteOutput))/(t(2)*t(3)*(t(2) - t(3)))
  c1 = ( (t(2)-t(3))*u(1)%WriteOutput + t(3)*u(2)%WriteOutput - t(2)*u(3)%WriteOutput ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%WriteOutput = u(1)%WriteOutput + b1 * t_out + c1 * t_out**2
  DEALLOCATE(b1)
  DEALLOCATE(c1)
END IF ! check if allocated
 ELSE 
   ErrStat = ErrID_Fatal
   ErrMsg = ' order must be less than 3 in SD_Output_ExtrapInterp '
   RETURN
 ENDIF 
 END SUBROUTINE SD_Output_ExtrapInterp

END MODULE SubDyn_Types
!ENDOFREGISTRYGENERATEDFILE
