!**********************************************************************************************************************************
! LICENSING
! Copyright (C) 2013-2014  National Renewable Energy Laboratory
!
!    This file is part of FAST's Controls and Electrical Drive Module, "ServoDyn".
!
! Licensed under the Apache License, Version 2.0 (the "License");
! you may not use this file except in compliance with the License.
! You may obtain a copy of the License at
!
!     http://www.apache.org/licenses/LICENSE-2.0
!
! Unless required by applicable law or agreed to in writing, software
! distributed under the License is distributed on an "AS IS" BASIS,
! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
! See the License for the specific language governing permissions and
! limitations under the License.
!
!**********************************************************************************************************************************
! File last committed: $Date: 2014-12-23 14:05:54 -0700 (Tue, 23 Dec 2014) $
! (File) Revision #: $Rev: 838 $
! URL: $HeadURL: https://windsvn.nrel.gov/FAST/branches/BJonkman/Source/ServoDyn.f90 $
!**********************************************************************************************************************************
MODULE ServoDyn

   USE ServoDyn_Types
   USE NWTC_Library
   USE BladedInterface

   IMPLICIT NONE

   PRIVATE

   TYPE(ProgDesc), PARAMETER            :: SrvD_Ver = ProgDesc( 'ServoDyn', 'v1.01.02a-bjj', '30-June-2014' )
   CHARACTER(*),   PARAMETER            :: SrvD_Nickname = 'SrvD'
   LOGICAL, PARAMETER, PUBLIC           :: Cmpl4SFun  = .FALSE.                            ! Is the module being compiled as an S-Function for Simulink?
   LOGICAL, PARAMETER, PUBLIC           :: Cmpl4LV    = .FALSE.                            ! Is the module being compiled for Labview?
   
   
! ==================================================================================================="
! NOTE: The following lines of code were generated by a Matlab script called "Write_ChckOutLst.m"
!      using the parameters listed in the "OutListParameters.xlsx" Excel file. Any changes to these 
!      lines should be modified in the Matlab script and/or Excel worksheet as necessary. 
! ==================================================================================================="
! This code was generated by Write_ChckOutLst.m at 23-Mar-2013 20:41:03.


     ! Parameters related to output length (number of characters allowed in the output data headers):

   INTEGER(IntKi), PARAMETER      :: OutStrLenM1 = ChanLen - 1


     ! Indices for computing output channels:
     ! NOTES: 
     !    (1) These parameters are in the order stored in "OutListParameters.xlsx"
     !    (2) Array AllOuts() must be dimensioned to the value of the largest output parameter

     !  Time: 

   INTEGER(IntKi), PARAMETER      :: Time      =  0


     ! Pitch Control:

   INTEGER(IntKi), PARAMETER      :: BlPitchC1 =  1
   INTEGER(IntKi), PARAMETER      :: BlPitchC2 =  2
   INTEGER(IntKi), PARAMETER      :: BlPitchC3 =  3


     ! Generator and Torque Control:

   INTEGER(IntKi), PARAMETER      :: GenTq     =  4
   INTEGER(IntKi), PARAMETER      :: GenPwr    =  5


     ! High Speed Shaft Brake:

   INTEGER(IntKi), PARAMETER      :: HSSBrTq   =  6


     ! Nacelle Yaw Control:

   INTEGER(IntKi), PARAMETER      :: YawMomCom =  7


     ! The maximum number of output channels which can be output by the code.
   INTEGER(IntKi), PARAMETER      :: MaxOutPts =  7

!End of code generated by Matlab script
! ==================================================================================================="

   INTEGER(IntKi), PARAMETER      :: BlPitchC (3) = (/ BlPitchC1, BlPitchC2, BlPitchC3 /) 
   
!bjj: added parameters here (after the "(/ /)" above) so VS2010 doesn't get so confused with the previous statement.

      ! Parameters for type of control
      
   INTEGER(IntKi), PARAMETER :: ControlMode_None   = 0          ! The (ServoDyn-universal) control code for not using a particular type of control
   INTEGER(IntKi), PARAMETER :: ControlMode_DLL    = 5          ! The (ServoDyn-universal) control code for obtaining the control values from a Bladed-Style dynamic-link library
   
   
      ! ..... Public Subroutines ...................................................................................................

   PUBLIC :: SrvD_Init                           ! Initialization routine
   PUBLIC :: SrvD_End                            ! Ending routine (includes clean up)

   PUBLIC :: SrvD_UpdateStates                   ! Loose coupling routine for solving for constraint states, integrating
                                                 !   continuous states, and updating discrete states
   PUBLIC :: SrvD_CalcOutput                     ! Routine for computing outputs

   PUBLIC :: SrvD_CalcConstrStateResidual        ! Tight coupling routine for returning the constraint state residual
   PUBLIC :: SrvD_CalcContStateDeriv             ! Tight coupling routine for computing derivatives of continuous states
   PUBLIC :: SrvD_UpdateDiscState                ! Tight coupling routine for updating discrete states

   !PUBLIC :: SrvD_JacobianPInput                 ! Routine to compute the Jacobians of the output (Y), continuous- (X), discrete-
   !                                              !   (Xd), and constraint-state (Z) equations all with respect to the inputs (u)
   !PUBLIC :: SrvD_JacobianPContState             ! Routine to compute the Jacobians of the output (Y), continuous- (X), discrete-
   !                                              !   (Xd), and constraint-state (Z) equations all with respect to the continuous
   !                                              !   states (x)
   !PUBLIC :: SrvD_JacobianPDiscState             ! Routine to compute the Jacobians of the output (Y), continuous- (X), discrete-
   !                                              !   (Xd), and constraint-state (Z) equations all with respect to the discrete
   !                                              !   states (xd)
   !PUBLIC :: SrvD_JacobianPConstrState           ! Routine to compute the Jacobians of the output (Y), continuous- (X), discrete-
   !                                              !   (Xd), and constraint-state (Z) equations all with respect to the constraint
   !                                              !   states (z)
   
   
CONTAINS
!----------------------------------------------------------------------------------------------------------------------------------
SUBROUTINE SrvD_Init( InitInp, u, p, x, xd, z, OtherState, y, Interval, InitOut, ErrStat, ErrMsg )
! This routine is called at the start of the simulation to perform initialization steps.
! The parameters are set here and not changed during the simulation.
! The initial states and initial guess for the input are defined.
!..................................................................................................................................

   TYPE(SrvD_InitInputType),       INTENT(IN   )  :: InitInp     ! Input data for initialization routine
   TYPE(SrvD_InputType),           INTENT(  OUT)  :: u           ! An initial guess for the input; input mesh must be defined
   TYPE(SrvD_ParameterType),       INTENT(  OUT)  :: p           ! Parameters
   TYPE(SrvD_ContinuousStateType), INTENT(  OUT)  :: x           ! Initial continuous states
   TYPE(SrvD_DiscreteStateType),   INTENT(  OUT)  :: xd          ! Initial discrete states
   TYPE(SrvD_ConstraintStateType), INTENT(  OUT)  :: z           ! Initial guess of the constraint states
   TYPE(SrvD_OtherStateType),      INTENT(  OUT)  :: OtherState  ! Initial other/optimization states
   TYPE(SrvD_OutputType),          INTENT(  OUT)  :: y           ! Initial system outputs (outputs are not calculated;
                                                                 !   only the output mesh is initialized)
   REAL(DbKi),                     INTENT(INOUT)  :: Interval    ! Coupling interval in seconds: the rate that
                                                                 !   (1) SrvD_UpdateStates() is called in loose coupling &
                                                                 !   (2) SrvD_UpdateDiscState() is called in tight coupling.
                                                                 !   Input is the suggested time from the glue code;
                                                                 !   Output is the actual coupling interval that will be used
                                                                 !   by the glue code.
   TYPE(SrvD_InitOutputType),      INTENT(  OUT)  :: InitOut     ! Output for initialization routine
   INTEGER(IntKi),                 INTENT(  OUT)  :: ErrStat     ! Error status of the operation
   CHARACTER(*),                   INTENT(  OUT)  :: ErrMsg      ! Error message if ErrStat /= ErrID_None

      ! local variables

   TYPE(SrvD_InputFile)                           :: InputFileData  ! Data stored in the module's input file
   INTEGER(IntKi)                                 :: ErrStat2       ! temporary Error status of the operation
   CHARACTER(LEN(ErrMsg))                         :: ErrMsg2        ! temporary Error message if ErrStat /= ErrID_None


      ! Initialize variables

   ErrStat = ErrID_None
   ErrMsg  = ""

      
      ! Initialize the NWTC Subroutine Library

   CALL NWTC_Init( EchoLibVer=.FALSE. )

      ! Display the module information

   CALL DispNVD( SrvD_Ver )

      !............................................................................................      
      ! Read the input file and validate the data
      ! (note p%NumBl and p%RootName must be set first!) 
      !............................................................................................      
   p%RootName = TRIM(InitInp%RootName)//'.'//SrvD_Nickname ! all of the output file names from this module will end with '_ModuleName'
   p%NumBl    = InitInp%NumBl         
      
   CALL SrvD_ReadInput( InitInp%InputFile, InputFileData, Interval, p%RootName, ErrStat2, ErrMsg2 )
      CALL CheckError( ErrStat2, ErrMsg2 )
      IF (ErrStat >= AbortErrLev) RETURN

   CALL ValidatePrimaryData( InputFileData, InitInp%NumBl, ErrStat2, ErrMsg2 )
      CALL CheckError( ErrStat2, ErrMsg2 )
      IF (ErrStat >= AbortErrLev) RETURN
      
      !............................................................................................
      ! Define parameters here:
      !............................................................................................
   CALL SrvD_SetParameters( InputFileData, p, ErrStat2, ErrMsg2 )   
      CALL CheckError( ErrStat2, ErrMsg2 )
      IF (ErrStat >= AbortErrLev) RETURN      
   !p%DT  = Interval
   

      ! Set and verify BlPitchInit, which comes from InitInputData (not the inputfiledata)
   CALL AllocAry( p%BlPitchInit, p%NumBl, 'BlPitchInit', ErrStat2, ErrMsg2 )
      CALL CheckError( ErrStat2, ErrMsg2 )
      IF (ErrStat >= AbortErrLev) RETURN
   p%BlPitchInit = InitInp%BlPitchInit

   IF ( ANY( p%BlPitchInit <= -pi ) .OR. ANY( p%BlPitchInit > pi ) )  THEN
      CALL CheckError( ErrID_Fatal, 'BlPitchInit must be in the range (-pi,pi] radians (i.e., (-180,180] degrees).' )
      IF (ErrStat >= AbortErrLev) RETURN
   END IF     
   
      !............................................................................................
      ! Define initial system states here:
      !............................................................................................

   x%DummyContState           = 0
   xd%DummyDiscState          = 0
   z%DummyConstrState         = 0
   
      ! Initialize other states here:
   CALL AllocAry( OtherState%BlPitchI,  p%NumBl, 'BlPitchI',  ErrStat2, ErrMsg2 )
      CALL CheckError( ErrStat2, ErrMsg2 )
      IF (ErrStat >= AbortErrLev) RETURN
   CALL AllocAry( OtherState%BegPitMan, p%NumBl, 'BegPitMan', ErrStat2, ErrMsg2 )
      CALL CheckError( ErrStat2, ErrMsg2 )
      IF (ErrStat >= AbortErrLev) RETURN
   CALL AllocAry( OtherState%PitManRat, p%NumBl, 'PitManRat', ErrStat2, ErrMsg2 )
      CALL CheckError( ErrStat2, ErrMsg2 )
      IF (ErrStat >= AbortErrLev) RETURN
   CALL AllocAry( OtherState%TPitManE,  p%NumBl, 'TPitManE',  ErrStat2, ErrMsg2 )
      CALL CheckError( ErrStat2, ErrMsg2 )
      IF (ErrStat >= AbortErrLev) RETURN

   OtherState%BegPitMan  = HUGE(OtherState%BegPitMan)          ! Pitch maneuvers didn't actually start, yet (pick a number larger than TPitManS)
   OtherState%PitManRat = InputFileData%PitManRat(1:p%NumBl)   ! we change the sign of this variable later, so we'll store it as an other state instead of a parameter
   
   OtherState%BegYawMan  = HUGE(OtherState%BegYawMan)          ! Yaw maneuver didn't actually start, yet (pick a number larger than TYawManS)   
   OtherState%YawManRat = InputFileData%YawManRat              ! we change the sign of this variable later, so we'll store it as an other state instead of a parameter
   
   
   OtherState%TOff4Good = HUGE(OtherState%TOff4Good)  ! time the generator went off for good
   OtherState%TGenOnLine= HUGE(OtherState%TGenOnLine) ! time the generator was first online
   
   

      !............................................................................................
      ! Define initial guess for the system inputs here:
      !............................................................................................

   CALL AllocAry( u%BlPitch, p%NumBl, 'BlPitch', ErrStat2, ErrMsg2 )
      CALL CheckError( ErrStat2, ErrMsg2 )
      IF (ErrStat >= AbortErrLev) RETURN

   CALL AllocAry( u%ExternalBlPitchCom, p%NumBl, 'ExternalBlPitchCom', ErrStat2, ErrMsg2 )
      CALL CheckError( ErrStat2, ErrMsg2 )
      IF (ErrStat >= AbortErrLev) RETURN
      
   u%BlPitch = p%BlPitchInit
   
   u%Yaw = p%YawNeut
   u%YawRate   = 0.
   
   u%LSS_Spd   = 0.0
   u%HSS_Spd   = 0.0
   u%RotSpeed  = 0.0
   
   u%ExternalYawPosCom = p%YawNeut
   u%ExternalYawRateCom = 0.
   u%ExternalBlPitchCom = p%BlPitchInit
   u%ExternalGenTrq = 0.
   u%ExternalElecPwr = 0.
   u%ExternalHSSBrFrac = 0.
   
   u%TwrAccel  = 0.
   u%YawErr    = 0.   
   u%WindDir   = 0.
   
      !Inputs for the Bladed Interface:
   u%RootMyc   = 0.
   u%YawBrTAxp = 0.
   u%YawBrTAyp = 0.
   u%LSSTipPxa = 0.
   u%RootMxc   = 0.
   u%LSSTipMya = 0.
   u%LSSTipMza = 0.
   u%LSSTipMys = 0.
   u%LSSTipMzs = 0.
   u%YawBrMyn  = 0.
   u%YawBrMzn  = 0.   
   u%NcIMURAxs = 0.
   u%NcIMURAys = 0.
   u%NcIMURAzs = 0.
   u%RotPwr = 0.
   u%HorWindV = 0.
   u%YawAngle = 0.
   u%ElecPwr_prev = 0.
   u%GenTrq_prev = 0.   

   ! These are values from previous step. I'll initialize them here, though the glue code may not use it. 
   ! TODO: these need to be removed because they break the framework (though they're only for the Bladed-style 
   !       DLL which also breaks the frameowrk)
   y%ElecPwr = u%ElecPwr_prev
   y%GenTrq  = u%GenTrq_prev      
   
   
      !............................................................................................
      ! Define system output initializations (set up mesh) here:
      !............................................................................................
   CALL AllocAry( y%WriteOutput, p%NumOuts, 'WriteOutput', ErrStat2, ErrMsg2 )
      CALL CheckError( ErrStat2, ErrMsg2 )
      IF (ErrStat >= AbortErrLev) RETURN
   y%WriteOutput = 0
   
   
      
   CALL AllocAry( y%BlPitchCom, p%NumBl, 'BlPitchCom', ErrStat2, ErrMsg2 )
      CALL CheckError( ErrStat2, ErrMsg2 )
      IF (ErrStat >= AbortErrLev) RETURN

      ! tip brakes - this may be added back, later, so we'll keep these here for now
   CALL AllocAry( y%TBDrCon, p%NumBl, 'TBDrCon', ErrStat2, ErrMsg2 )
      CALL CheckError( ErrStat2, ErrMsg2 )
      IF (ErrStat >= AbortErrLev) RETURN

      
      !............................................................................................
      ! Define initialization-routine output here:
      !............................................................................................
   CALL AllocAry( InitOut%WriteOutputHdr, p%NumOuts, 'WriteOutputHdr', ErrStat2, ErrMsg2 )
      CALL CheckError( ErrStat2, ErrMsg2 )
      IF (ErrStat >= AbortErrLev) RETURN
   CALL AllocAry( InitOut%WriteOutputUnt, p%NumOuts, 'WriteOutputUnt', ErrStat2, ErrMsg2 )
      CALL CheckError( ErrStat2, ErrMsg2 )
      IF (ErrStat >= AbortErrLev) RETURN
   
   InitOut%WriteOutputHdr = p%OutParam(1:p%NumOuts)%Name
   InitOut%WriteOutputUnt = p%OutParam(1:p%NumOuts)%Units     
   InitOut%Ver = SrvD_Ver
               
   IF ( p%UseBladedInterface ) THEN
      InitOut%CouplingScheme = ExplicitLoose
   !   CALL CheckError( ErrID_Info, 'The external dynamic-link library option being used in ServoDyn '&
   !                    //'requires an explicit-loose coupling scheme.' )
   END IF
   
      !............................................................................................
      ! tip brakes - this may be added back, later, so we'll keep these here for now
      !............................................................................................
   p%TpBrDT = HUGE(p%TpBrDT)

   CALL AllocAry( OtherState%TTpBrDp,  p%NumBl, 'TTpBrDp', ErrStat2, ErrMsg2 )
      CALL CheckError( ErrStat2, ErrMsg2 )
      IF (ErrStat >= AbortErrLev) RETURN
   OtherState%TTpBrDp = HUGE(OtherState%TTpBrDp) !basically never deploy them. Eventually this will be added back?

   CALL AllocAry( OtherState%TTpBrFl,  p%NumBl, 'TTpBrFl', ErrStat2, ErrMsg2 )
      CALL CheckError( ErrStat2, ErrMsg2 )
      IF (ErrStat >= AbortErrLev) RETURN
   OtherState%TTpBrFl = HUGE(OtherState%TTpBrFl) !basically never deploy them. Eventually this will be added back?
   !OtherState%TTpBrFl = InputFileData%TTpBrFl + p%TpBrDT

   CALL AllocAry( p%TBDepISp, p%NumBl, 'TBDepISp', ErrStat2, ErrMsg2 )
      CALL CheckError( ErrStat2, ErrMsg2 )
      IF (ErrStat >= AbortErrLev) RETURN
   p%TBDepISp = HUGE(p%TBDepISp) !basically never deploy them. Eventually this will be added back?
   !p%TBDepISp  = InputFileData%TBDepISp*RPM2RPS
   
   
      !............................................................................................
      ! If you want to choose your own rate instead of using what the glue code suggests, tell the glue code the rate at which
      !   this module must be called here:
      !............................................................................................

   Interval = p%DT      
      
      !............................................................................................
      ! After we've set up all the data for everything else, we'll call the routines to initialize the Bladed Interface
      ! (it requires initial guesses for input/output)
      !............................................................................................
      
   IF ( p%UseBladedInterface ) THEN

      CALL BladedInterface_Init(u, p, OtherState, y, InputFileData, ErrStat2, ErrMsg2 )
         CALL CheckError( ErrStat2, ErrMsg2 )
         IF (ErrStat >= AbortErrLev) RETURN
         
      OtherState%LastTimeCalled = - p%DT  ! we'll initialize the last time the DLL was called as -1 DT.
      OtherState%FirstWarn      = .TRUE.
   
   ELSE

      p%DLL_Trgt%FileName = ""
      p%DLL_Trgt%ProcName = ""
      
   END IF
      
   OtherState%FirstWarn_THSSBrDp = .TRUE.
   
      ! Clean up the local variable:
   CALL SrvD_DestroyInputFile( InputFileData, ErrStat2, ErrMsg2 )
      
   RETURN
   
CONTAINS
   !...............................................................................................................................
   SUBROUTINE CheckError(ErrID,Msg)
   ! This subroutine sets the error message and level and cleans up if the error is >= AbortErrLev
   !...............................................................................................................................

         ! Passed arguments
      INTEGER(IntKi), INTENT(IN) :: ErrID       ! The error identifier (ErrStat)
      CHARACTER(*),   INTENT(IN) :: Msg         ! The error message (ErrMsg)

      INTEGER(IntKi)             :: ErrStat3    ! The error identifier (ErrStat)
      CHARACTER(1024)            :: ErrMsg3     ! The error message (ErrMsg)

      !............................................................................................................................
      ! Set error status/message;
      !............................................................................................................................

      IF ( ErrID /= ErrID_None ) THEN
          
         IF (ErrStat /= ErrID_None) ErrMsg = TRIM(ErrMsg)//NewLine
         ErrMsg = TRIM(ErrMsg)//' SrvD_Init:'//TRIM(Msg)
         ErrStat = MAX(ErrStat, ErrID)

         !.........................................................................................................................
         ! Clean up if we're going to return on error: close files, deallocate local arrays
         !.........................................................................................................................
         IF ( ErrStat >= AbortErrLev ) THEN
            CALL SrvD_DestroyInputFile(InputFileData, ErrStat3, ErrMsg3 )
         END IF

      END IF

   END SUBROUTINE CheckError 
!----------------------------------------------------------------------------------------------------------------------------------
END SUBROUTINE SrvD_Init
!----------------------------------------------------------------------------------------------------------------------------------
SUBROUTINE SrvD_End( u, p, x, xd, z, OtherState, y, ErrStat, ErrMsg )
! This routine is called at the end of the simulation.
!..................................................................................................................................

      TYPE(SrvD_InputType),           INTENT(INOUT)  :: u           ! System inputs
      TYPE(SrvD_ParameterType),       INTENT(INOUT)  :: p           ! Parameters
      TYPE(SrvD_ContinuousStateType), INTENT(INOUT)  :: x           ! Continuous states
      TYPE(SrvD_DiscreteStateType),   INTENT(INOUT)  :: xd          ! Discrete states
      TYPE(SrvD_ConstraintStateType), INTENT(INOUT)  :: z           ! Constraint states
      TYPE(SrvD_OtherStateType),      INTENT(INOUT)  :: OtherState  ! Other/optimization states
      TYPE(SrvD_OutputType),          INTENT(INOUT)  :: y           ! System outputs
      INTEGER(IntKi),                 INTENT(  OUT)  :: ErrStat     ! Error status of the operation
      CHARACTER(*),                   INTENT(  OUT)  :: ErrMsg      ! Error message if ErrStat /= ErrID_None



         ! Initialize ErrStat

      ErrStat = ErrID_None
      ErrMsg  = ""


         ! Place any last minute operations or calculations here:

      IF ( p%UseBladedInterface ) THEN
         CALL BladedInterface_End(u, p, OtherState, ErrStat, ErrMsg )
      END IF
         
         ! Close files here:
         

         ! Destroy the input data:

      CALL SrvD_DestroyInput( u, ErrStat, ErrMsg )


         ! Destroy the parameter data:

      CALL SrvD_DestroyParam( p, ErrStat, ErrMsg )


         ! Destroy the state data:

      CALL SrvD_DestroyContState(   x,           ErrStat, ErrMsg )
      CALL SrvD_DestroyDiscState(   xd,          ErrStat, ErrMsg )
      CALL SrvD_DestroyConstrState( z,           ErrStat, ErrMsg )
      CALL SrvD_DestroyOtherState(  OtherState,  ErrStat, ErrMsg )


         ! Destroy the output data:

      CALL SrvD_DestroyOutput( y, ErrStat, ErrMsg )




END SUBROUTINE SrvD_End
!----------------------------------------------------------------------------------------------------------------------------------
SUBROUTINE SrvD_UpdateStates( t, n, Inputs, InputTimes, p, x, xd, z, OtherState, ErrStat, ErrMsg )
! Loose coupling routine for solving for constraint states, integrating continuous states, and updating discrete states
! Constraint states are solved for input t; Continuous and discrete states are updated for t + Interval
!..................................................................................................................................

      REAL(DbKi),                      INTENT(IN   ) :: t               ! Current simulation time in seconds
      INTEGER(IntKi),                  INTENT(IN   ) :: n               ! Current step of the simulation: t = n*Interval
      TYPE(SrvD_InputType),            INTENT(INOUT) :: Inputs(:)       ! Inputs at InputTimes (output only for mesh record-keeping in ExtrapInterp routine)
      REAL(DbKi),                      INTENT(IN   ) :: InputTimes(:)   ! Times in seconds associated with Inputs
      TYPE(SrvD_ParameterType),        INTENT(IN   ) :: p               ! Parameters
      TYPE(SrvD_ContinuousStateType),  INTENT(INOUT) :: x               ! Input: Continuous states at t;
                                                                        !   Output: Continuous states at t + Interval
      TYPE(SrvD_DiscreteStateType),    INTENT(INOUT) :: xd              ! Input: Discrete states at t;
                                                                        !   Output: Discrete states at t  + Interval
      TYPE(SrvD_ConstraintStateType),  INTENT(INOUT) :: z               ! Input: Initial guess of constraint states at t;
                                                                        !   Output: Constraint states at t
      TYPE(SrvD_OtherStateType),       INTENT(INOUT) :: OtherState      ! Other/optimization states
      INTEGER(IntKi),                  INTENT(  OUT) :: ErrStat         ! Error status of the operation
      CHARACTER(*),                    INTENT(  OUT) :: ErrMsg          ! Error message if ErrStat /= ErrID_None

         ! Local variables

      TYPE(SrvD_ContinuousStateType)                 :: dxdt            ! Continuous state derivatives at t
      TYPE(SrvD_InputType)                           :: u               ! Inputs at t

      INTEGER(IntKi)                                 :: ErrStat2        ! Error status of the operation (occurs after initial error)
      CHARACTER(LEN(ErrMsg))                         :: ErrMsg2         ! Error message if ErrStat2 /= ErrID_None

      
      
         ! Initialize ErrStat

      ErrStat = ErrID_None
      ErrMsg  = ""


         ! Get the inputs at time t, based on the array of values sent by the glue code:
         
      CALL SrvD_Input_ExtrapInterp( Inputs, InputTimes, u, t, ErrStat, ErrMsg )  
      IF ( ErrStat >= AbortErrLev ) RETURN
            


         ! Get first time derivatives of continuous states (dxdt):

      CALL SrvD_CalcContStateDeriv( t, u, p, x, xd, z, OtherState, dxdt, ErrStat, ErrMsg )
      IF ( ErrStat >= AbortErrLev ) THEN
         CALL SrvD_DestroyContState( dxdt, ErrStat2, ErrMsg2)
         ErrMsg = TRIM(ErrMsg)//' '//TRIM(ErrMsg2)
         RETURN
      END IF


         ! Update discrete states:
         !   Note that xd [discrete state] is changed in SrvD_UpdateDiscState(), so SrvD_CalcOutput(),
         !   SrvD_CalcContStateDeriv(), and SrvD_CalcConstrStates() must be called first (see above).

      CALL SrvD_UpdateDiscState(t, u, p, x, xd, z, OtherState, ErrStat, ErrMsg )
      IF ( ErrStat >= AbortErrLev ) THEN
         CALL SrvD_DestroyContState( dxdt, ErrStat2, ErrMsg2)
         ErrMsg = TRIM(ErrMsg)//' '//TRIM(ErrMsg2)
         RETURN
      END IF


         ! Integrate (update) continuous states (x) here:

      !x = function of dxdt and x


         ! Destroy dxdt because it is not necessary for the rest of the subroutine

      CALL SrvD_DestroyContState( dxdt, ErrStat, ErrMsg)
      IF ( ErrStat >= AbortErrLev ) RETURN



END SUBROUTINE SrvD_UpdateStates
!----------------------------------------------------------------------------------------------------------------------------------
SUBROUTINE SrvD_CalcOutput( t, u, p, x, xd, z, OtherState, y, ErrStat, ErrMsg )
! Routine for computing outputs, used in both loose and tight coupling.
!..................................................................................................................................

   REAL(DbKi),                     INTENT(IN   )  :: t           ! Current simulation time in seconds
   TYPE(SrvD_InputType),           INTENT(IN   )  :: u           ! Inputs at t
   TYPE(SrvD_ParameterType),       INTENT(IN   )  :: p           ! Parameters
   TYPE(SrvD_ContinuousStateType), INTENT(IN   )  :: x           ! Continuous states at t
   TYPE(SrvD_DiscreteStateType),   INTENT(IN   )  :: xd          ! Discrete states at t
   TYPE(SrvD_ConstraintStateType), INTENT(IN   )  :: z           ! Constraint states at t
   TYPE(SrvD_OtherStateType),      INTENT(INOUT)  :: OtherState  ! Other/optimization states
   TYPE(SrvD_OutputType),          INTENT(INOUT)  :: y           ! Outputs computed at t (Input only so that mesh con-
                                                                  !   nectivity information does not have to be recalculated)
   INTEGER(IntKi),                 INTENT(  OUT)  :: ErrStat     ! Error status of the operation
   CHARACTER(*),                   INTENT(  OUT)  :: ErrMsg      ! Error message if ErrStat /= ErrID_None

      ! Local variables
   REAL(ReKi)                                     :: AllOuts(MaxOutPts)     ! All the the available output channels
   INTEGER(IntKi)                                 :: I                      ! Generic loop index
   INTEGER(IntKi)                                 :: K                      ! Blade index
   INTEGER(IntKi)                                 :: ErrStat2
   CHARACTER(LEN(ErrMsg))                         :: ErrMsg2
         
      ! Initialize ErrStat

   ErrStat = ErrID_None
   ErrMsg  = ""

   
   IF (  t >= p%THSSBrDp ) THEN
      IF ( OtherState%FirstWarn_THSSBrDp ) THEN
         CALL CheckError ( ErrID_Warn, 'THSSBrDp is ignored in this version of ServoDyn. '//&
                                       'Warning will not be displayed again.' )      
         OtherState%FirstWarn_THSSBrDp = .FALSE.
      END IF      
   END IF
   
   !...............................................................................................................................   
   ! Get the demanded values from the external Bladed dynamic link library, if necessary:
   !...............................................................................................................................   
   IF ( p%UseBladedInterface ) THEN
      
      IF ( .NOT. EqualRealNos( t - p%DT, OtherState%LastTimeCalled ) ) THEN
         IF (OtherState%FirstWarn) CALL CheckError ( ErrID_Warn, 'BladedInterface option was designed for an explicit-loose '//&
            'coupling scheme. Using last calculated values from DLL on all subsequent calls until time is advanced. '//&
            'Warning will not be displayed again.' )
         OtherState%FirstWarn = .FALSE.
      ELSE      
         OtherState%LastTimeCalled = t
         CALL BladedInterface_CalcOutput( t, u, p, OtherState, ErrStat2, ErrMsg2 )
            CALL CheckError( ErrStat2, ErrMsg2 )
            IF (ErrStat >= AbortErrLev) RETURN
      END IF
      
   END IF      
      
   !...............................................................................................................................   
   ! Compute the outputs
   !...............................................................................................................................   

      ! Torque control:
   CALL Torque_CalcOutput( t, u, p, x, xd, z, OtherState, y, ErrStat2, ErrMsg2 )      !  calculates ElecPwr, which Pitch_CalcOutput will use in the user pitch routine  
      CALL CheckError( ErrStat2, ErrMsg2)
      IF (ErrStat >= AbortErrLev) RETURN

      ! Pitch control:
   CALL Pitch_CalcOutput( t, u, p, x, xd, z, OtherState, y, ErrStat2, ErrMsg2 )  
      CALL CheckError( ErrStat2, ErrMsg2)
      IF (ErrStat >= AbortErrLev) RETURN

      ! Yaw control: 
   CALL Yaw_CalcOutput( t, u, p, x, xd, z, OtherState, y, ErrStat2, ErrMsg2 )      
      CALL CheckError( ErrStat2, ErrMsg2)
      IF (ErrStat >= AbortErrLev) RETURN

      ! Tip brake control: 
   CALL TipBrake_CalcOutput( t, u, p, x, xd, z, OtherState, y, ErrStat2, ErrMsg2 )      
      CALL CheckError( ErrStat2, ErrMsg2)
      IF (ErrStat >= AbortErrLev) RETURN
   
   !...............................................................................................................................   
   ! Calculate all of the available output channels:
   !...............................................................................................................................   
!   AllOuts(Time) = t    
   
   AllOuts(GenTq)   = 0.001*y%GenTrq
   AllOuts(GenPwr)  = 0.001*y%ElecPwr
   AllOuts(HSSBrTq) = 0.001*y%HSSBrTrq

   DO K=1,p%NumBl
      AllOuts( BlPitchC(K) ) = y%BlPitchCom(K)
   END DO        
   
   AllOuts(YawMomCom) = y%YawMom
      
   !...............................................................................................................................   
   ! Place the selected output channels into the WriteOutput(:) array with the proper sign:
   !...............................................................................................................................   

   DO I = 1,p%NumOuts  ! Loop through all selected output channels

      y%WriteOutput(I) = p%OutParam(I)%SignM * AllOuts( p%OutParam(I)%Indx )

   ENDDO             ! I - All selected output channels
   
   RETURN
CONTAINS
   !...............................................................................................................................
   SUBROUTINE CheckError(ErrID,Msg)
   ! This subroutine sets the error message and level and cleans up if the error is >= AbortErrLev
   !...............................................................................................................................

         ! Passed arguments
      INTEGER(IntKi), INTENT(IN) :: ErrID       ! The error identifier (ErrStat)
      CHARACTER(*),   INTENT(IN) :: Msg         ! The error message (ErrMsg)


      !............................................................................................................................
      ! Set error status/message;
      !............................................................................................................................

      IF ( ErrID /= ErrID_None ) THEN

         IF (ErrStat /= ErrID_None) ErrMsg = TRIM(ErrMsg)//NewLine
         ErrMsg = TRIM(ErrMsg)//'SrvD_CalcOutput:'//TRIM(Msg)
         ErrStat = MAX(ErrStat, ErrID)

         !.........................................................................................................................
         ! Clean up if we're going to return on error: close files, deallocate local arrays
         !.........................................................................................................................
         IF ( ErrStat >= AbortErrLev ) THEN
         END IF

      END IF


   END SUBROUTINE CheckError        
   !...............................................................................................................................
END SUBROUTINE SrvD_CalcOutput
!----------------------------------------------------------------------------------------------------------------------------------
SUBROUTINE SrvD_CalcContStateDeriv( t, u, p, x, xd, z, OtherState, dxdt, ErrStat, ErrMsg )
! Tight coupling routine for computing derivatives of continuous states
!..................................................................................................................................

      REAL(DbKi),                     INTENT(IN   )  :: t           ! Current simulation time in seconds
      TYPE(SrvD_InputType),           INTENT(IN   )  :: u           ! Inputs at t
      TYPE(SrvD_ParameterType),       INTENT(IN   )  :: p           ! Parameters
      TYPE(SrvD_ContinuousStateType), INTENT(IN   )  :: x           ! Continuous states at t
      TYPE(SrvD_DiscreteStateType),   INTENT(IN   )  :: xd          ! Discrete states at t
      TYPE(SrvD_ConstraintStateType), INTENT(IN   )  :: z           ! Constraint states at t
      TYPE(SrvD_OtherStateType),      INTENT(INOUT)  :: OtherState  ! Other/optimization states
      TYPE(SrvD_ContinuousStateType), INTENT(  OUT)  :: dxdt        ! Continuous state derivatives at t
      INTEGER(IntKi),                 INTENT(  OUT)  :: ErrStat     ! Error status of the operation
      CHARACTER(*),                   INTENT(  OUT)  :: ErrMsg      ! Error message if ErrStat /= ErrID_None


         ! Initialize ErrStat

      ErrStat = ErrID_None
      ErrMsg  = ""


         ! Compute the first time derivatives of the continuous states here:

      dxdt%DummyContState = 0.0


END SUBROUTINE SrvD_CalcContStateDeriv
!----------------------------------------------------------------------------------------------------------------------------------
SUBROUTINE SrvD_UpdateDiscState( t, u, p, x, xd, z, OtherState, ErrStat, ErrMsg )
! Tight coupling routine for updating discrete states
!..................................................................................................................................

      REAL(DbKi),                     INTENT(IN   )  :: t           ! Current simulation time in seconds
      TYPE(SrvD_InputType),           INTENT(IN   )  :: u           ! Inputs at t
      TYPE(SrvD_ParameterType),       INTENT(IN   )  :: p           ! Parameters
      TYPE(SrvD_ContinuousStateType), INTENT(IN   )  :: x           ! Continuous states at t
      TYPE(SrvD_DiscreteStateType),   INTENT(INOUT)  :: xd          ! Input: Discrete states at t;
                                                                    !   Output: Discrete states at t + Interval
      TYPE(SrvD_ConstraintStateType), INTENT(IN   )  :: z           ! Constraint states at t
      TYPE(SrvD_OtherStateType),      INTENT(INOUT)  :: OtherState  ! Other/optimization states
      INTEGER(IntKi),                 INTENT(  OUT)  :: ErrStat     ! Error status of the operation
      CHARACTER(*),                   INTENT(  OUT)  :: ErrMsg      ! Error message if ErrStat /= ErrID_None


         ! Initialize ErrStat

      ErrStat = ErrID_None
      ErrMsg  = ""


         ! Update discrete states here:

      ! StateData%DiscState =

END SUBROUTINE SrvD_UpdateDiscState
!----------------------------------------------------------------------------------------------------------------------------------
SUBROUTINE SrvD_CalcConstrStateResidual( t, u, p, x, xd, z, OtherState, z_residual, ErrStat, ErrMsg )
! Tight coupling routine for solving for the residual of the constraint state equations
!..................................................................................................................................

      REAL(DbKi),                     INTENT(IN   )  :: t           ! Current simulation time in seconds
      TYPE(SrvD_InputType),           INTENT(IN   )  :: u           ! Inputs at t
      TYPE(SrvD_ParameterType),       INTENT(IN   )  :: p           ! Parameters
      TYPE(SrvD_ContinuousStateType), INTENT(IN   )  :: x           ! Continuous states at t
      TYPE(SrvD_DiscreteStateType),   INTENT(IN   )  :: xd          ! Discrete states at t
      TYPE(SrvD_ConstraintStateType), INTENT(IN   )  :: z           ! Constraint states at t (possibly a guess)
      TYPE(SrvD_OtherStateType),      INTENT(INOUT)  :: OtherState  ! Other/optimization states
      TYPE(SrvD_ConstraintStateType), INTENT(  OUT)  :: z_residual  ! Residual of the constraint state equations using
                                                                    !     the input values described above
      INTEGER(IntKi),                 INTENT(  OUT)  :: ErrStat     ! Error status of the operation
      CHARACTER(*),                   INTENT(  OUT)  :: ErrMsg      ! Error message if ErrStat /= ErrID_None


         ! Initialize ErrStat

      ErrStat = ErrID_None
      ErrMsg  = ""


         ! Solve for the constraint states here:

      z_residual%DummyConstrState = 0.0_ReKi

END SUBROUTINE SrvD_CalcConstrStateResidual
!++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
! WE ARE NOT YET IMPLEMENTING THE JACOBIANS...
!++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!----------------------------------------------------------------------------------------------------------------------------------
SUBROUTINE SrvD_ReadInput( InputFileName, InputFileData, Default_DT, OutFileRoot, ErrStat, ErrMsg )
! This subroutine reads the input file and stores all the data in the SrvD_InputFile structure.
! It does not perform data validation.
!..................................................................................................................................

      ! Passed variables
   REAL(DbKi),           INTENT(IN)       :: Default_DT     ! The default DT (from glue code)

   CHARACTER(*), INTENT(IN)               :: InputFileName  ! Name of the input file
   CHARACTER(*), INTENT(IN)               :: OutFileRoot    ! The rootname of all the output files written by this routine.

   TYPE(SrvD_InputFile),  INTENT(OUT)     :: InputFileData  ! Data stored in the module's input file

   INTEGER(IntKi),       INTENT(OUT)      :: ErrStat        ! The error status code
   CHARACTER(*),         INTENT(OUT)      :: ErrMsg         ! The error message, if an error occurred

      ! local variables

   INTEGER(IntKi)                         :: UnEcho         ! Unit number for the echo file
   INTEGER(IntKi)                         :: ErrStat2       ! The error status code
   CHARACTER(LEN(ErrMsg))                 :: ErrMsg2        ! The error message, if an error occurred
   
      ! initialize values: 
   
   ErrStat = ErrID_None
   ErrMsg  = ''

   InputFileData%DT = Default_DT  ! the glue code's suggested DT for the module (may be overwritten in ReadPrimaryFile())
   
      ! get the primary/platform input-file data
   
   CALL ReadPrimaryFile( InputFileName, InputFileData, OutFileRoot, UnEcho, ErrStat2, ErrMsg2 )
      CALL CheckError(ErrStat2,ErrMsg2)
      IF ( ErrStat >= AbortErrLev ) RETURN
      

      ! we may need to read additional files here (e.g., Bladed Interface)
   
      
      ! close any echo file that was opened
      
   IF ( UnEcho > 0 ) CLOSE( UnEcho )        

CONTAINS
   !...............................................................................................................................
   SUBROUTINE CheckError(ErrID,Msg)
   ! This subroutine sets the error message and level and cleans up if the error is >= AbortErrLev
   !...............................................................................................................................

         ! Passed arguments
      INTEGER(IntKi), INTENT(IN) :: ErrID       ! The error identifier (ErrStat)
      CHARACTER(*),   INTENT(IN) :: Msg         ! The error message (ErrMsg)


      !............................................................................................................................
      ! Set error status/message;
      !............................................................................................................................

      IF ( ErrID /= ErrID_None ) THEN

         IF (ErrStat /= ErrID_None) ErrMsg = TRIM(ErrMsg)//NewLine
         ErrMsg = TRIM(ErrMsg)//'SrvD_ReadInput:'//TRIM(Msg)
         ErrStat = MAX(ErrStat, ErrID)

         !.........................................................................................................................
         ! Clean up if we're going to return on error: close files, deallocate local arrays
         !.........................................................................................................................
         IF ( ErrStat >= AbortErrLev ) THEN
            IF ( UnEcho > 0 ) CLOSE( UnEcho )
         END IF

      END IF


   END SUBROUTINE CheckError     

END SUBROUTINE SrvD_ReadInput
!----------------------------------------------------------------------------------------------------------------------------------
SUBROUTINE ReadPrimaryFile( InputFile, InputFileData, OutFileRoot, UnEc, ErrStat, ErrMsg )
! This routine reads in the primary ServoDyn input file and places the values it reads in the InputFileData structure.
!   It opens and prints to an echo file if requested.
!..................................................................................................................................


   IMPLICIT                        NONE

      ! Passed variables
   INTEGER(IntKi),     INTENT(OUT)     :: UnEc                                ! I/O unit for echo file. If > 0, file is open for writing.
   INTEGER(IntKi),     INTENT(OUT)     :: ErrStat                             ! Error status

   CHARACTER(*),       INTENT(IN)      :: InputFile                           ! Name of the file containing the primary input data
   CHARACTER(*),       INTENT(OUT)     :: ErrMsg                              ! Error message
   CHARACTER(*),       INTENT(IN)      :: OutFileRoot                         ! The rootname of the echo file, possibly opened in this routine

   TYPE(SrvD_InputFile), INTENT(INOUT) :: InputFileData                       ! All the data in the ServoDyn input file
   
      ! Local variables:
   REAL(ReKi)                    :: TmpRAry(2)                                ! A temporary array to read a table from the input file
   INTEGER(IntKi)                :: I                                         ! loop counter
   INTEGER(IntKi)                :: NumOuts                                   ! Number of output channel names read from the file 
   INTEGER(IntKi)                :: UnIn                                      ! Unit number for reading file
     
   INTEGER(IntKi)                :: ErrStat2                                  ! Temporary Error status
   LOGICAL                       :: Echo                                      ! Determines if an echo file should be written
   CHARACTER(LEN(ErrMsg))        :: ErrMsg2                                   ! Temporary Error message
   CHARACTER(1024)               :: PriPath                                   ! Path name of the primary file
   CHARACTER(1024)               :: FTitle                                    ! "File Title": the 2nd line of the input file, which contains a description of its contents
   CHARACTER(200)                :: Line                                      ! Temporary storage of a line from the input file (to compare with "default")

   
      ! Initialize some variables:
   ErrStat = ErrID_None
   ErrMsg  = ""
      
   UnEc = -1
   Echo = .FALSE.   
   CALL GetPath( InputFile, PriPath )     ! Input files will be relative to the path where the primary input file is located.
   

   CALL AllocAry( InputFileData%OutList, MaxOutPts, "ServoDyn Input File's Outlist", ErrStat2, ErrMsg2 )
      CALL CheckError( ErrStat2, ErrMsg2 )
      IF ( ErrStat >= AbortErrLev ) RETURN   
      
   
      ! Get an available unit number for the file.

   CALL GetNewUnit( UnIn, ErrStat2, ErrMsg2 )
      CALL CheckError( ErrStat2, ErrMsg2 )
      IF ( ErrStat >= AbortErrLev ) RETURN


      ! Open the Primary input file.

   CALL OpenFInpFile ( UnIn, InputFile, ErrStat2, ErrMsg2 )
      CALL CheckError( ErrStat2, ErrMsg2 )
      IF ( ErrStat >= AbortErrLev ) RETURN
                  
      
   ! Read the lines up/including to the "Echo" simulation control variable
   ! If echo is FALSE, don't write these lines to the echo file. 
   ! If Echo is TRUE, rewind and write on the second try.
   
   I = 1 !set the number of times we've read the file
   DO 
   !-------------------------- HEADER ---------------------------------------------
   
      CALL ReadCom( UnIn, InputFile, 'File header: Module Version (line 1)', ErrStat2, ErrMsg2, UnEc )
         CALL CheckError( ErrStat2, ErrMsg2 )
         IF ( ErrStat >= AbortErrLev ) RETURN
   
      CALL ReadStr( UnIn, InputFile, FTitle, 'FTitle', 'File Header: File Description (line 2)', ErrStat2, ErrMsg2, UnEc )
         CALL CheckError( ErrStat2, ErrMsg2 )
         IF ( ErrStat >= AbortErrLev ) RETURN
   
   
   !---------------------- SIMULATION CONTROL --------------------------------------
   
      CALL ReadCom( UnIn, InputFile, 'Section Header: Simulation Control', ErrStat2, ErrMsg2, UnEc )
         CALL CheckError( ErrStat2, ErrMsg2 )
         IF ( ErrStat >= AbortErrLev ) RETURN
   
         ! Echo - Echo input to "<RootName>.ech".
   
      CALL ReadVar( UnIn, InputFile, Echo, 'Echo',   'Echo switch', ErrStat2, ErrMsg2, UnEc )
         CALL CheckError( ErrStat2, ErrMsg2 )
         IF ( ErrStat >= AbortErrLev ) RETURN
   
   
      IF (.NOT. Echo .OR. I > 1) EXIT !exit this loop
   
         ! Otherwise, open the echo file, then rewind the input file and echo everything we've read
      
      I = I + 1         ! make sure we do this only once (increment counter that says how many times we've read this file)
   
      CALL OpenEcho ( UnEc, TRIM(OutFileRoot)//'.ech', ErrStat2, ErrMsg2, SrvD_Ver )
         CALL CheckError( ErrStat2, ErrMsg2 )
         IF ( ErrStat >= AbortErrLev ) RETURN
   
      IF ( UnEc > 0 )  WRITE (UnEc,'(/,A,/)')  'Data from '//TRIM(SrvD_Ver%Name)//' primary input file "'//TRIM( InputFile )//'":'
         
      REWIND( UnIn, IOSTAT=ErrStat2 )  
         IF (ErrStat2 /= 0_IntKi ) THEN
            CALL CheckError( ErrID_Fatal, 'Error rewinding file "'//TRIM(InputFile)//'".' )      
            RETURN
         END IF         
      
   END DO    

   IF (NWTC_VerboseLevel == NWTC_Verbose) THEN
      CALL WrScr( ' Heading of the '//TRIM(SrvD_Ver%Name)//' input file: ' )      
      CALL WrScr( '   '//TRIM( FTitle ) )
   END IF
   
   
      ! DT - Communication interval for controllers (s):
   CALL ReadVar( UnIn, InputFile, Line, "DT", "Communication interval for controllers (s)", ErrStat2, ErrMsg2, UnEc)
      CALL CheckError( ErrStat2, ErrMsg2 )
      IF ( ErrStat >= AbortErrLev ) RETURN
      CALL Conv2UC( Line )
      IF ( INDEX(Line, "DEFAULT" ) /= 1 ) THEN ! If it's not "default", read this variable; otherwise use the value already stored in InputFileData%DT
         READ( Line, *, IOSTAT=ErrStat2) InputFileData%DT
         IF ( ErrStat2 /= 0 ) THEN
            CALL CheckIOS ( ErrStat2, InputFile, "DT", NumType, .TRUE., ErrMsg2 )
            CALL CheckError( ErrID_Fatal, ErrMsg2 )
            RETURN
         END IF
      END IF   
      
      
   !---------------------- PITCH CONTROL -------------------------------------------
   CALL ReadCom( UnIn, InputFile, 'Section Header: Pitch Control', ErrStat2, ErrMsg2, UnEc )
      CALL CheckError( ErrStat2, ErrMsg2 )
      IF ( ErrStat >= AbortErrLev ) RETURN
      
      ! PCMode - Pitch control mode (-):
   CALL ReadVar( UnIn, InputFile, InputFileData%PCMode, "PCMode", "Pitch control mode (-)", ErrStat2, ErrMsg2, UnEc)
      CALL CheckError( ErrStat2, ErrMsg2 )
      IF ( ErrStat >= AbortErrLev ) RETURN

      ! TPCOn - Time to enable active pitch control [unused when PCMode=0] (s):
   CALL ReadVar( UnIn, InputFile, InputFileData%TPCOn, "TPCOn", "Time to enable active pitch control (s)", ErrStat2, ErrMsg2, UnEc)
      CALL CheckError( ErrStat2, ErrMsg2 )
      IF ( ErrStat >= AbortErrLev ) RETURN

      ! TPitManS - Time to start override pitch maneuver for blade (K) and end standard pitch control (s):
   CALL ReadAryLines( UnIn, InputFile, InputFileData%TPitManS, SIZE(InputFileData%TPitManS), "TPitManS", &
        "Time to start override pitch maneuver for blade K and end standard pitch control (s)", ErrStat2, ErrMsg2, UnEc)
      CALL CheckError( ErrStat2, ErrMsg2 )
      IF ( ErrStat >= AbortErrLev ) RETURN

      ! PitManRat - Pitch rates at which override pitch maneuvers head toward final pitch angles (degrees/s) (read in deg/s and converted to radians/s here):
   CALL ReadAryLines( UnIn, InputFile, InputFileData%PitManRat, SIZE(InputFileData%PitManRat), "PitManRat", "Pitch rates at which override pitch maneuvers head toward final pitch angles (deg/s)", ErrStat2, ErrMsg2, UnEc)
      CALL CheckError( ErrStat2, ErrMsg2 )
      IF ( ErrStat >= AbortErrLev ) RETURN
   InputFileData%PitManRat = InputFileData%PitManRat*D2R

      ! BlPitchF - Blade (K) final pitch for pitch maneuvers (deg) (read from file in degrees and converted to radians here):
   CALL ReadAryLines( UnIn, InputFile, InputFileData%BlPitchF, SIZE(InputFileData%BlPitchF), "BlPitchF", "Blade K final pitch for pitch maneuvers (deg)", ErrStat2, ErrMsg2, UnEc)
      CALL CheckError( ErrStat2, ErrMsg2 )
      IF ( ErrStat >= AbortErrLev ) RETURN
   InputFileData%BlPitchF = InputFileData%BlPitchF*D2R
   
   !---------------------- GENERATOR AND TORQUE CONTROL ----------------------------
   CALL ReadCom( UnIn, InputFile, 'Section Header: Generator and Torque Control', ErrStat2, ErrMsg2, UnEc )
      CALL CheckError( ErrStat2, ErrMsg2 )
      IF ( ErrStat >= AbortErrLev ) RETURN
      
      ! VSContrl - Variable-speed control mode {0: none, 1: simple VS, 2: user-defined from routine UserVSCont, 3: user-defined from Simulink/Labview} (-):
   CALL ReadVar( UnIn, InputFile, InputFileData%VSContrl, "VSContrl", "Variable-speed control mode (-)", ErrStat2, ErrMsg2, UnEc)
      CALL CheckError( ErrStat2, ErrMsg2 )
      IF ( ErrStat >= AbortErrLev ) RETURN

      ! GenModel - Generator model {1: simple, 2: Thevenin, 3: user-defined from routine UserGen} [used only when VSContrl=0] (-):
   CALL ReadVar( UnIn, InputFile, InputFileData%GenModel, "GenModel", "Generator model {1: simple, 2: Thevenin, 3: user-defined from routine UserGen} [used only when VSContrl=0] (-)", ErrStat2, ErrMsg2, UnEc)
      CALL CheckError( ErrStat2, ErrMsg2 )
      IF ( ErrStat >= AbortErrLev ) RETURN

      ! GenEff - Generator efficiency [ignored by the Thevenin and user-defined generator models] (%) (read in percent and converted to a fraction here):
   CALL ReadVar( UnIn, InputFile, InputFileData%GenEff, "GenEff", "Generator efficiency [ignored by the Thevenin and user-defined generator models] (%)", ErrStat2, ErrMsg2, UnEc)
      CALL CheckError( ErrStat2, ErrMsg2 )
      IF ( ErrStat >= AbortErrLev ) RETURN
   InputFileData%GenEff = InputFileData%GenEff*0.01      

      ! GenTiStr - Method to start the generator {T: timed using TimGenOn, F: generator speed using SpdGenOn} (flag):
   CALL ReadVar( UnIn, InputFile, InputFileData%GenTiStr, "GenTiStr", "Method to start the generator {T: timed using TimGenOn, F: generator speed using SpdGenOn} (flag)", ErrStat2, ErrMsg2, UnEc)
      CALL CheckError( ErrStat2, ErrMsg2 )
      IF ( ErrStat >= AbortErrLev ) RETURN

      ! GenTiStp - Method to stop the generator {T: timed using TimGenOf, F: when generator power = 0} (flag):
   CALL ReadVar( UnIn, InputFile, InputFileData%GenTiStp, "GenTiStp", "Method to stop the generator {T: timed using TimGenOf, F: when generator power = 0} (flag)", ErrStat2, ErrMsg2, UnEc)
      CALL CheckError( ErrStat2, ErrMsg2 )
      IF ( ErrStat >= AbortErrLev ) RETURN

      ! SpdGenOn - Generator speed to turn on the generator for a startup (HSS speed) [used only when GenTiStr=False] (rpm) (read in rpm and converted to rad/sec here):
   CALL ReadVar( UnIn, InputFile, InputFileData%SpdGenOn, "SpdGenOn", "Generator speed to turn on the generator for a startup (HSS speed) [used only when GenTiStr=False] (rpm)", ErrStat2, ErrMsg2, UnEc)
      CALL CheckError( ErrStat2, ErrMsg2 )
      IF ( ErrStat >= AbortErrLev ) RETURN
   InputFileData%SpdGenOn = InputFileData%SpdGenOn*RPM2RPS

      ! TimGenOn - Time to turn on the generator for a startup [used only when GenTiStr=True] (s):
   CALL ReadVar( UnIn, InputFile, InputFileData%TimGenOn, "TimGenOn", "Time to turn on the generator for a startup [used only when GenTiStr=True] (s)", ErrStat2, ErrMsg2, UnEc)
      CALL CheckError( ErrStat2, ErrMsg2 )
      IF ( ErrStat >= AbortErrLev ) RETURN

      ! TimGenOf - Time to turn off the generator [used only when GenTiStp=True] (s):
   CALL ReadVar( UnIn, InputFile, InputFileData%TimGenOf, "TimGenOf", "Time to turn off the generator [used only when GenTiStp=True] (s)", ErrStat2, ErrMsg2, UnEc)
      CALL CheckError( ErrStat2, ErrMsg2 )
      IF ( ErrStat >= AbortErrLev ) RETURN
      
   !---------------------- SIMPLE VARIABLE-SPEED TORQUE CONTROL --------------------
   CALL ReadCom( UnIn, InputFile, 'Section Header: Simple Variable-Speed Torque Control', ErrStat2, ErrMsg2, UnEc )
      CALL CheckError( ErrStat2, ErrMsg2 )
      IF ( ErrStat >= AbortErrLev ) RETURN
      
      ! VS_RtGnSp - Rated generator speed for simple variable-speed generator control (HSS side) [used only when VSContrl=1] (rpm) (read in rpm and converted to rad/sec here):
   CALL ReadVar( UnIn, InputFile, InputFileData%VS_RtGnSp, "VS_RtGnSp", "Rated generator speed for simple variable-speed generator control (HSS side) [used only when VSContrl=1] (rpm)", ErrStat2, ErrMsg2, UnEc)
      CALL CheckError( ErrStat2, ErrMsg2 )
      IF ( ErrStat >= AbortErrLev ) RETURN
   InputFileData%VS_RtGnSp = InputFileData%VS_RtGnSp*RPM2RPS
      
      ! VS_RtTq - Rated generator torque/constant generator torque in Region 3 for simple variable-speed generator control (HSS side) [used only when VSContrl=1] (N-m):
   CALL ReadVar( UnIn, InputFile, InputFileData%VS_RtTq, "VS_RtTq", "Rated generator torque/constant generator torque in Region 3 for simple variable-speed generator control (HSS side) [used only when VSContrl=1] (N-m)", ErrStat2, ErrMsg2, UnEc)
      CALL CheckError( ErrStat2, ErrMsg2 )
      IF ( ErrStat >= AbortErrLev ) RETURN

      ! VS_Rgn2K - Generator torque constant in Region 2 for simple variable-speed generator control (HSS side) [used only when VSContrl=1] (N-m/rpm^2) (read in N-m/rpm^2 and converted to N-m/(rad/s)^2 here:
   CALL ReadVar( UnIn, InputFile, InputFileData%VS_Rgn2K, "VS_Rgn2K", "Generator torque constant in Region 2 for simple variable-speed generator control (HSS side) [used only when VSContrl=1] (N-m/rpm^2)", ErrStat2, ErrMsg2, UnEc)
      CALL CheckError( ErrStat2, ErrMsg2 )
      IF ( ErrStat >= AbortErrLev ) RETURN
   InputFileData%VS_Rgn2K = InputFileData%VS_Rgn2K/( RPM2RPS**2 )

      ! VS_SlPc - Rated generator slip percentage in Region 2 1/2 for simple variable-speed generator control [used only when VSContrl=1] (%) (read in percent and converted to a fraction here):
   CALL ReadVar( UnIn, InputFile, InputFileData%VS_SlPc, "VS_SlPc", "Rated generator slip percentage in Region 2 1/2 for simple variable-speed generator control [used only when VSContrl=1] (%)", ErrStat2, ErrMsg2, UnEc)
      CALL CheckError( ErrStat2, ErrMsg2 )
      IF ( ErrStat >= AbortErrLev ) RETURN     
   InputFileData%VS_SlPc = InputFileData%VS_SlPc*.01
   
   !---------------------- SIMPLE INDUCTION GENERATOR ------------------------------
   CALL ReadCom( UnIn, InputFile, 'Section Header: Simple Induction Generator', ErrStat2, ErrMsg2, UnEc )
      CALL CheckError( ErrStat2, ErrMsg2 )
      IF ( ErrStat >= AbortErrLev ) RETURN
      
      ! SIG_SlPc - Rated generator slip percentage [used only when VSContrl=0 and GenModel=1] (%) (read in percent and converted to a fraction here):
   CALL ReadVar( UnIn, InputFile, InputFileData%SIG_SlPc, "SIG_SlPc", "Rated generator slip percentage [used only when VSContrl=0 and GenModel=1] (%)", ErrStat2, ErrMsg2, UnEc)
      CALL CheckError( ErrStat2, ErrMsg2 )
      IF ( ErrStat >= AbortErrLev ) RETURN
   InputFileData%SIG_SlPc = InputFileData%SIG_SlPc*.01

      ! SIG_SySp - Synchronous (zero-torque) generator speed [used only when VSContrl=0 and GenModel=1] (rpm) (read in rpm and convert to rad/sec here):
   CALL ReadVar( UnIn, InputFile, InputFileData%SIG_SySp, "SIG_SySp", "Synchronous (zero-torque) generator speed [used only when VSContrl=0 and GenModel=1] (rpm)", ErrStat2, ErrMsg2, UnEc)
      CALL CheckError( ErrStat2, ErrMsg2 )
      IF ( ErrStat >= AbortErrLev ) RETURN
   InputFileData%SIG_SySp = InputFileData%SIG_SySp*RPM2RPS  
      

      ! SIG_RtTq - Rated torque [used only when VSContrl=0 and GenModel=1] (N-m):
   CALL ReadVar( UnIn, InputFile, InputFileData%SIG_RtTq, "SIG_RtTq", "Rated torque [used only when VSContrl=0 and GenModel=1] (N-m)", ErrStat2, ErrMsg2, UnEc)
      CALL CheckError( ErrStat2, ErrMsg2 )
      IF ( ErrStat >= AbortErrLev ) RETURN

      ! SIG_PORt - Pull-out ratio (Tpullout/Trated) [used only when VSContrl=0 and GenModel=1] (-):
   CALL ReadVar( UnIn, InputFile, InputFileData%SIG_PORt, "SIG_PORt", "Pull-out ratio (Tpullout/Trated) [used only when VSContrl=0 and GenModel=1] (-)", ErrStat2, ErrMsg2, UnEc)
      CALL CheckError( ErrStat2, ErrMsg2 )
      IF ( ErrStat >= AbortErrLev ) RETURN
      
   !---------------------- THEVENIN-EQUIVALENT INDUCTION GENERATOR -----------------
   CALL ReadCom( UnIn, InputFile, 'Section Header: Thevenin-Equivalent Induction Generator', ErrStat2, ErrMsg2, UnEc )
      CALL CheckError( ErrStat2, ErrMsg2 )
      IF ( ErrStat >= AbortErrLev ) RETURN
      
      ! TEC_Freq - Line frequency [50 or 60] [used only when VSContrl=0 and GenModel=2] (Hz):
   CALL ReadVar( UnIn, InputFile, InputFileData%TEC_Freq, "TEC_Freq", "Line frequency [50 or 60] [used only when VSContrl=0 and GenModel=2] (Hz)", ErrStat2, ErrMsg2, UnEc)
      CALL CheckError( ErrStat2, ErrMsg2 )
      IF ( ErrStat >= AbortErrLev ) RETURN

      ! TEC_NPol - Number of poles [even integer > 0] [used only when VSContrl=0 and GenModel=2] (-):
   CALL ReadVar( UnIn, InputFile, InputFileData%TEC_NPol, "TEC_NPol", "Number of poles [even integer > 0] [used only when VSContrl=0 and GenModel=2] (-)", ErrStat2, ErrMsg2, UnEc)
      CALL CheckError( ErrStat2, ErrMsg2 )
      IF ( ErrStat >= AbortErrLev ) RETURN

      ! TEC_SRes - Stator resistance [used only when VSContrl=0 and GenModel=2] (ohms):
   CALL ReadVar( UnIn, InputFile, InputFileData%TEC_SRes, "TEC_SRes", "Stator resistance [used only when VSContrl=0 and GenModel=2] (ohms)", ErrStat2, ErrMsg2, UnEc)
      CALL CheckError( ErrStat2, ErrMsg2 )
      IF ( ErrStat >= AbortErrLev ) RETURN

      ! TEC_RRes - Rotor resistance [used only when VSContrl=0 and GenModel=2] (ohms):
   CALL ReadVar( UnIn, InputFile, InputFileData%TEC_RRes, "TEC_RRes", "Rotor resistance [used only when VSContrl=0 and GenModel=2] (ohms)", ErrStat2, ErrMsg2, UnEc)
      CALL CheckError( ErrStat2, ErrMsg2 )
      IF ( ErrStat >= AbortErrLev ) RETURN

      ! TEC_VLL - Line-to-line RMS voltage [used only when VSContrl=0 and GenModel=2] (volts):
   CALL ReadVar( UnIn, InputFile, InputFileData%TEC_VLL, "TEC_VLL", "Line-to-line RMS voltage [used only when VSContrl=0 and GenModel=2] (volts)", ErrStat2, ErrMsg2, UnEc)
      CALL CheckError( ErrStat2, ErrMsg2 )
      IF ( ErrStat >= AbortErrLev ) RETURN

      ! TEC_SLR - Stator leakage reactance [used only when VSContrl=0 and GenModel=2] (ohms):
   CALL ReadVar( UnIn, InputFile, InputFileData%TEC_SLR, "TEC_SLR", "Stator leakage reactance [used only when VSContrl=0 and GenModel=2] (ohms)", ErrStat2, ErrMsg2, UnEc)
      CALL CheckError( ErrStat2, ErrMsg2 )
      IF ( ErrStat >= AbortErrLev ) RETURN

      ! TEC_RLR - Rotor leakage reactance [used only when VSContrl=0 and GenModel=2] (ohms):
   CALL ReadVar( UnIn, InputFile, InputFileData%TEC_RLR, "TEC_RLR", "Rotor leakage reactance [used only when VSContrl=0 and GenModel=2] (ohms)", ErrStat2, ErrMsg2, UnEc)
      CALL CheckError( ErrStat2, ErrMsg2 )
      IF ( ErrStat >= AbortErrLev ) RETURN

      ! TEC_MR - Magnetizing reactance [used only when VSContrl=0 and GenModel=2] (ohms):
   CALL ReadVar( UnIn, InputFile, InputFileData%TEC_MR, "TEC_MR", "Magnetizing reactance [used only when VSContrl=0 and GenModel=2] (ohms)", ErrStat2, ErrMsg2, UnEc)
      CALL CheckError( ErrStat2, ErrMsg2 )
      IF ( ErrStat >= AbortErrLev ) RETURN
      
   !---------------------- HIGH-SPEED SHAFT BRAKE ----------------------------------
   CALL ReadCom( UnIn, InputFile, 'Section Header: High-Speed Shaft Brake', ErrStat2, ErrMsg2, UnEc )
      CALL CheckError( ErrStat2, ErrMsg2 )
      IF ( ErrStat >= AbortErrLev ) RETURN
      
      ! HSSBrMode - HSS brake model {1: simple, 2: user-defined from routine UserHSSBr, 3: user-defined from Labview} (-):
   CALL ReadVar( UnIn, InputFile, InputFileData%HSSBrMode, "HSSBrMode", "HSS brake model {1: simple, 2: user-defined from routine UserHSSBr, 3: user-defined from Labview} (-)", ErrStat2, ErrMsg2, UnEc)
      CALL CheckError( ErrStat2, ErrMsg2 )
      IF ( ErrStat >= AbortErrLev ) RETURN

      ! THSSBrDp - Time to initiate deployment of the HSS brake (s):
   CALL ReadVar( UnIn, InputFile, InputFileData%THSSBrDp, "THSSBrDp", "Time to initiate deployment of the HSS brake (s)", ErrStat2, ErrMsg2, UnEc)
      CALL CheckError( ErrStat2, ErrMsg2 )
      IF ( ErrStat >= AbortErrLev ) RETURN

      ! HSSBrDT - Time for HSS-brake to reach full deployment once initiated [used only when HSSBrMode=1] (sec):
   CALL ReadVar( UnIn, InputFile, InputFileData%HSSBrDT, "HSSBrDT", "Time for HSS-brake to reach full deployment once initiated [used only when HSSBrMode=1] (sec)", ErrStat2, ErrMsg2, UnEc)
      CALL CheckError( ErrStat2, ErrMsg2 )
      IF ( ErrStat >= AbortErrLev ) RETURN

      ! HSSBrTqF - Fully deployed HSS-brake torque (N-m):
   CALL ReadVar( UnIn, InputFile, InputFileData%HSSBrTqF, "HSSBrTqF", "Fully deployed HSS-brake torque (N-m)", ErrStat2, ErrMsg2, UnEc)
      CALL CheckError( ErrStat2, ErrMsg2 )
      IF ( ErrStat >= AbortErrLev ) RETURN
      
   !---------------------- YAW CONTROL ---------------------------------------------
   CALL ReadCom( UnIn, InputFile, 'Section Header: Yaw Control', ErrStat2, ErrMsg2, UnEc )
      CALL CheckError( ErrStat2, ErrMsg2 )
      IF ( ErrStat >= AbortErrLev ) RETURN
      
      ! YCMode - Yaw control mode {0: none, 1: simple, 2: user-defined from routine UserYawCont, 3: user-defined from Simulink/Labview} (-):
   CALL ReadVar( UnIn, InputFile, InputFileData%YCMode, "YCMode", "Yaw control mode (-)", ErrStat2, ErrMsg2, UnEc)
      CALL CheckError( ErrStat2, ErrMsg2 )
      IF ( ErrStat >= AbortErrLev ) RETURN

      ! TYCOn - Time to enable active yaw control [unused when YCMode=0] (s):
   CALL ReadVar( UnIn, InputFile, InputFileData%TYCOn, "TYCOn", "Time to enable active yaw control [unused when YCMode=0] (s)", ErrStat2, ErrMsg2, UnEc)
      CALL CheckError( ErrStat2, ErrMsg2 )
      IF ( ErrStat >= AbortErrLev ) RETURN

      ! YawNeut - Neutral yaw position--yaw spring force is zero at this yaw (deg) (read from file in degrees and converted to radians here):
   CALL ReadVar( UnIn, InputFile, InputFileData%YawNeut, "YawNeut", "Neutral yaw position--yaw spring force is zero at this yaw (deg)", ErrStat2, ErrMsg2, UnEc)
      CALL CheckError( ErrStat2, ErrMsg2 )
      IF ( ErrStat >= AbortErrLev ) RETURN
   InputFileData%YawNeut = InputFileData%YawNeut*D2R

      ! YawSpr - Nacelle-yaw spring constant (N-m/rad):
   CALL ReadVar( UnIn, InputFile, InputFileData%YawSpr, "YawSpr", "Nacelle-yaw spring constant (N-m/rad)", ErrStat2, ErrMsg2, UnEc)
      CALL CheckError( ErrStat2, ErrMsg2 )
      IF ( ErrStat >= AbortErrLev ) RETURN

      ! YawDamp - Nacelle-yaw constant (N-m/(rad/s)):
   CALL ReadVar( UnIn, InputFile, InputFileData%YawDamp, "YawDamp", "Nacelle-yaw constant (N-m/(rad/s))", ErrStat2, ErrMsg2, UnEc)
      CALL CheckError( ErrStat2, ErrMsg2 )
      IF ( ErrStat >= AbortErrLev ) RETURN      
      
      ! TYawManS - Time to start override yaw maneuver and end standard yaw control (s):
   CALL ReadVar( UnIn, InputFile, InputFileData%TYawManS, "TYawManS", "Time to start override yaw maneuver and end standard yaw control (s)", ErrStat2, ErrMsg2, UnEc)
      CALL CheckError( ErrStat2, ErrMsg2 )
      IF ( ErrStat >= AbortErrLev ) RETURN

      ! YawManRat - Yaw maneuver rate (in absolute value) (deg/s) (read in degrees/second and converted to radians/second here):
   CALL ReadVar( UnIn, InputFile, InputFileData%YawManRat, "YawManRat", "Yaw maneuver rate (in absolute value) (deg/s)", ErrStat2, ErrMsg2, UnEc)
      CALL CheckError( ErrStat2, ErrMsg2 )
      IF ( ErrStat >= AbortErrLev ) RETURN
   InputFileData%YawManRat = InputFileData%YawManRat*D2R

      ! NacYawF - Final yaw angle for override yaw maneuvers (deg) (read from file in degrees and converted to radians here):
   CALL ReadVar( UnIn, InputFile, InputFileData%NacYawF, "NacYawF", "Final yaw angle for override yaw maneuvers (deg)", ErrStat2, ErrMsg2, UnEc)
      CALL CheckError( ErrStat2, ErrMsg2 )
      IF ( ErrStat >= AbortErrLev ) RETURN
   InputFileData%NacYawF = InputFileData%NacYawF*D2R
      
   !---------------------- BLADED INTERFACE ----------------------------------------         
   CALL ReadCom( UnIn, InputFile, 'Section Header: Bladed Interface', ErrStat2, ErrMsg2, UnEc )
      CALL CheckError( ErrStat2, ErrMsg2 )
      IF ( ErrStat >= AbortErrLev ) RETURN
                  
      ! DLL_FileName - Name of the Bladed DLL [used only with DLL Interface] (-):
   CALL ReadVar( UnIn, InputFile, InputFileData%DLL_FileName, "DLL_FileName", "Name/location of the external library {.dll [Windows]} in the Bladed-DLL format [used only with DLL Interface] (-)", ErrStat2, ErrMsg2, UnEc)
      CALL CheckError( ErrStat2, ErrMsg2 )
      IF ( ErrStat >= AbortErrLev ) RETURN
   IF ( PathIsRelative( InputFileData%DLL_FileName ) ) InputFileData%DLL_FileName = TRIM(PriPath)//TRIM(InputFileData%DLL_FileName)
      
      
      ! NacYaw_North - Reference yaw angle of the nacelle when the upwind end points due North (deg) (read from file in degrees and converted to radians here):
   CALL ReadVar( UnIn, InputFile, InputFileData%NacYaw_North, "NacYaw_North", "Reference yaw angle of the nacelle when the upwind end points due North (deg)", ErrStat2, ErrMsg2, UnEc)
      CALL CheckError( ErrStat2, ErrMsg2 )
      IF ( ErrStat >= AbortErrLev ) RETURN
   InputFileData%NacYaw_North = InputFileData%NacYaw_North*D2R

      ! Ptch_Cntrl - Record 28: Use individual pitch control {0: collective pitch; 1: individual pitch control} [used only with DLL Interface] (-):
   CALL ReadVar( UnIn, InputFile, InputFileData%Ptch_Cntrl, "Ptch_Cntrl", "Record 28: Use individual pitch control {0: collective pitch; 1: individual pitch control} [used only with DLL Interface] (-)", ErrStat2, ErrMsg2, UnEc)
      CALL CheckError( ErrStat2, ErrMsg2 )
      IF ( ErrStat >= AbortErrLev ) RETURN

      ! Ptch_SetPnt - Record  5: Below-rated pitch angle set-point [used only with DLL Interface] (deg) (read from file in degrees and converted to radians here):
   CALL ReadVar( UnIn, InputFile, InputFileData%Ptch_SetPnt, "Ptch_SetPnt", "Record  5: Below-rated pitch angle set-point [used only with DLL Interface] (deg)", ErrStat2, ErrMsg2, UnEc)
      CALL CheckError( ErrStat2, ErrMsg2 )
      IF ( ErrStat >= AbortErrLev ) RETURN
   InputFileData%Ptch_SetPnt = InputFileData%Ptch_SetPnt*D2R

      ! Ptch_Min - Record  6: Minimum pitch angle [used only with DLL Interface] (deg) (read from file in degrees and converted to radians here):
   CALL ReadVar( UnIn, InputFile, InputFileData%Ptch_Min, "Ptch_Min", "Record  6: Minimum pitch angle [used only with DLL Interface] (deg)", ErrStat2, ErrMsg2, UnEc)
      CALL CheckError( ErrStat2, ErrMsg2 )
      IF ( ErrStat >= AbortErrLev ) RETURN
   InputFileData%Ptch_Min = InputFileData%Ptch_Min*D2R

      ! Ptch_Max - Record  7: Maximum pitch angle [used only with DLL Interface] (deg) (read from file in degrees and converted to radians here):
   CALL ReadVar( UnIn, InputFile, InputFileData%Ptch_Max, "Ptch_Max", "Record  7: Maximum pitch angle [used only with DLL Interface] (deg)", ErrStat2, ErrMsg2, UnEc)
      CALL CheckError( ErrStat2, ErrMsg2 )
      IF ( ErrStat >= AbortErrLev ) RETURN
   InputFileData%Ptch_Max = InputFileData%Ptch_Max*D2R

      ! PtchRate_Min - Record  8: Minimum pitch rate (most negative value allowed) [used only with DLL Interface] (deg/s) (read from file in deg/s and converted to rad/s here):
   CALL ReadVar( UnIn, InputFile, InputFileData%PtchRate_Min, "PtchRate_Min", "Record  8: Minimum pitch rate (most negative value allowed) [used only with DLL Interface] (deg/s)", ErrStat2, ErrMsg2, UnEc)
      CALL CheckError( ErrStat2, ErrMsg2 )
      IF ( ErrStat >= AbortErrLev ) RETURN
   InputFileData%PtchRate_Min = InputFileData%PtchRate_Min*D2R

      ! PtchRate_Max - Record  9: Maximum pitch rate [used only with DLL Interface] (deg/s) (read from file in deg/s and converted to rad/s here):
   CALL ReadVar( UnIn, InputFile, InputFileData%PtchRate_Max, "PtchRate_Max", "Record  9: Maximum pitch rate [used only with DLL Interface] (deg/s)", ErrStat2, ErrMsg2, UnEc)
      CALL CheckError( ErrStat2, ErrMsg2 )
      IF ( ErrStat >= AbortErrLev ) RETURN
   InputFileData%PtchRate_Max = InputFileData%PtchRate_Max*D2R

      ! Gain_OM - Record 16: Optimal mode gain [used only with DLL Interface] (Nm/(rad/s)^2):
   CALL ReadVar( UnIn, InputFile, InputFileData%Gain_OM, "Gain_OM", "Record 16: Optimal mode gain [used only with DLL Interface] (Nm/(rad/s)^2)", ErrStat2, ErrMsg2, UnEc)
      CALL CheckError( ErrStat2, ErrMsg2 )
      IF ( ErrStat >= AbortErrLev ) RETURN

      ! GenSpd_MinOM - Record 17: Minimum generator speed [used only with DLL Interface] (rpm) (read from file in rpm and converted to rad/s here):
   CALL ReadVar( UnIn, InputFile, InputFileData%GenSpd_MinOM, "GenSpd_MinOM", "Record 17: Minimum generator speed [used only with DLL Interface] (rpm)", ErrStat2, ErrMsg2, UnEc)
      CALL CheckError( ErrStat2, ErrMsg2 )
      IF ( ErrStat >= AbortErrLev ) RETURN
   InputFileData%GenSpd_MinOM = InputFileData%GenSpd_MinOM*RPM2RPS

      ! GenSpd_MaxOM - Record 18: Optimal mode maximum speed [used only with DLL Interface] (rpm) (read from file in rpm and converted to rad/s here):
   CALL ReadVar( UnIn, InputFile, InputFileData%GenSpd_MaxOM, "GenSpd_MaxOM", "Record 18: Optimal mode maximum speed [used only with DLL Interface] (rpm)", ErrStat2, ErrMsg2, UnEc)
      CALL CheckError( ErrStat2, ErrMsg2 )
      IF ( ErrStat >= AbortErrLev ) RETURN
   InputFileData%GenSpd_MaxOM = InputFileData%GenSpd_MaxOM*RPM2RPS

      ! GenSpd_Dem - Record 19: Demanded generator speed above rated [used only with DLL Interface] (rpm) (read from file in rpm and converted to rad/s here):
   CALL ReadVar( UnIn, InputFile, InputFileData%GenSpd_Dem, "GenSpd_Dem", "Record 19: Demanded generator speed above rated [used only with DLL Interface] (rpm)", ErrStat2, ErrMsg2, UnEc)
      CALL CheckError( ErrStat2, ErrMsg2 )
      IF ( ErrStat >= AbortErrLev ) RETURN
   InputFileData%GenSpd_Dem = InputFileData%GenSpd_Dem*RPM2RPS

      ! GenTrq_Dem - Record 22: Demanded generator torque above rated [used only with DLL Interface] (Nm):
   CALL ReadVar( UnIn, InputFile, InputFileData%GenTrq_Dem, "GenTrq_Dem", "Record 22: Demanded generator torque above rated [used only with DLL Interface] (Nm)", ErrStat2, ErrMsg2, UnEc)
      CALL CheckError( ErrStat2, ErrMsg2 )
      IF ( ErrStat >= AbortErrLev ) RETURN

      ! GenPwr_Dem - Record 13: Demanded power [used only with DLL Interface] (W):
   CALL ReadVar( UnIn, InputFile, InputFileData%GenPwr_Dem, "GenPwr_Dem", "Record 13: Demanded power [used only with DLL Interface] (W)", ErrStat2, ErrMsg2, UnEc)
      CALL CheckError( ErrStat2, ErrMsg2 )
      IF ( ErrStat >= AbortErrLev ) RETURN

   !---------------------- BLADED INTERFACE TORQUE-SPEED LOOK-UP TABLE -------------         
   CALL ReadCom( UnIn, InputFile, 'Section Header: Bladed Interface Torque-Speed Look-Up Table', ErrStat2, ErrMsg2, UnEc )
      CALL CheckError( ErrStat2, ErrMsg2 )
      IF ( ErrStat >= AbortErrLev ) RETURN      

      ! DLL_NumTrq - Record 26: No. of points in torque-speed look-up table {0 = none and use the optimal mode PARAMETERs instead, nonzero = ignore the optimal mode PARAMETERs by setting Gain_OM (Record 16) to 0.0} (-):
   CALL ReadVar( UnIn, InputFile, InputFileData%DLL_NumTrq, "DLL_NumTrq", "Record 26: No. of points in torque-speed look-up table {0 = none and use the optimal mode PARAMETERs instead, nonzero = ignore the optimal mode PARAMETERs by setting Gain_OM (Record 16) to 0.0} (-)", ErrStat2, ErrMsg2, UnEc)
      CALL CheckError( ErrStat2, ErrMsg2 )
      IF ( ErrStat >= AbortErrLev ) RETURN

   IF ( InputFileData%DLL_NumTrq > 0 ) THEN
      CALL AllocAry( InputFileData%GenSpd_TLU,   InputFileData%DLL_NumTrq, 'GenSpd_TLU', ErrStat2, ErrMsg2 )
            CALL CheckError(ErrStat2,ErrMsg2)
            IF ( ErrStat >= AbortErrLev ) RETURN
      
      CALL AllocAry( InputFileData%GenTrq_TLU,   InputFileData%DLL_NumTrq, 'GenTrq_TLU',ErrStat2, ErrMsg2 )
            CALL CheckError(ErrStat2,ErrMsg2)
            IF ( ErrStat >= AbortErrLev ) RETURN      
   END IF
      
   CALL ReadCom( UnIn, InputFile, 'Table Header: Bladed Interface Torque-Speed Look-Up Table', ErrStat2, ErrMsg2, UnEc )
      CALL CheckError( ErrStat2, ErrMsg2 )
      IF ( ErrStat >= AbortErrLev ) RETURN      
      
   CALL ReadCom( UnIn, InputFile, 'Table Units: Bladed Interface Torque-Speed Look-Up Table', ErrStat2, ErrMsg2, UnEc )
      CALL CheckError( ErrStat2, ErrMsg2 )
      IF ( ErrStat >= AbortErrLev ) RETURN      
            
   DO I=1,InputFileData%DLL_NumTrq     
      
      CALL ReadAry( UnIn, InputFile, TmpRAry, 2_IntKi, 'Line'//TRIM(Num2LStr(I)), 'Bladed Interface Torque-Speed Look-Up Table', &
                    ErrStat2, ErrMsg2, UnEc )
         CALL CheckError( ErrStat2, ErrMsg2 )
         IF ( ErrStat >= AbortErrLev ) RETURN

      InputFileData%GenSpd_TLU( I) = TmpRAry(1)*RPM2RPS  ! GenSpd_TLU - Records R:2:R+2*DLL_NumTrq-2: Generator speed values in look-up table (rpm) (read from file in rpm and converted to rad/s here)
      InputFileData%GenTrq_TLU(I)  = TmpRAry(2)          ! GenTrq_TLU - Records R+1:2:R+2*DLL_NumTrq-1: Generator torque values in look-up table (Nm)
                   
   END DO
                     
   
   !---------------------- OUTPUT --------------------------------------------------         
   CALL ReadCom( UnIn, InputFile, 'Section Header: Output', ErrStat2, ErrMsg2, UnEc )
      CALL CheckError( ErrStat2, ErrMsg2 )
      IF ( ErrStat >= AbortErrLev ) RETURN

      ! SumPrint - Print summary data to <RootName>.sum (flag):
   CALL ReadVar( UnIn, InputFile, InputFileData%SumPrint, "SumPrint", "Print summary data to <RootName>.sum (flag)", ErrStat2, ErrMsg2, UnEc)
      CALL CheckError( ErrStat2, ErrMsg2 )
      IF ( ErrStat >= AbortErrLev ) RETURN

      ! OutFile - Switch to determine where output will be placed: (1: in module output file only; 2: in glue code output file only; 3: both) (-):
   CALL ReadVar( UnIn, InputFile, InputFileData%OutFile, "OutFile", "Switch to determine where output will be placed: {1: in module output file only; 2: in glue code output file only; 3: both} (-)", ErrStat2, ErrMsg2, UnEc)
      CALL CheckError( ErrStat2, ErrMsg2 )
      IF ( ErrStat >= AbortErrLev ) RETURN

   !   ! OutFileFmt - Format for module tabular (time-marching) output: (1: text file [<RootName>.out], 2: binary file [<RootName>.outb], 3: both):
   !CALL ReadVar( UnIn, InputFile, InputFileData%OutFileFmt, "OutFileFmt", "Format for module tabular (time-marching) output: (1: text file [<RootName>.out], 2: binary file [<RootName>.outb], 3: both)", ErrStat2, ErrMsg2, UnEc)
   !   CALL CheckError( ErrStat2, ErrMsg2 )
   !   IF ( ErrStat >= AbortErrLev ) RETURN      
      
      ! TabDelim - Flag to cause tab-delimited text output (delimited by space otherwise) (flag):
   CALL ReadVar( UnIn, InputFile, InputFileData%TabDelim, "TabDelim", "Flag to cause tab-delimited text output (delimited by space otherwise) (flag)", ErrStat2, ErrMsg2, UnEc)
      CALL CheckError( ErrStat2, ErrMsg2 )
      IF ( ErrStat >= AbortErrLev ) RETURN

      ! OutFmt - Format used for module's text tabult output (except time); resulting field should be 10 characters (-):
   CALL ReadVar( UnIn, InputFile, InputFileData%OutFmt, "OutFmt", "Format used for module's text tabular output (except time); resulting field should be 10 characters (-)", ErrStat2, ErrMsg2, UnEc)
      CALL CheckError( ErrStat2, ErrMsg2 )
      IF ( ErrStat >= AbortErrLev ) RETURN

      ! Tstart - Time to start module's tabular output (seconds):
   CALL ReadVar( UnIn, InputFile, InputFileData%Tstart, "Tstart", "Time to start module's tabular output (seconds)", ErrStat2, ErrMsg2, UnEc)
      CALL CheckError( ErrStat2, ErrMsg2 )
      IF ( ErrStat >= AbortErrLev ) RETURN
   !
   !   ! DecFact - Decimation factor for module's tabular output (1=output every step) (-):
   !CALL ReadVar( UnIn, InputFile, InputFileData%DecFact, "DecFact", "Decimation factor for module's tabular output (1=output every step) (-)", ErrStat2, ErrMsg2, UnEc)
   !   CALL CheckError( ErrStat2, ErrMsg2 )
   !   IF ( ErrStat >= AbortErrLev ) RETURN

   !---------------------- OUTLIST  --------------------------------------------
      CALL ReadCom( UnIn, InputFile, 'Section Header: OutList', ErrStat2, ErrMsg2, UnEc )
      CALL CheckError( ErrStat2, ErrMsg2 )
      IF ( ErrStat >= AbortErrLev ) RETURN

      ! OutList - List of user-requested output channels (-):
   CALL ReadOutputList ( UnIn, InputFile, InputFileData%OutList, InputFileData%NumOuts, 'OutList', "List of user-requested output channels", ErrStat2, ErrMsg2, UnEc  )     ! Routine in NWTC Subroutine Library
      CALL CheckError( ErrStat2, ErrMsg2 )
      IF ( ErrStat >= AbortErrLev ) RETURN     
      
   !---------------------- END OF FILE -----------------------------------------
      
   CLOSE ( UnIn )
   RETURN


CONTAINS
   !...............................................................................................................................
   SUBROUTINE CheckError(ErrID,Msg)
   ! This subroutine sets the error message and level
   !...............................................................................................................................

         ! Passed arguments
      INTEGER(IntKi), INTENT(IN) :: ErrID       ! The error identifier (ErrStat)
      CHARACTER(*),   INTENT(IN) :: Msg         ! The error message (ErrMsg)


      !............................................................................................................................
      ! Set error status/message;
      !............................................................................................................................

      IF ( ErrID /= ErrID_None ) THEN

         IF (ErrStat /= ErrID_None) ErrMsg = TRIM(ErrMsg)//NewLine
         ErrMsg = TRIM(ErrMsg)//'ReadPrimaryFile:'//TRIM(Msg)
         ErrStat = MAX(ErrStat, ErrID)

         !.........................................................................................................................
         ! Clean up if we're going to return on error: close file, deallocate local arrays
         !.........................................................................................................................
         IF ( ErrStat >= AbortErrLev ) THEN
            CLOSE( UnIn )
!            IF ( UnEc > 0 ) CLOSE ( UnEc )
         END IF

      END IF


   END SUBROUTINE CheckError
   !...............................................................................................................................
END SUBROUTINE ReadPrimaryFile      
!----------------------------------------------------------------------------------------------------------------------------------
SUBROUTINE ValidatePrimaryData( InputFileData, NumBl, ErrStat, ErrMsg )
! This routine validates the inputs from the primary input file.
!..................................................................................................................................
      
      ! Passed variables:

   TYPE(SrvD_InputFile),     INTENT(IN)     :: InputFileData                       ! All the data in the ServoDyn input file
   INTEGER(IntKi),           INTENT(IN)     :: NumBl                               ! Number of blades
   INTEGER(IntKi),           INTENT(OUT)    :: ErrStat                             ! Error status
   CHARACTER(*),             INTENT(OUT)    :: ErrMsg                              ! Error message

   
      ! local variables
   INTEGER(IntKi)                           :: K                                   ! Blade number
   
   
   
   CALL Pitch_ValidateData()
   CALL Yaw_ValidateData()
   CALL TipBrake_ValidateData()
   
   
   
      ! Some special checks based on whether inputs will come from external source (e.g., Simulink, LabVIEW)
   IF ( .NOT. Cmpl4SFun .AND. .NOT. Cmpl4LV ) THEN
      
      IF ( InputFileData%VSContrl == 3 )  THEN
         CALL SetErrors( ErrID_Fatal, 'VSContrl can only equal 3 when ServoDyn is interfaced with Simulink or Labview.'// &
                '  Set VSContrl to 0, 1, or 2 or interface ServoDyn with Simulink or Labview.' )
      END IF
         
   ELSE
      
      IF ( InputFileData%VSContrl == 3_IntKi  ) THEN  !we don't know TMax anymore...
         
         IF ( .NOT. InputFileData%GenTiStr .OR. .NOT. EqualRealNos( InputFileData%TimGenOn, 0.0_DbKi ) )  THEN
            CALL SetErrors( ErrID_Fatal, 'Variable-speed, generator torque control must be enabled at time zero when '//&
               'implemented in Simulink or Labview. Set GenTiStr to True and TimGenOn to 0.0, set VSContrl to 0, 1, or 2,'//&
               ' or use the standard version of ServoDyn.' )
         END IF
         
!         IF ( .NOT. InputFileData%GenTiStp .OR. InputFileData%TimGenOf <= TMax ) THEN   !BJJ SET p%TimGenOf = HUGE() when Cmpl4SFun .OR. Cmpl4LV
         IF ( .NOT. InputFileData%GenTiStp ) THEN
            CALL SetErrors( ErrID_Fatal, 'Variable-speed, generator torque control must not be disabled during simulation'//&
                ' when implemented in Simulink or Labview. Set GenTiStp to True and TimGenOf > TMax, '//                    &
                ' set VSContrl to 0, 1, or 2, or use the standard version of ServoDyn.'   )            
         END IF         
         
      END IF         
           
      !IF ( Cmpl4SFun .AND. ( InputFileData%THSSBrDp <= TMax ) )  THEN  !BJJ SET p%THSSBrDp = HUGE() when Cmpl4SFun
      !   CALL SetErrors( ErrID_Fatal, 'A high-speed shaft brake shutdown event can''t be initiated when ServoDyn is '// &
      !                'interfaced  with Simulink. Set THSSBrDp > TMax or use the standard version of ServoDyn.'        )
      !ENDIF
      !
   END IF
   
   IF ( .NOT. Cmpl4LV .AND. InputFileData%HSSBrMode == 3_IntKi )  THEN
      CALL SetErrors( ErrID_Fatal, 'HSSBrMode can be 3 only when when implemented in Labview.' )
   ENDIF      

         
   
      ! checks for generator and torque control:           
   IF ( ( InputFileData%VSContrl < 0_IntKi ) .OR. ( InputFileData%VSContrl > 3_IntKi ) )  THEN
      IF ( InputFileData%VSContrl /= ControlMode_DLL )  &
      CALL SetErrors( ErrID_Fatal, 'VSContrl must be either 0, 1, 2, or 3 (or 5).' )
   ENDIF
   
   IF ( InputFileData%SpdGenOn < 0.0_ReKi ) CALL SetErrors( ErrID_Fatal, 'SpdGenOn must not be negative.' )
   IF ( InputFileData%TimGenOn < 0.0_DbKi ) CALL SetErrors( ErrID_Fatal, 'TimGenOn must not be negative.' )
   IF ( InputFileData%TimGenOf < 0.0_DbKi ) CALL SetErrors( ErrID_Fatal, 'TimGenOf must not be negative.' )
!   IF ( InputFileData%TimGenOf < InputFileData%TimGenOn ) CALL SetErrors( ErrID_Fatal, 'TimGenOf must not be before TimGenOn.')
   IF ( InputFileData%GenEff   < 0.0_ReKi  .OR.  InputFileData%GenEff > 1.0_ReKi )  THEN
      CALL SetErrors( ErrID_Fatal, 'GenEff must be in the range [0, 1] (i.e., [0, 100] percent)' )
   END IF
   
   
      ! checks for variable-speed torque control:           
   IF ( InputFileData%VSContrl == 1_IntKi ) THEN
      IF ( InputFileData%VS_RtGnSp <= 0.0_ReKi )  CALL SetErrors( ErrID_Fatal, 'VS_RtGnSp must be greater than zero.' )
      IF ( InputFileData%VS_RtTq   < 0.0_ReKi  )  CALL SetErrors( ErrID_Fatal, 'VS_RtTq must not be negative.' )
      IF ( InputFileData%VS_Rgn2K  < 0.0_ReKi  )  CALL SetErrors( ErrID_Fatal, 'VS_Rgn2K must not be negative.' )
      IF ( InputFileData%VS_Rgn2K*InputFileData%VS_RtGnSp**2 >  InputFileData%VS_RtTq )  &
         CALL SetErrors( ErrID_Fatal, 'VS_Rgn2K*VS_RtGnSp^2 must not be greater than VS_RtTq.' )
      IF ( InputFileData%VS_SlPc  <= 0.0_ReKi  )  CALL SetErrors( ErrID_Fatal, 'VS_SlPc must be greater than zero.' )
   END IF

      ! checks for generator models (VSControl == 0):           
   IF ( InputFileData%VSContrl == 0_IntKi ) THEN
      
      IF ( InputFileData%GenModel < 1_IntKi .OR. InputFileData%GenModel > 3_IntKi )  THEN
         CALL SetErrors( ErrID_Fatal, 'GenModel must be either 1, 2, or 3.' )
      ENDIF            
      
         ! checks for simple induction generator (VSControl=0 & GenModel=1):      
      IF ( InputFileData%GenModel == 1_IntKi ) THEN
         IF ( InputFileData%SIG_SlPc <= 0.0_ReKi )  CALL SetErrors( ErrID_Fatal, 'SIG_SlPc must be greater than zero.' )
         IF ( InputFileData%SIG_SySp <= 0.0_ReKi )  CALL SetErrors( ErrID_Fatal, 'SIG_SySp must be greater than zero.' )
         IF ( InputFileData%SIG_RtTq <= 0.0_ReKi )  CALL SetErrors( ErrID_Fatal, 'SIG_RtTq must be greater than zero.' )
         IF ( InputFileData%SIG_PORt <  1.0_ReKi )  CALL SetErrors( ErrID_Fatal, 'SIG_PORt must not be less than 1.' )
      END IF

         ! checks for Thevenin-equivalent induction generator (VSControl=0 & GenModel=2):      
      IF ( InputFileData%GenModel == 2_IntKi ) THEN
         IF ( InputFileData%TEC_Freq <= 0.0_ReKi ) CALL SetErrors( ErrID_Fatal, 'TEC_Freq must be greater than zero.' )
         IF ( InputFileData%TEC_NPol <= 0_IntKi .OR. MOD( InputFileData%TEC_NPol, 2_IntKi ) /= 0_IntKi ) &
                                     CALL SetErrors( ErrID_Fatal, 'TEC_NPol must be an even number greater than zero.' )
         IF ( InputFileData%TEC_SRes <= 0.0_ReKi ) CALL SetErrors( ErrID_Fatal, 'TEC_SRes must be greater than zero.' )
         IF ( InputFileData%TEC_RRes <= 0.0_ReKi ) CALL SetErrors( ErrID_Fatal, 'TEC_RRes must be greater than zero.' )
         IF ( InputFileData%TEC_VLL  <= 0.0_ReKi ) CALL SetErrors( ErrID_Fatal, 'TEC_VLL must be greater than zero.'  )
         IF ( InputFileData%TEC_SLR  <= 0.0_ReKi ) CALL SetErrors( ErrID_Fatal, 'TEC_SLR must be greater than zero.'  )
         IF ( InputFileData%TEC_RLR  <= 0.0_ReKi ) CALL SetErrors( ErrID_Fatal, 'TEC_RLR must be greater than zero.'  )
         IF ( InputFileData%TEC_MR   <= 0.0_ReKi ) CALL SetErrors( ErrID_Fatal, 'TEC_MR must be greater than zero.'   )
      END IF      
      
   END IF
   
      
      ! checks for high-speed shaft brake:       
   IF ( InputFileData%HSSBrMode < 1_IntKi .OR. InputFileData%HSSBrMode > 3_IntKi )  THEN
      IF ( InputFileData%HSSBrMode /= ControlMode_DLL ) &      
                                             CALL SetErrors( ErrID_Fatal, 'HSSBrMode must be 1, 2 or 3.' )
   END IF
   IF ( InputFileData%THSSBrDp < 0.0_DbKi )  CALL SetErrors( ErrID_Fatal, 'THSSBrDp must not be negative.' )
   IF ( InputFileData%HSSBrDT  < 0.0_ReKi )  CALL SetErrors( ErrID_Fatal, 'HSSBrDT must not be negative.'  )
   IF ( InputFileData%HSSBrTqF < 0.0_ReKi )  CALL SetErrors( ErrID_Fatal, 'HSSBrTqF must not be negative.' )

      
   RETURN
   
CONTAINS
   !-------------------------------------------------------------------------------------------------------------------------------
   SUBROUTINE Pitch_ValidateData( )
   ! This routine performs the checks on inputs for the pitch controller.
   !...............................................................................................................................
   
         ! Check that the requested pitch control modes are valid:
   
      IF ( .NOT. Cmpl4SFun .AND. .NOT. Cmpl4LV ) THEN
         
         IF ( InputFileData%PCMode == 2_IntKi )  THEN
            CALL SetErrors( ErrID_Fatal, 'PCMode can only equal 2 when ServoDyn is interfaced with Simulink or Labview.'// &
                      '  Set PCMode to 0 or 1 or interface ServoDyn with Simulink or Labview.' )          
         END IF
         
      ELSE
         
         IF ( InputFileData%PCMode == 2_IntKi .AND. .NOT. EqualRealNos( InputFileData%TPCOn, 0.0_DbKi ) )  THEN
            CALL SetErrors( ErrID_Fatal, 'Pitch control must be enabled at time zero when implemented in Simulink or Labview.'//&
                   '  Set TPCon to 0.0, set PCMode to 0 or 1, or use the standard version of ServoDyn.' )
         END IF           
         
      END IF
   
   
      IF ( ( InputFileData%PCMode < 0_IntKi ) .OR. ( InputFileData%PCMode > 2_IntKi ) )  THEN
         IF ( InputFileData%PCMode /= ControlMode_DLL )  &
         CALL SetErrors( ErrID_Fatal, 'PCMode must be 0, 1, or 2 (or 5).' )
      ENDIF
         

         ! Time that pitch control is enabled:
      
      IF ( InputFileData%TPCOn < 0.0_DbKi )  THEN
         CALL SetErrors( ErrID_Fatal, 'TPCOn must not be negative.' )
      ENDIF

         ! Make sure the number of blades in the simulation doesn't exceed 3:

      IF ( NumBl > SIZE(InputFileData%TPitManS,1) ) CALL SetErrors( ErrID_Fatal, 'Number of blades exceeds input values.')
      
         ! Check the pitch-maneuver start times and rates:
         
      DO K=1,MIN(NumBl,SIZE(InputFileData%TPitManS))
      
         IF ( InputFileData%TPitManS(K) < 0.0_DbKi ) &
            CALL SetErrors( ErrID_Fatal, 'TPitManS('//TRIM( Num2LStr( K ) )//') must not be negative.' )         
         IF ( EqualRealNos( InputFileData%PitManRat(K), 0.0_ReKi ) ) &
            CALL SetErrors( ErrID_Fatal, 'PitManRat('//TRIM( Num2LStr(K) )//') must not be 0.' )

      ENDDO ! K   
      
      
!??? IF ( ANY( p%BlPitchInit <= -pi ) .OR. ANY( p%BlPitchInit > pi ) )  THEN
!      CALL SetErrors( ErrID_Fatal, 'BlPitchInit('//TRIM( Num2LStr( K ) )//') must be in the range (-pi,pi] radians (i.e., (-180,180] degrees).' )
!   
               
   END SUBROUTINE Pitch_ValidateData
   !-------------------------------------------------------------------------------------------------------------------------------
   SUBROUTINE Yaw_ValidateData( )
   ! This routine performs the checks on inputs for the yaw controller.
   !...............................................................................................................................
   
            ! checks for yaw control mode:
      IF ( ( InputFileData%YCMode < 0_IntKi ) .OR. ( InputFileData%YCMode > 2_IntKi ) )  THEN
         IF ( InputFileData%YCMode /= ControlMode_DLL )  &
         CALL SetErrors( ErrID_Fatal, 'YCMode must be 0, 1, or 2 (or 5).' )
      ENDIF

            
         ! Some special checks based on whether inputs will come from external source (e.g., Simulink, LabVIEW)            
      IF ( .NOT. Cmpl4SFun .AND. .NOT. Cmpl4LV ) THEN
         
         IF ( InputFileData%YCMode == 2_IntKi )  THEN
            CALL SetErrors( ErrID_Fatal, 'YCMode can only equal 2 when ServoDyn is interfaced with Simulink or Labview.'// &
                      '  Set YCMode to 0 or 1 or interface ServoDyn with Simulink or Labview.' )          
         END IF
   
      ELSE
      
         IF ( InputFileData%YCMode == 2_IntKi .AND. .NOT. EqualRealNos( InputFileData%TYCOn, 0.0_DbKi ) )  THEN
            CALL SetErrors( ErrID_Fatal, 'Yaw control must be enabled at time zero when implemented in Simulink or Labview.'//&
                   '  Set TYCon to 0.0, set YCMode to 0 or 1, or use the standard version of ServoDyn.' )
         END IF
      END IF
            

         ! Check the start time to enable yaw control mode:
      
      IF ( InputFileData%TYCOn < 0.0_DbKi )  THEN
         CALL SetErrors( ErrID_Fatal, 'TYCOn must not be negative.' )
      ENDIF
   
   
         ! Check the nacelle-yaw-maneuver start times and rates:
      IF ( InputFileData%TYawManS < 0.0_DbKi )  CALL SetErrors( ErrID_Fatal, 'TYawManS must not be negative.' )
      IF ( EqualRealNos( InputFileData%YawManRat, 0.0_ReKi ) ) CALL SetErrors( ErrID_Fatal, 'YawManRat must not be 0.' )
   !   IF ( InputFileData%TYawManE < InputFileData%TYawManS ) CALL SetErrors( ErrID_Fatal, 'TYawManE must not be less than TYawManS.')


         ! Check the nacelle-yaw spring and damping constants:

      IF ( InputFileData%YawSpr  < 0.0_ReKi )  CALL SetErrors( ErrID_Fatal, 'YawSpr must not be negative.' )
      IF ( InputFileData%YawDamp < 0.0_ReKi )  CALL SetErrors( ErrID_Fatal, 'YawDamp must not be negative.' )
   
         ! Check the neutral position:
      IF ( InputFileData%YawNeut <= -pi  .OR.  InputFileData%YawNeut > pi )  &
         CALL SetErrors( ErrID_Fatal, 'YawNeut must be in the range (-pi, pi] radians (i.e., (-180,180] degrees).' )
   
   
   END SUBROUTINE Yaw_ValidateData
   !-------------------------------------------------------------------------------------------------------------------------------
   SUBROUTINE TipBrake_ValidateData( )
   ! This routine performs the checks on inputs for the tip brakes.
   !...............................................................................................................................
   
      !IF ( TBDrConN < 0.0 )  CALL ProgAbort ( ' TBDrConN must not be negative.' )
      !IF ( TBDrConD < TBDrConN )  CALL ProgAbort( ' TBDrConD must not be less than TBDrConN.' )
      !IF ( p%TpBrDT < 0.0_DbKi )  CALL ProgAbort ( ' TpBrDT must not be negative.' )
      
   
      !DO K=1,MIN(NumBl,SIZE(InputFileData%TTpBrDp))
      !   IF ( InputFileData%TTpBrDp(K)  < 0.0_DbKi ) &
      !      CALL SetErrors( ErrID_Fatal, 'TTpBrDp(' //TRIM( Num2LStr( K ) )//') must not be negative.' )
      !   IF ( InputFileData%TBDepISp(K) < 0.0_DbKi ) &
      !      CALL SetErrors( ErrID_Fatal, 'TBDepISp('//TRIM( Num2LStr( K ) )//') must not be negative.' )      
      !ENDDO ! K   
   
   
   END SUBROUTINE TipBrake_ValidateData
   !-------------------------------------------------------------------------------------------------------------------------------
   SUBROUTINE SetErrors( ErrStat3, ErrMsg3 )
   ! This routine sets the error message and flag when an error has occurred.
   !...............................................................................................................................
   INTEGER(IntKi), INTENT(IN) :: ErrStat3     ! Error status for this error
   CHARACTER(*),   INTENT(IN) :: ErrMsg3      ! Error message for this error

      ErrStat = MAX( ErrStat, ErrStat3 )
      IF ( LEN_TRIM(ErrMsg) > 0 ) ErrMsg = TRIM(ErrMsg)//NewLine
      ErrMsg  = TRIM(ErrMsg)//TRIM(ErrMsg3)

   END SUBROUTINE SetErrors
   !-------------------------------------------------------------------------------------------------------------------------------      
END SUBROUTINE ValidatePrimaryData
!----------------------------------------------------------------------------------------------------------------------------------
SUBROUTINE SrvD_SetParameters( InputFileData, p, ErrStat, ErrMsg )
! This subroutine sets the parameters, based on the data stored in InputFileData
!..................................................................................................................................

   TYPE(SrvD_InputFile),     INTENT(IN)       :: InputFileData  ! Data stored in the module's input file
   TYPE(SrvD_ParameterType), INTENT(INOUT)    :: p              ! The module's parameter data
   INTEGER(IntKi),           INTENT(OUT)      :: ErrStat        ! The error status code
   CHARACTER(*),             INTENT(OUT)      :: ErrMsg         ! The error message, if an error occurred

      ! Local variables
   REAL(ReKi)                                 :: ComDenom       ! Common denominator of variables used in the TEC model
   REAL(ReKi)                                 :: SIG_RtSp       ! Rated speed
   REAL(ReKi)                                 :: TEC_K1         ! K1 term for Thevenin-equivalent circuit
   REAL(ReKi)                                 :: TEC_K2         ! K2 term for Thevenin-equivalent circuit
   
   INTEGER(IntKi)                             :: K              ! Loop counter (for blades)
   INTEGER(IntKi)                             :: ErrStat2       ! Temporary error ID   
   CHARACTER(LEN(ErrMsg))                     :: ErrMsg2        ! Temporary message describing error


   
      ! Initialize variables

   ErrStat = ErrID_None
   ErrMsg  = ''


   p%DT = InputFileData%DT
   
      !.............................................
      ! Pitch control parameters
      !.............................................
      
   p%PCMode   = InputFileData%PCMode
   p%TPCOn    = InputFileData%TPCOn      

   CALL AllocAry( p%TPitManS, p%NumBl, 'TPitManS', ErrStat, ErrMsg )
   IF ( ErrStat /= ErrID_None ) RETURN
   p%TPitManS = InputFileData%TPitManS(1:p%NumBl)
   
   CALL AllocAry( p%BlPitchF, p%NumBl, 'BlPitchF', ErrStat, ErrMsg )
   IF ( ErrStat /= ErrID_None ) RETURN
   p%BlPitchF = InputFileData%BlPitchF(1:p%NumBl)
   
   ! note that PitManRat is stored in OtherStates

      !.............................................
      ! Set generator and torque control parameters:
      !.............................................
   p%VSContrl  = InputFileData%VSContrl
   p%GenModel  = InputFileData%GenModel
   p%GenEff    = InputFileData%GenEff
   p%GenTiStr  = InputFileData%GenTiStr
   p%GenTiStp  = InputFileData%GenTiStp
   p%SpdGenOn  = InputFileData%SpdGenOn
   p%TimGenOn  = InputFileData%TimGenOn
         
   
   IF ( Cmpl4SFun .OR. Cmpl4LV ) THEN
      p%TimGenOf = HUGE( p%TimGenOf ) 
      CALL CheckError( ErrID_Info, 'TimGenOf is ignored when compiled for LabVIEW or Simulink.' )
   ELSE
      p%TimGenOf  = InputFileData%TimGenOf
   END IF
   
   
   p%THSSBrFl  = InputFileData%THSSBrDp + InputFileData%HSSBrDT   ! Time at which shaft brake is fully deployed
   
   SELECT CASE ( p%VSContrl )      
   CASE ( 0_IntKi )  ! None
      
      IF ( p%GenModel == 1_IntKi )     THEN   ! Simple induction generator

           SIG_RtSp  = InputFileData%SIG_SySp*( 1.0 + InputFileData%SIG_SlPc )                                 ! Rated speed
         p%SIG_POSl  = InputFileData%SIG_PORt*( SIG_RtSp - InputFileData%SIG_SySp )                                 ! Pullout slip
         p%SIG_POTq  = InputFileData%SIG_RtTq*InputFileData%SIG_PORt                                                ! Pullout torque
         p%SIG_Slop  = InputFileData%SIG_RtTq/( SIG_RtSp - InputFileData%SIG_SySp )                                 ! SIG torque/speed slope

         p%SIG_SySp = InputFileData%SIG_SySp
      ELSEIF ( p%GenModel == 2_IntKi )  THEN   ! Thevenin-equivalent induction generator

         ComDenom    = InputFileData%TEC_SRes**2 + ( InputFileData%TEC_SLR + InputFileData%TEC_MR )**2   ! common denominator used in many of the following equations
         
         p%TEC_Re1   = InputFileData%TEC_SRes*( InputFileData%TEC_MR**2 )/ComDenom                       ! Thevenin's equivalent stator resistance (ohms)
         p%TEC_Xe1   = InputFileData%TEC_MR*( InputFileData%TEC_SRes**2 + InputFileData%TEC_SLR* &
                                    ( InputFileData%TEC_SLR + InputFileData%TEC_MR) )/ComDenom           ! Thevenin's equivalent stator leakage reactance (ohms)
         p%TEC_V1a   = InputFileData%TEC_MR*InputFileData%TEC_VLL/SQRT( 3.0*ComDenom )                   ! Thevenin equivalent source voltage
         p%TEC_SySp  = 4.0*Pi*InputFileData%TEC_Freq/InputFileData%TEC_NPol                              ! Thevenin equivalent synchronous speed
           TEC_K1    = ( p%TEC_Xe1 + InputFileData%TEC_RLR )**2                                          ! Thevenin equivalent K1 term
           TEC_K2    = ( InputFileData%TEC_MR**2 )/ComDenom                                              ! Thevenin equivalent K2 term
         p%TEC_A0    = InputFileData%TEC_RRes*TEC_K2/p%TEC_SySp                                          ! Thevenin equivalent A0 term
         p%TEC_C0    = InputFileData%TEC_RRes**2                                                         ! Thevenin equivalent C0 term
         p%TEC_C1    = -2.0*p%TEC_Re1*InputFileData%TEC_RRes                                             ! Thevenin equivalent C1 term
         p%TEC_C2    = p%TEC_Re1**2 + TEC_K1                                                             ! Thevenin equivalent C2 term

         p%TEC_MR    = InputFileData%TEC_MR
         p%TEC_RLR   = InputFileData%TEC_RLR
         p%TEC_RRes  = InputFileData%TEC_RRes
         p%TEC_SRes  = InputFileData%TEC_SRes
         p%TEC_VLL   = InputFileData%TEC_VLL

      ENDIF
         
      
   CASE ( 1_IntKi ) ! Simple variable-speed control
      
      p%VS_SySp   = InputFileData%VS_RtGnSp/( 1.0 +  InputFileData%VS_SlPc )                                            ! Synchronous speed of region 2 1/2 induction generator.
      IF ( InputFileData%VS_SlPc < SQRT(EPSILON(InputFileData%VS_SlPc) ) ) THEN                                         ! We don't have a region 2 so we'll use VS_TrGnSp = VS_RtGnSp
         p%VS_Slope = 9999.9
         p%VS_TrGnSp = InputFileData%VS_RtGnSp
      ELSE
         p%VS_Slope  = InputFileData%VS_RtTq  /( InputFileData%VS_RtGnSp - p%VS_SySp )                                  ! Torque/speed slope of region 2 1/2 induction generator.
         IF ( ABS(InputFileData%VS_Rgn2K) < EPSILON(InputFileData%VS_SlPc) )  THEN  ! .TRUE. if the Region 2 torque is flat, and thus, the denominator in the ELSE condition is zero
            p%VS_TrGnSp = p%VS_SySp                                                                                     ! Transitional generator speed between regions 2 and 2 1/2.
         ELSE                          ! .TRUE. if the Region 2 torque is quadratic with speed
            p%VS_TrGnSp = ( p%VS_Slope - SQRT( p%VS_Slope*( p%VS_Slope - 4.0*InputFileData%VS_Rgn2K*p%VS_SySp ) ) ) &
                              / ( 2.0*InputFileData%VS_Rgn2K )                                                          ! Transitional generator speed between regions 2 and 2 1/2.
         ENDIF
      END IF
   
      p%VS_Rgn2K   = InputFileData%VS_Rgn2K
      p%VS_RtGnSp  = InputFileData%VS_RtGnSp
      p%VS_RtTq    = InputFileData%VS_RtTq
      
   END SELECT 
      
      !.............................................
      ! High-speed shaft brake parameters
      !.............................................   
   p%HSSBrMode = InputFileData%HSSBrMode
   IF ( Cmpl4SFun ) THEN
      p%THSSBrDp  = HUGE(p%THSSBrDp) ! Make sure this doesn't get shut off during simulation
      CALL CheckError( ErrID_Info, 'THSSBrDp is ignored in this version of ServoDyn.' )
      
!      CALL CheckError( ErrID_Info, 'THSSBrDp is ignored when compiled for Simulink.' )
   ELSE      
      p%THSSBrDp  = InputFileData%THSSBrDp
   END IF 
   p%HSSBrDT   = InputFileData%HSSBrDT
   p%HSSBrTqF  = InputFileData%HSSBrTqF
      
      !.............................................
      ! Nacelle-yaw control parameters
      !.............................................
   p%YCMode   = InputFileData%YCMode
   p%TYCOn    = InputFileData%TYCOn
   p%YawNeut  = InputFileData%YawNeut !bjj: this should be renamed...
   p%YawSpr   = InputFileData%YawSpr
   p%YawDamp  = InputFileData%YawDamp

   p%TYawManS = InputFileData%TYawManS   
   p%NacYawF  = InputFileData%NacYawF   
   ! noted: YawManRate is an OtherState
      
   
      !.............................................
      ! Determine if the BladedDLL should be called
      !.............................................
   
   IF ( p%PCMode    == ControlMode_DLL .OR. &
        p%YCMode    == ControlMode_DLL .OR. &        
        p%VSContrl  == ControlMode_DLL .OR. &
        p%HSSBrMode == ControlMode_DLL      ) THEN
      
      p%UseBladedInterface = .TRUE.   
      
   ELSE
      p%UseBladedInterface = .FALSE.   
   END IF
   
   
      !.............................................
      ! Parameters for file output
      !.............................................
   p%NumOuts = InputFileData%NumOuts
      
   CALL SetOutParam(InputFileData%OutList, p, ErrStat2, ErrMsg2 ) ! requires: p%NumOuts, p%NumBl; sets: p%OutParam.
      CALL CheckError(ErrStat2,ErrMsg2)
      IF (ErrStat >= AbortErrLev) RETURN  
      
   IF ( InputFileData%TabDelim ) THEN
      p%Delim = TAB
   ELSE
      p%Delim = ' '
   END IF           
             

   
CONTAINS
   !...............................................................................................................................
   SUBROUTINE CheckError(ErrID,Msg)
   ! This subroutine sets the error message and level
   !...............................................................................................................................

         ! Passed arguments
      INTEGER(IntKi), INTENT(IN) :: ErrID       ! The error identifier (ErrStat)
      CHARACTER(*),   INTENT(IN) :: Msg         ! The error message (ErrMsg)


      !............................................................................................................................
      ! Set error status/message;
      !............................................................................................................................

      IF ( ErrID /= ErrID_None ) THEN

         IF (ErrStat /= ErrID_None) ErrMsg = TRIM(ErrMsg)//NewLine
!         ErrMsg = TRIM(ErrMsg)//' '//TRIM(Msg)  !bjj: note that when you pass a literal string "", it somehow adds an extra space at the beginning.
         ErrMsg = TRIM(ErrMsg)//'SrvD_SetParameters:'//TRIM(Msg)
         ErrStat = MAX(ErrStat, ErrID)
         
         !.........................................................................................................................
         ! Clean up if we're going to return on error: close files, deallocate local arrays
         !.........................................................................................................................
         IF ( ErrStat >= AbortErrLev ) THEN
         END IF

      END IF


   END SUBROUTINE CheckError

END SUBROUTINE SrvD_SetParameters
!----------------------------------------------------------------------------------------------------------------------------------
SUBROUTINE Yaw_CalcOutput( t, u, p, x, xd, z, OtherState, y, ErrStat, ErrMsg )
! Routine for computing the yaw output: a yaw moment. This routine is used in both loose and tight coupling.
!..................................................................................................................................

   REAL(DbKi),                     INTENT(IN   )  :: t           ! Current simulation time in seconds
   TYPE(SrvD_InputType),           INTENT(IN   )  :: u           ! Inputs at t
   TYPE(SrvD_ParameterType),       INTENT(IN   )  :: p           ! Parameters
   TYPE(SrvD_ContinuousStateType), INTENT(IN   )  :: x           ! Continuous states at t
   TYPE(SrvD_DiscreteStateType),   INTENT(IN   )  :: xd          ! Discrete states at t
   TYPE(SrvD_ConstraintStateType), INTENT(IN   )  :: z           ! Constraint states at t
   TYPE(SrvD_OtherStateType),      INTENT(INOUT)  :: OtherState  ! Other/optimization states
   TYPE(SrvD_OutputType),          INTENT(INOUT)  :: y           ! Outputs computed at t (Input only so that mesh con-
                                                                  !   nectivity information does not have to be recalculated)
   INTEGER(IntKi),                 INTENT(  OUT)  :: ErrStat     ! Error status of the operation
   CHARACTER(*),                   INTENT(  OUT)  :: ErrMsg      ! Error message if ErrStat /= ErrID_None
  
      ! local variables      
   REAL(ReKi)                   :: YawPosCom                                       ! Commanded yaw angle from user-defined routines, rad.
   REAL(ReKi)                   :: YawRateCom                                      ! Commanded yaw rate  from user-defined routines, rad/s.


INTEGER(IntKi), PARAMETER :: ControlMode_Simple = 2 
INTEGER(IntKi), PARAMETER :: ControlMode_User   = 1
INTEGER(IntKi), PARAMETER :: ControlMode_Extern = 3
   

         ! Initialize ErrStat

      ErrStat = ErrID_None
      ErrMsg  = ""


   !...................................................................
   ! Calculate standard yaw position and rate commands:
   !...................................................................

         
   IF ( t >= p%TYCOn  .AND.  p%YCMode /= ControlMode_None )  THEN   ! Time now to enable active yaw control.


      SELECT CASE ( p%YCMode )  ! Which yaw control mode are we using? (we already took care of ControlMode_None)
            
         CASE ( ControlMode_Simple )            ! Simple ... BJJ: THIS will be NEW

            
         CASE ( ControlMode_User )              ! User-defined from routine UserYawCont().
         
            CALL UserYawCont ( u%Yaw, u%YawRate, u%WindDir, u%YawErr, p%NumBl, t, p%DT, p%RootName, YawPosCom, YawRateCom )         

         CASE ( ControlMode_Extern )              ! User-defined from Simulink or Labview

            YawPosCom  = u%ExternalYawPosCom
            YawRateCom = u%ExternalYawRateCom

         CASE ( ControlMode_DLL )                                ! User-defined yaw control from Bladed-style DLL
            
            YawPosCom  = u%Yaw + OtherState%dll_data%YawRateCom*p%DT !bjj: was this: LastYawPosCom + YawRateCom*( ZTime - LastTime )
            YawRateCom =         OtherState%dll_data%YawRateCom
            
                        
      END SELECT


   ELSE  ! Do not control yaw, maintain initial (neutral) yaw angles
      
         YawPosCom  = p%YawNeut
         YawRateCom = 0.0_ReKi

   ENDIF         
         
   !...................................................................
   ! Override standard yaw control with a linear maneuver if necessary:
   !...................................................................

   IF ( t >= p%TYawManS )  THEN  ! Override yaw maneuver is occuring.


      IF ( t < OtherState%BegYawMan )  THEN  ! Override yaw maneuver is just beginning (possibly again).

         OtherState%NacYawI   = YawPosCom  !bjj: was u%Yaw                                               ! Store the initial (current) yaw, at the start of the yaw maneuver
         OtherState%YawManRat = SIGN( OtherState%YawManRat, p%NacYawF - OtherState%NacYawI )             ! Modify the sign of YawManRat based on the direction of the yaw maneuever
         OtherState%TYawManE  = p%TYawManS + ( p%NacYawF - OtherState%NacYawI ) / OtherState%YawManRat   ! Calculate the end time of the override yaw maneuver         

         OtherState%BegYawMan = t                                                                        ! Let's remember when we stored this these values

      ENDIF
      
      
      IF ( t >= OtherState%TYawManE )  THEN   ! Override yaw maneuver has ended; yaw command is fixed at NacYawF

         YawPosCom     = p%NacYawF
         YawRateCom    = 0.0_ReKi

      ELSE                             ! Override yaw maneuver in linear ramp

            ! Increment the command yaw and rate using OtherState%YawManRat         

         YawPosCom     = OtherState%NacYawI + OtherState%YawManRat*( t - p%TYawManS )
         YawRateCom    = OtherState%YawManRat                                                                           

      ENDIF   
      
   ELSE
      
      OtherState%BegYawMan = HUGE( OtherState%BegYawMan )      ! We haven't started the yaw maneuver (or need to restart)

   ENDIF
                
   !...................................................................
   ! Calculate the yaw moment:
   !...................................................................
      
   y%YawMom = - p%YawSpr *( u%Yaw     - YawPosCom  )     &          ! {-f(qd,q,t)}SpringYaw
              - p%YawDamp*( u%YawRate - YawRateCom )                ! {-f(qd,q,t)}DampYaw;
   
   
END SUBROUTINE Yaw_CalcOutput
!----------------------------------------------------------------------------------------------------------------------------------
SUBROUTINE Pitch_CalcOutput( t, u, p, x, xd, z, OtherState, y, ErrStat, ErrMsg )
! Routine for computing the pitch output: blade pitch commands. This routine is used in both loose and tight coupling.
!..................................................................................................................................

   REAL(DbKi),                     INTENT(IN   )  :: t           ! Current simulation time in seconds
   TYPE(SrvD_InputType),           INTENT(IN   )  :: u           ! Inputs at t
   TYPE(SrvD_ParameterType),       INTENT(IN   )  :: p           ! Parameters
   TYPE(SrvD_ContinuousStateType), INTENT(IN   )  :: x           ! Continuous states at t
   TYPE(SrvD_DiscreteStateType),   INTENT(IN   )  :: xd          ! Discrete states at t
   TYPE(SrvD_ConstraintStateType), INTENT(IN   )  :: z           ! Constraint states at t
   TYPE(SrvD_OtherStateType),      INTENT(INOUT)  :: OtherState  ! Other/optimization states
   TYPE(SrvD_OutputType),          INTENT(INOUT)  :: y           ! Outputs computed at t (Input only so that mesh con-
                                                                 !   nectivity information does not have to be recalculated)
   INTEGER(IntKi),                 INTENT(  OUT)  :: ErrStat     ! Error status of the operation
   CHARACTER(*),                   INTENT(  OUT)  :: ErrMsg      ! Error message if ErrStat /= ErrID_None
  
      ! local variables      
   INTEGER(IntKi)                                 :: K           ! counter for blades

INTEGER(IntKi), PARAMETER :: ControlMode_Simple = 3 
INTEGER(IntKi), PARAMETER :: ControlMode_User   = 1
INTEGER(IntKi), PARAMETER :: ControlMode_Extern = 2
   

         ! Initialize ErrStat

      ErrStat = ErrID_None
      ErrMsg  = ""


   !...................................................................
   ! Calculate standard pitch position and rate commands:
   !...................................................................
      ! Control pitch if requested:                  
      
   IF ( t >= p%TPCOn .AND.  p%PCMode /= ControlMode_None )  THEN   ! Time now to enable active pitch control.


      SELECT CASE ( p%PCMode )  ! Which pitch control mode are we using?

         CASE ( ControlMode_Simple )            ! Simple, built-in pitch-control routine.
         
            ! bjj: add this!
            
         CASE ( ControlMode_User )              ! User-defined from routine PitchCntrl().

            CALL PitchCntrl ( u%BlPitch, y%ElecPwr, u%LSS_Spd, u%TwrAccel, p%NumBl, t, p%DT, p%RootName, y%BlPitchCom )

         CASE ( ControlMode_Extern )              ! User-defined from Simulink or Labview.

            y%BlPitchCom = u%ExternalBlPitchCom                ! copy entire array
         
         CASE ( ControlMode_DLL )                                ! User-defined pitch control from Bladed-style DLL
            
            y%BlPitchCom = OtherState%dll_data%BlPitchCom(1:p%NumBl)
            
      END SELECT

   ELSE                          ! Do not control pitch yet, maintain initial pitch angles.


      ! Use the initial blade pitch angles:

      y%BlPitchCom = p%BlPitchInit


   ENDIF


   !...................................................................
   ! Override standard pitch control with a linear maneuver if necessary:
   !...................................................................

   DO K = 1,p%NumBl ! Loop through all blades


      IF ( t >= p%TPitManS(K) )  THEN  ! Override pitch maneuver is occuring for this blade.


         IF ( t < OtherState%BegPitMan(K) )  THEN  ! Override pitch maneuver is just beginning.

            OtherState%BlPitchI   (K) = u%BlPitch(K)                                                                       ! Store the initial (current) pitch, at the start of the pitch maneuver.

            OtherState%PitManRat(K) = SIGN( OtherState%PitManRat(K), p%BlPitchF(K) - OtherState%BlPitchI(K) )              ! Modify the sign of PitManRat based on the direction of the pitch maneuever
            OtherState%TPitManE (K) = p%TPitManS(K) + ( p%BlPitchF(K) - OtherState%BlPitchI(K) )/OtherState%PitManRat(K)   ! Calculate the end time of the override pitch maneuver      
         
            OtherState%BegPitMan(K) = t    ! Don't enter this part of the IF-structure again (unless we're backing up in time)

         ENDIF

      
         IF ( t >= OtherState%TPitManE(K) )  THEN      ! Override pitch maneuver has ended, blade is locked at BlPitchF.

            y%BlPitchCom(K) = p%BlPitchF(K)

         ELSE  
         
            y%BlPitchCom(K) = OtherState%BlPitchI(K) + OtherState%PitManRat(K)*( t - p%TPitManS(K) )         ! Increment the blade pitch using PitManRat
         
         END IF                  
      
      ELSE
            
         OtherState%BegPitMan(K) = HUGE( OtherState%BegPitMan(K) )      ! We haven't started the pitch maneuver (or will need to restart)

      ENDIF
 
   
   ENDDO ! K - blades   
      
   
END SUBROUTINE Pitch_CalcOutput
!----------------------------------------------------------------------------------------------------------------------------------
!**********************************************************************************************************************************
! NOTE: The following lines of code were generated by a Matlab script called "Write_ChckOutLst.m"
!      using the parameters listed in the "OutListParameters.xlsx" Excel file. Any changes to these 
!      lines should be modified in the Matlab script and/or Excel worksheet as necessary. 
! This code was generated by Write_ChckOutLst.m at 23-Mar-2013 20:32:16.
!----------------------------------------------------------------------------------------------------------------------------------
SUBROUTINE SetOutParam(OutList, p, ErrStat, ErrMsg )
! This routine checks to see if any requested output channel names (stored in the OutList(:)) are invalid. It returns a 
! warning if any of the channels are not available outputs from the module.
!  It assigns the settings for OutParam(:) (i.e, the index, name, and units of the output channels, WriteOutput(:)).
!  the sign is set to 0 if the channel is invalid.
! It sets assumes the value p%NumOuts has been set before this routine has been called, and it sets the values of p%OutParam here.
!..................................................................................................................................

   IMPLICIT                        NONE

      ! Passed variables

   CHARACTER(ChanLen),        INTENT(IN)     :: OutList(:)                        ! The list out user-requested outputs
   TYPE(SrvD_ParameterType),  INTENT(INOUT)  :: p                                 ! The module parameters
   INTEGER(IntKi),            INTENT(OUT)    :: ErrStat                           ! The error status code
   CHARACTER(*),              INTENT(OUT)    :: ErrMsg                            ! The error message, if an error occurred

      ! Local variables

   INTEGER                      :: I                                               ! Generic loop-counting index
   INTEGER                      :: J                                               ! Generic loop-counting index
   INTEGER                      :: INDX                                            ! Index for valid arrays

   LOGICAL                      :: CheckOutListAgain                               ! Flag used to determine if output parameter starting with "M" is valid (or the negative of another parameter)
   LOGICAL                      :: InvalidOutput(0:MaxOutPts)                      ! This array determines if the output channel is valid for this configuration
   CHARACTER(ChanLen)           :: OutListTmp                                      ! A string to temporarily hold OutList(I)

   CHARACTER(OutStrLenM1), PARAMETER  :: ValidParamAry(8) =  (/ &                  ! This lists the names of the allowed parameters, which must be sorted alphabetically
                               "BLPITCHC1","BLPITCHC2","BLPITCHC3","GENPWR   ","GENTQ    ","HSSBRTQ  ","YAWMOM   ", &
                               "YAWMOMCOM"/)
   INTEGER(IntKi), PARAMETER :: ParamIndxAry(8) =  (/ &                            ! This lists the index into AllOuts(:) of the allowed parameters ValidParamAry(:)
                                BlPitchC1 , BlPitchC2 , BlPitchC3 ,    GenPwr ,     GenTq ,   HSSBrTq , YawMomCom , &
                                YawMomCom /)
   CHARACTER(ChanLen), PARAMETER :: ParamUnitsAry(8) =  (/ &                     ! This lists the units corresponding to the allowed parameters
                               "(deg)     ","(deg)     ","(deg)     ","(kW)      ","(kNm)    ","(kNm)    ","(kNm)    ", &
                               "(kNm)    "/)


      ! Initialize values
   ErrStat = ErrID_None
   ErrMsg = ""
   InvalidOutput = .FALSE.


      ! Determine which inputs are not valid

   InvalidOutput(BlPitchC3) = ( p%NumBl < 3 )


   !-------------------------------------------------------------------------------------------------
   ! Allocate and set index, name, and units for the output channels
   ! If a selected output channel is not available in this module, set error flag.
   !-------------------------------------------------------------------------------------------------

   ALLOCATE ( p%OutParam(0:p%NumOuts) , STAT=ErrStat )
   IF ( ErrStat /= 0_IntKi )  THEN
      ErrStat = ErrID_Fatal
      ErrMsg  = "Error allocating memory for the ServoDyn OutParam array."
      RETURN
   ELSE
      ErrStat = ErrID_None
   ENDIF

      ! Set index, name, and units for the time output channel:

   p%OutParam(0)%Indx  = Time
   p%OutParam(0)%Name  = "Time"    ! OutParam(0) is the time channel by default.
   p%OutParam(0)%Units = "(s)"
   p%OutParam(0)%SignM = 1


      ! Set index, name, and units for all of the output channels.
      ! If a selected output channel is not available by this module set ErrStat = ErrID_Warn.

   DO I = 1,p%NumOuts

      p%OutParam(I)%Name  = OutList(I)
      OutListTmp          = OutList(I)

      ! Reverse the sign (+/-) of the output channel if the user prefixed the
      !   channel name with a "-", "_", "m", or "M" character indicating "minus".


      CheckOutListAgain = .FALSE.

      IF      ( INDEX( "-_", OutListTmp(1:1) ) > 0 ) THEN
         p%OutParam(I)%SignM = -1                         ! ex, "-TipDxc1" causes the sign of TipDxc1 to be switched.
         OutListTmp          = OutListTmp(2:)
      ELSE IF ( INDEX( "mM", OutListTmp(1:1) ) > 0 ) THEN ! We'll assume this is a variable name for now, (if not, we will check later if OutListTmp(2:) is also a variable name)
         CheckOutListAgain   = .TRUE.
         p%OutParam(I)%SignM = 1
      ELSE
         p%OutParam(I)%SignM = 1
      END IF

      CALL Conv2UC( OutListTmp )    ! Convert OutListTmp to upper case


      Indx = IndexCharAry( OutListTmp(1:OutStrLenM1), ValidParamAry )


         ! If it started with an "M" (CheckOutListAgain) we didn't find the value in our list (Indx < 1)

      IF ( CheckOutListAgain .AND. Indx < 1 ) THEN    ! Let's assume that "M" really meant "minus" and then test again
         p%OutParam(I)%SignM = -1                     ! ex, "MTipDxc1" causes the sign of TipDxc1 to be switched.
         OutListTmp          = OutListTmp(2:)

         Indx = IndexCharAry( OutListTmp(1:OutStrLenM1), ValidParamAry )
      END IF


      IF ( Indx > 0 ) THEN ! we found the channel name
         p%OutParam(I)%Indx     = ParamIndxAry(Indx)
         IF ( InvalidOutput( ParamIndxAry(Indx) ) ) THEN  ! but, it isn't valid for these settings
            p%OutParam(I)%Units = "INVALID"
            p%OutParam(I)%SignM = 0
         ELSE
            p%OutParam(I)%Units = ParamUnitsAry(Indx) ! it's a valid output
         END IF
      ELSE ! this channel isn't valid
         p%OutParam(I)%Indx  = Time                 ! pick any valid channel (I just picked "Time" here because it's universal)
         p%OutParam(I)%Units = "INVALID"
         p%OutParam(I)%SignM = 0                    ! multiply all results by zero

         ErrStat = ErrID_Warn
         ErrMsg  = p%OutParam(I)%Name//" is not an available output channel. "//TRIM(ErrMsg)
      END IF

   END DO

   RETURN
END SUBROUTINE SetOutParam
!----------------------------------------------------------------------------------------------------------------------------------
!End of code generated by Matlab script
!**********************************************************************************************************************************

!----------------------------------------------------------------------------------------------------------------------------------  
SUBROUTINE TipBrake_CalcOutput( t, u, p, x, xd, z, OtherState, y, ErrStat, ErrMsg )
! Routine for computing the tip-brake output: TBDrCon. This routine is used in both loose and tight coupling.
!..................................................................................................................................

   REAL(DbKi),                     INTENT(IN   )  :: t           ! Current simulation time in seconds
   TYPE(SrvD_InputType),           INTENT(IN   )  :: u           ! Inputs at t
   TYPE(SrvD_ParameterType),       INTENT(IN   )  :: p           ! Parameters
   TYPE(SrvD_ContinuousStateType), INTENT(IN   )  :: x           ! Continuous states at t
   TYPE(SrvD_DiscreteStateType),   INTENT(IN   )  :: xd          ! Discrete states at t
   TYPE(SrvD_ConstraintStateType), INTENT(IN   )  :: z           ! Constraint states at t
   TYPE(SrvD_OtherStateType),      INTENT(INOUT)  :: OtherState  ! Other/optimization states
   TYPE(SrvD_OutputType),          INTENT(INOUT)  :: y           ! Outputs computed at t (Input only so that mesh con-
                                                                 !   nectivity information does not have to be recalculated)
   INTEGER(IntKi),                 INTENT(  OUT)  :: ErrStat     ! Error status of the operation
   CHARACTER(*),                   INTENT(  OUT)  :: ErrMsg      ! Error message if ErrStat /= ErrID_None
  
      ! local variables      
   INTEGER(IntKi)                                 :: K           ! counter for blades


      ! Initialize ErrStat

   ErrStat = ErrID_None
   ErrMsg  = ""


   !...................................................................
   ! Calculate standard tip brake commands:
   !...................................................................
 
!--- this is the tip brake controller: !bjj: check this logic if it goes backward in time...
   DO K = 1,p%NumBl
      
      IF ( t >= OtherState%TTpBrDp(K) )  THEN                     ! The tip brakes have been deployed due to time.

         y%TBDrCon(K) = p%TBDrConN + ( p%TBDrConD - p%TBDrConN )*TBFract( t, OtherState%TTpBrDp(K), OtherState%TTpBrFl(K) )

      ELSEIF ( u%RotSpeed >= p%TBDepISp(K) )  THEN                ! The tip brakes deploy due to speed.

         OtherState%TTpBrDp(K) = t                                ! Use the check on time the next time step
         OtherState%TTpBrFl(K) = t + p%TpBrDT

         y%TBDrCon(K) = p%TBDrConN

      ELSE                                                        ! The tip brakes haven't been deployed yet.

         y%TBDrCon(K) = p%TBDrConN

      ENDIF
      
   END DO      
!---- end of the controller: returns TBDrCon, or N and D part of ElastoDyn, return 0<=TBFrac<=1, consistant with other controllers

CONTAINS
   !-------------------------------------------------------------------------------------------------------------------------------
   FUNCTION TBFract( t, BrakStrt, BrakEnd )
   ! A math S-function for the fraction of tip brake drag between normal and fully deployed operation.
   ! (This function was formerly part of RtHS.)
   !...............................................................................................................................

      IMPLICIT                        NONE


         ! Passed Variables:

      REAL(DbKi), INTENT(IN )      :: t                                               ! Current time
      REAL(DbKi), INTENT(IN )      :: BrakEnd                                         ! Time at which brakes are fully deployed
      REAL(DbKi), INTENT(IN )      :: BrakStrt                                        ! Time at which brakes are first deployed
      REAL(ReKi)                   :: TBFract                                         ! This function.


         ! Local Variables.

      REAL(DbKi)                   :: TmpVar                                          ! A temporary variable

      
      
      IF ( t <= BrakStrt )  THEN

         TBFract = 0.0

      ELSEIF ( t < BrakEnd )  THEN

         TmpVar  = ( ( t - BrakStrt )/( BrakStrt - BrakEnd ) )**2
         TBFract = TmpVar*( 2.0 - TmpVar )

      ELSE

         TBFract = 1.0

      ENDIF

      RETURN
   END FUNCTION TBFract
   !-------------------------------------------------------------------------------------------------------------------------------   
END SUBROUTINE TipBrake_CalcOutput
!----------------------------------------------------------------------------------------------------------------------------------
SUBROUTINE Torque_CalcOutput( t, u, p, x, xd, z, OtherState, y, ErrStat, ErrMsg )
! This routine calculates the drive-train torque outputs: GenTrq, ElecPwr, and HSSBrTrq
!..................................................................................................................................

   REAL(DbKi),                     INTENT(IN   )  :: t           ! Current simulation time in seconds
   TYPE(SrvD_InputType),           INTENT(IN   )  :: u           ! Inputs at t
   TYPE(SrvD_ParameterType),       INTENT(IN   )  :: p           ! Parameters
   TYPE(SrvD_ContinuousStateType), INTENT(IN   )  :: x           ! Continuous states at t
   TYPE(SrvD_DiscreteStateType),   INTENT(IN   )  :: xd          ! Discrete states at t
   TYPE(SrvD_ConstraintStateType), INTENT(IN   )  :: z           ! Constraint states at t
   TYPE(SrvD_OtherStateType),      INTENT(INOUT)  :: OtherState  ! Other/optimization states
   TYPE(SrvD_OutputType),          INTENT(INOUT)  :: y           ! Outputs computed at t (Input only so that mesh con-
                                                                 !   nectivity information does not have to be recalculated)
   INTEGER(IntKi),                 INTENT(  OUT)  :: ErrStat     ! Error status of the operation
   CHARACTER(*),                   INTENT(  OUT)  :: ErrMsg      ! Error message if ErrStat /= ErrID_None

      ! Local variables:

   COMPLEX(ReKi)                :: Current1                                        ! Current passing through the stator (amps)
   COMPLEX(ReKi)                :: Current2                                        ! Current passing through the rotor (amps)
   COMPLEX(ReKi)                :: Currentm                                        ! Magnitizing current (amps)

   REAL(ReKi)                   :: ComDenom                                        ! Common denominator of variables used in the TEC model
   REAL(ReKi)                   :: HSSBrFrac                                       ! Fraction of full braking torque {0 (off) <= HSSBrFrac <= 1 (full)} (-)
   REAL(ReKi)                   :: PwrLossS                                        ! Power loss in the stator (watts)
   REAL(ReKi)                   :: PwrLossR                                        ! Power loss in the rotor (watts)
   REAL(ReKi)                   :: PwrMech                                         ! Mechanical power (watts)
   REAL(ReKi)                   :: Slip                                            ! Generator slip.
   REAL(ReKi)                   :: SlipRat                                         ! Generator slip ratio.

   LOGICAL                      :: GenOnLine                                       ! Is the generator online?


INTEGER(IntKi), PARAMETER :: ControlMode_None   = 0
INTEGER(IntKi), PARAMETER :: ControlMode_Simple = 1
INTEGER(IntKi), PARAMETER :: ControlMode_User   = 2
INTEGER(IntKi), PARAMETER :: ControlMode_Extern = 3


      ! Initialize variables
   ErrStat = ErrID_None
   ErrMsg  = ''


      ! See if the generator is on line.
   GenOnLine = .FALSE.
   
   IF ( t < OtherState%TOff4Good .OR. EqualRealNos(t, OtherState%TOff4Good) )  THEN

      OtherState%TOff4Good = HUGE(OtherState%TOff4Good)  ! reset when the generator went off for good
      
      ! The generator is either on-line or has never been turned online.

      IF ( EqualRealNos(t,OtherState%TGenOnLine ) .OR. t > OtherState%TGenOnLine )  THEN   ! The generator is on-line.

         IF ( ( p%GenTiStp ) .AND. ( t > p%TimGenOf .OR. EqualRealNos(t,p%TimGenOf) ) )  THEN   ! Shut-down of generator determined by time, TimGenOf
            OtherState%TOff4Good = t
         ELSE
            GenOnLine = .TRUE.
         ENDIF

      ELSE                    ! The generator has never been turned online.

         IF ( p%GenTiStr )  THEN   ! Start-up of generator determined by time, TimGenOn
            IF ( t > p%TimGenOn .OR. EqualRealNos(t,p%TimGenOn) )  THEN
               GenOnLine = .TRUE.
               OtherState%TGenOnLine = t
            ELSE
               OtherState%TGenOnLine = HUGE(OtherState%TGenOnLine) !reset the first time the generator has been online
            END IF
         ELSE                    ! Start-up of generator determined by HSS speed, SpdGenOn
            IF ( u%HSS_Spd > p%SpdGenOn .OR. EqualRealNos(u%HSS_Spd, p%SpdGenOn) )  THEN
               GenOnLine = .TRUE.
               OtherState%TGenOnLine = t
            ELSE
               OtherState%TGenOnLine = HUGE(OtherState%TGenOnLine)  !reset the first time the generator has been online
            END IF
         ENDIF

      ENDIF

   ENDIF


   IF ( GenOnLine )  THEN                    ! Generator is on line.


      ! Are we doing simple variable-speed control, or using a generator model?

      SELECT CASE ( p%VSContrl )               ! Are we using variable-speed control?

         CASE ( ControlMode_None )                ! No variable-speed control.  Using a generator model.


            SELECT CASE ( p%GenModel )            ! Which generator model are we using?

               CASE ( 1_IntKi )                          ! Simple induction-generator model.


                  Slip = u%HSS_Spd - p%SIG_SySp

                  IF ( ABS( Slip ) > p%SIG_POSl  )  THEN
                     y%GenTrq  = SIGN( p%SIG_POTq, Slip )
                  ELSE
                     y%GenTrq  = Slip*p%SIG_Slop
                  ENDIF
                  !GenTrq     = GenTrq + DelGenTrq  ! Add the pertubation on generator torque, DelGenTrq.  This is used only for FAST linearization (it is zero otherwise).

                  
                  y%ElecPwr = CalculateElecPwr( y, u, p )


               CASE ( 2_IntKi )                          ! Thevenin-equivalent generator model.


                  SlipRat  = ( u%HSS_Spd - p%TEC_SySp )/p%TEC_SySp

                  y%GenTrq  = p%TEC_A0*(p%TEC_VLL**2)*SlipRat &
                             /( p%TEC_C0 + p%TEC_C1*SlipRat + p%TEC_C2*(SlipRat**2) )

                  ComDenom  = ( p%TEC_Re1 - p%TEC_RRes/SlipRat )**2 + ( p%TEC_Xe1 + p%TEC_RLR )**2
                  Current2  = CMPLX(  p%TEC_V1a*( p%TEC_Re1 - p%TEC_RRes/SlipRat )/ComDenom , &
                                     -p%TEC_V1a*( p%TEC_Xe1 + p%TEC_RLR          )/ComDenom     )
                  Currentm  = CMPLX( 0.0_ReKi , -p%TEC_V1a/p%TEC_MR )
                  Current1  = Current2 + Currentm
                  PwrLossS  = 3.0*( ( ABS( Current1 ) )**2 )*p%TEC_SRes
                  PwrLossR  = 3.0*( ( ABS( Current2 ) )**2 )*p%TEC_RRes
                  PwrMech   = y%GenTrq*u%HSS_Spd
                  y%ElecPwr = PwrMech - PwrLossS - PwrLossR


               CASE ( 3_IntKi )                          ! User-defined generator model.


         !        CALL UserGen ( u%HSS_Spd, u%LSS_Spd, p%NumBl, t, DT, p%GenEff, DelGenTrq, DirRoot, GenTrq, ElecPwr )
                  CALL UserGen ( u%HSS_Spd, u%LSS_Spd, p%NumBl, t, p%DT, p%GenEff, 0.0_ReKi, p%RootName, y%GenTrq, y%ElecPwr )

            END SELECT


         CASE ( ControlMode_Simple )              ! Simple variable-speed control.


         ! Compute the generator torque, which depends on which region we are in:

            IF ( u%HSS_Spd >= p%VS_RtGnSp )  THEN      ! We are in region 3 - torque is constant
               y%GenTrq = p%VS_RtTq
            ELSEIF ( u%HSS_Spd < p%VS_TrGnSp )  THEN   ! We are in region 2 - torque is proportional to the square of the generator speed
               y%GenTrq = p%VS_Rgn2K* (u%HSS_Spd**2)
            ELSE                                   ! We are in region 2 1/2 - simple induction generator transition region
               y%GenTrq = p%VS_Slope*( u%HSS_Spd - p%VS_SySp )
            ENDIF

            !GenTrq  = GenTrq + DelGenTrq  ! Add the pertubation on generator torque, DelGenTrq.  This is used only for FAST linearization (it is zero otherwise).


         ! It's not possible to motor using this control scheme, so the generator efficiency is always subtractive.

            y%ElecPwr = y%GenTrq*u%HSS_Spd*p%GenEff
            !y%ElecPwr = CalculateElecPwr( y, u, p )

         CASE ( ControlMode_User )                              ! User-defined variable-speed control for routine UserVSCont().


      !      CALL UserVSCont ( u%HSS_Spd, u%LSS_Spd, p%NumBl, t, DT, p%GenEff, DelGenTrq, DirRoot, GenTrq, ElecPwr )
            CALL UserVSCont ( u%HSS_Spd, u%LSS_Spd, p%NumBl, t, p%DT, p%GenEff, 0.0_ReKi, p%RootName, y%GenTrq, y%ElecPwr )

         CASE ( ControlMode_DLL )                                ! User-defined variable-speed control from Bladed-style DLL
            
            ! bjj: I believe this is how the old logic worked, but perhaps now we can be more clever about checking if the generator is off
            
            IF ( OtherState%dll_data%GenState /= 0_IntKi ) THEN ! generator is on    
               
               y%GenTrq = OtherState%dll_data%GenTrq
               y%ElecPwr = CalculateElecPwr( y, u, p )
         
               
            ELSE ! generator is off
               
               y%GenTrq   = 0.0
               y%ElecPwr  = 0.0
               
            END IF
                        
         CASE ( ControlMode_Extern )                             ! User-defined variable-speed control from Simulink or Labview.

            y%GenTrq  = u%ExternalGenTrq
            y%ElecPwr = u%ExternalElecPwr

      END SELECT


      ! Lets turn the generator offline for good if ( GenTiStp = .FALSE. ) .AND. ( ElecPwr <= 0.0 ):

      IF ( ( .NOT. p%GenTiStp ) .AND. ( y%ElecPwr <= 0.0_ReKi ) ) THEN   ! Shut-down of generator determined by generator power = 0
         y%GenTrq   = 0.0
         y%ElecPwr  = 0.0

         OtherState%TOff4Good = t
      ENDIF

   ELSE                                     ! Generator is off line.

      y%GenTrq  = 0.0
      y%ElecPwr = 0.0

   ENDIF


   !.................................................................................
   ! Calculate the fraction of applied HSS-brake torque, HSSBrFrac:
   !.................................................................................
!bjj FIX THIS >>>
!   IF ( (.NOT. EqualRealNos(t, p%THSSBrDp )) .AND. t < p%THSSBrDp )  THEN    ! HSS brake not deployed yet.
   IF ( .TRUE. )  THEN    ! HSS brake not deployed yet.
!bjj end FIX THIS <<<

      HSSBrFrac = 0.0

   ELSE                             ! HSS brake deployed.


      SELECT CASE ( p%HSSBrMode )                 ! Which HSS brake model are we using?

      CASE ( ControlMode_Simple )                 ! Simple built-in HSS brake model with linear ramp.

         IF ( t < p%THSSBrFl )  THEN ! Linear ramp
            HSSBrFrac = ( t - p%THSSBrDp )/p%HSSBrDT
         ELSE                        ! Full braking torque
            HSSBrFrac = 1.0
         ENDIF

      CASE ( ControlMode_User )                   ! User-defined HSS brake model.

         CALL UserHSSBr ( y%GenTrq, y%ElecPwr, u%HSS_Spd, p%NumBl, t, p%DT, p%RootName, HSSBrFrac )

         IF ( ( HSSBrFrac < 0.0_ReKi ) .OR. ( HSSBrFrac > 1.0_ReKi ) )  THEN   ! 0 (off) <= HSSBrFrac <= 1 (full); else Abort.
            ErrStat = ErrID_Fatal
            ErrMsg  = 'HSSBrFrac must be between 0.0 (off) and 1.0 (full) (inclusive).  Fix logic in routine UserHSSBr().'
            RETURN
         END IF

      CASE ( ControlMode_DLL )                    ! User-defined HSS brake model from Bladed-style DLL
         
         HSSBrFrac = OtherState%dll_data%HSSBrFrac         
         
      CASE ( ControlMode_Extern )                 ! HSS brake model from Labview.

         HSSBrFrac = u%ExternalHSSBrFrac

      ENDSELECT


   ENDIF
   

      ! Calculate the magnitude of HSS brake torque:

   y%HSSBrTrq = SIGN( HSSBrFrac*p%HSSBrTqF, u%HSS_Spd )  ! Scale the full braking torque by the brake torque fraction and make sure the brake torque resists motion.

   RETURN
   
CONTAINS
!..................................................................................................................................
   FUNCTION CalculateElecPwr( y, u, p )
   ! This routine calculates the electrical power (y%ElecPwr) after the electrical generator torque (y%GenTrq) has been calculated.
   !...............................................................................................................................
   TYPE(SrvD_OutputType),     INTENT(IN)  :: y                    ! Outputs computed at t (Input only so that mesh con-
   TYPE(SrvD_InputType),      INTENT(IN)  :: u                    ! Inputs at t
   TYPE(SrvD_ParameterType),  INTENT(IN)  :: p                    ! Parameters
   
   REAL(ReKi)                             :: CalculateElecPwr     ! The result of this function
   
         ! The generator efficiency is either additive for motoring,
         !   or subtractive for generating power.

      IF ( y%GenTrq >= 0.0_ReKi )  THEN
         CalculateElecPwr = y%GenTrq * u%HSS_Spd * p%GenEff
      ELSE
         CalculateElecPwr = y%GenTrq * u%HSS_Spd / p%GenEff
      ENDIF      
   
   END FUNCTION CalculateElecPwr
!..................................................................................................................................   
END SUBROUTINE Torque_CalcOutput
END MODULE ServoDyn
!**********************************************************************************************************************************
